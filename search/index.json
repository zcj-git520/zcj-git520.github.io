[{"content":"é—®é¢˜  åœ¨æ”¶é›†æœåŠ¡çš„è®¿é—®è®°å½•æ—¶ï¼Œéœ€è¦å°†è®¿é—®è®°å½•ä¿å­˜ï¼Œå®šä¹‰ç»“æ„ä½“å¦‚ä¸‹    type accessData struct { RemoteAddr string // è¿œç¨‹è®¿é—®ä¸»æœºåœ°å€ RequestURI string //è®¿é—®çš„è·¯ç”± ServerName string // è®¿é—®çš„æœåŠ¡åç§° AccessDate string //è®¿é—®çš„æ—¶é—´ RunStatus bool //æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ RunError error //è¿è¡ŒæŠ¥é”™ï¼šæŠ¥é”™ä¿¡æ¯. ServerParam interface{} // è®¿é—®æœåŠ¡çš„å‚æ•° }   é€šè¿‡ç»“æ„ä½“è½¬jsonï¼ŒåŒæ—¶é€šè¿‡getè¯·æ±‚å¾—åˆ°å›¾ä¸‹ç»“æœ \ravatar\r\n  \u0026ldquo;RunError\u0026rdquo;: {},è¢«jsonè½¬ä¸º{}çš„å­—ç¬¦ï¼Œ æ‰“å°ç»“æ„ä½“ï¼Œå‘ç°é”™è¯¯ä¿¡æ¯æ˜¯æœ‰çš„ï¼š{192.168.1.101:53364 /v1/alarms/out/d GetOutAlarms 2021-10-12 10:09:42 false æ²¡æœ‰è¿™ä¸ªæŠ¥è­¦ğŸ†”id },è¯´æ˜æ˜¯error è½¬jsoné—®é¢˜\né—®é¢˜åˆ†æä¸è§£å†³  é—®é¢˜åˆ†ææŸ¥çœ‹errorç±»å‹å®šä¹‰å‘ç°ï¼šerrorç±»å‹åªæ˜¯ä¸€ä¸ªæ¥å£ã€‚å®ƒå¯ä»¥åŒ…å«ä»»ä½•å®ç°å®ƒçš„å…·ä½“ç±»å‹çš„å€¼ è§£å†³ï¼šå°†ç»“æ„ä½“ä¸­é”™è¯¯è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ç±»å‹ï¼ŒåŒæ—¶ç”¨err.Error()è¿”å›æ˜¯é”™è¯¯çš„å­—ç¬¦ä¸²  type accessData struct { RemoteAddr string // è¿œç¨‹è®¿é—®ä¸»æœºåœ°å€ RequestURI string //è®¿é—®çš„è·¯ç”± ServerName string // è®¿é—®çš„æœåŠ¡åç§° AccessDate string //è®¿é—®çš„æ—¶é—´ RunStatus bool //æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ RunError string //è¿è¡ŒæŠ¥é”™ï¼šæŠ¥é”™ä¿¡æ¯. ServerParam interface{} // è®¿é—®æœåŠ¡çš„å‚æ•° } type error interface { Error() string }   ç»“æœå¦‚å›¾\n  \ravatar\r\n  ","date":"2021-10-09T22:00:38+08:00","permalink":"https://zcj-git520.github.io/p/golang/","title":"go errorç±»å‹è½¬json"},{"content":"go åç¨‹goroutine  åç¨‹æ˜¯ç”¨æˆ·çº§çš„çº¿ç¨‹ï¼Œæœ‰ç”¨æˆ·è‡ªå·±è°ƒåº¦ï¼Œä½¿ç”¨åç¨‹ä½¿å¾—ç¨‹åºè°ƒåº¦æ›´åŠ çµæ´»ã€‚åŒæ—¶æ¯”çº¿ç¨‹æ›´è½»é‡ï¼Œå ç”¨çš„æ ˆå†…å­˜æ›´å°‘ã€‚goè¯­è¨€å¤©ç”Ÿæ”¯æŒé«˜å¹¶å‘ï¼Œgoä½¿ç”¨åç¨‹goroutineçš„è°ƒåº¦å™¨ã€‚goroutine çš„æ ˆå†…å­˜æœ€å°å€¼ä¸º2kb(_StackMin = 2048),å®ƒä¸æ˜¯å›ºå®šä¸å˜çš„ï¼Œå¯ä»¥éšéœ€æ±‚å¢å¤§å’Œç¼©å°ã€‚goroutine ç»´æŠ¤ç€å¾ˆå¤§çš„å†…å­˜ï¼Œæ— éœ€é¢‘ç¹å¼€è¾Ÿå†…å­˜ï¼Œgoroutineæ˜¯ä½¿ç”¨M:næ¨¡å‹ï¼Œåœ¨ç”¨æˆ·æ€åˆ‡æ¢åç¨‹ï¼ŒåŠ ä¸Šåˆ›å»ºåç¨‹ä»£ä»·ä½ï¼Œä½¿å¾—cpuçš„åˆ©ç”¨ç‡å¤§å¤§æå‡ï¼Œcupçš„æ€§èƒ½å¤§å¹…åº¦çš„è¢«åˆ©ç”¨ã€‚  goroutine è°ƒåº¦å™¨GPMæ¨¡å‹ G  G å°±æ˜¯goroutineåç¨‹  type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). // è®°å½•è¯¥goroutineä½¿ç”¨çš„æ ˆ stack stack // offset known to runtime/cgo //ä¸‹é¢ä¸¤ä¸ªæˆå‘˜ç”¨äºæ ˆæº¢å‡ºæ£€æŸ¥ï¼Œå®ç°æ ˆçš„è‡ªåŠ¨ä¼¸ç¼©ï¼ŒæŠ¢å è°ƒåº¦ä¹Ÿä¼šç”¨åˆ°stackguard0 stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink _panic *_panic // innermost panic - offset known to liblink _defer *_defer // innermost defer // æ­¤goroutineæ­£åœ¨è¢«å“ªä¸ªå·¥ä½œçº¿ç¨‹æ‰§è¡Œ m *m // current m; offset known to arm liblink //è¿™ä¸ªå­—æ®µè·Ÿè°ƒåº¦åˆ‡æ¢æœ‰å…³ï¼ŒGåˆ‡æ¢æ—¶ç”¨æ¥ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œä¿å­˜ä»€ä¹ˆï¼Œçœ‹ä¸‹é¢gobufç»“æ„ä½“ sched gobuf syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc stktopsp uintptr // expected sp at top of stack, to check in traceback param unsafe.Pointer // passed parameter on wakeupï¼Œwakeupå”¤é†’æ—¶ä¼ é€’çš„å‚æ•° // çŠ¶æ€Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead atomicstatus uint32 stackLock uint32 // sigprof/scang lock; TODO: fold in to atomicstatus goid int64 //schedlinkå­—æ®µæŒ‡å‘å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªgï¼Œ //æ‰€æœ‰ä½äºå…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„gå½¢æˆä¸€ä¸ªé“¾è¡¨ schedlink guintptr waitsince int64 // approx time when the g become blocked waitreason waitReason // if status==Gwaitingï¼Œgè¢«é˜»å¡çš„åŸå›  //æŠ¢å ä¿¡å·ï¼Œstackguard0 = stackpreemptï¼Œå¦‚æœéœ€è¦æŠ¢å è°ƒåº¦ï¼Œè®¾ç½®preemptä¸ºtrue preempt bool // preemption signal, duplicates stackguard0 = stackpreempt paniconfault bool // panic (instead of crash) on unexpected fault address preemptscan bool // preempted g does scan for gc gcscandone bool // g has scanned stack; protected by _Gscan bit in status gcscanvalid bool // false at start of gc cycle, true if G has not run since last scan; TODO: remove? throwsplit bool // must not split stack raceignore int8 // ignore race detection events sysblocktraced bool // StartTrace has emitted EvGoInSyscall about this goroutine sysexitticks int64 // cputicks when syscall has returned (for tracing) traceseq uint64 // trace event sequencer tracelastp puintptr // last P emitted an event for this goroutine // å¦‚æœè°ƒç”¨äº† LockOsThreadï¼Œé‚£ä¹ˆè¿™ä¸ª g ä¼šç»‘å®šåˆ°æŸä¸ª m ä¸Š lockedm muintptr sig uint32 writebuf []byte sigcode0 uintptr sigcode1 uintptr sigpc uintptr // åˆ›å»ºè¿™ä¸ªgoroutineçš„goè¡¨è¾¾å¼çš„pc gopc uintptr // pc of go statement that created this goroutine ancestors *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors) startpc uintptr // pc of goroutine function racectx uintptr waiting *sudog // sudog structures this g is waiting on (that have a valid elem ptr); in lock order cgoCtxt []uintptr // cgo traceback context labels unsafe.Pointer // profiler labels timer *timer // cached timer for time.Sleep,ä¸º time.Sleep ç¼“å­˜çš„è®¡æ—¶å™¨ selectDone uint32 // are we participating in a select and did someone win the race? // Per-G GC state // gcAssistBytes is this G's GC assist credit in terms of // bytes allocated. If this is positive, then the G has credit // to allocate gcAssistBytes bytes without assisting. If this // is negative, then the G must correct this by performing // scan work. We track this in bytes to make it fast to update // and check for debt in the malloc hot path. The assist ratio // determines how this corresponds to scan work debt. gcAssistBytes int64 }  ä¿å­˜ç€goroutineæ‰€æœ‰ä¿¡æ¯ä»¥åŠæ ˆä¿¡æ¯ï¼Œgobufç»“æ„ä½“ï¼šcpué‡Œçš„å¯„å­˜å™¨ä¿¡æ¯  P processorå¤„ç†å™¨  è°ƒåº¦åç¨‹Gå’Œçº¿ç¨‹Mçš„å…³è”  P çš„ç»“æ„ä½“å¦‚ä¸‹ï¼š type p struct { //allpä¸­çš„ç´¢å¼• id int32 //pçš„çŠ¶æ€ status uint32 // one of pidle/prunning/... link puintptr schedtick uint32 // incremented on every scheduler call-\u0026gt;æ¯æ¬¡schedulerè°ƒç”¨+1 syscalltick uint32 // incremented on every system call-\u0026gt;æ¯æ¬¡ç³»ç»Ÿè°ƒç”¨+1 sysmontick sysmontick // last tick observed by sysmon //æŒ‡å‘ç»‘å®šçš„ mï¼Œå¦‚æœ p æ˜¯ idle çš„è¯ï¼Œé‚£è¿™ä¸ªæŒ‡é’ˆæ˜¯ nil m muintptr // back-link to associated m (nil if idle) mcache *mcache raceprocctx uintptr //ä¸åŒå¤§å°å¯ç”¨deferç»“æ„æ±  deferpool [5][]*_defer // pool of available defer structs of different sizes (see panic.go) deferpoolbuf [5][32]*_defer // Cache of goroutine ids, amortizes accesses to runtimeÂ·sched.goidgen. goidcache uint64 goidcacheend uint64 //æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ï¼Œå¯ä»¥æ— é”è®¿é—® // Queue of runnable goroutines. Accessed without lock. runqhead uint32 //é˜Ÿåˆ—å¤´ runqtail uint32 //é˜Ÿåˆ—å°¾ //æ•°ç»„å®ç°çš„å¾ªç¯é˜Ÿåˆ— runq [256]guintptr // runnext, if non-nil, is a runnable G that was ready'd by // the current G and should be run next instead of what's in // runq if there's time remaining in the running G's time // slice. It will inherit the time left in the current time // slice. If a set of goroutines is locked in a // communicate-and-wait pattern, this schedules that set as a // unit and eliminates the (potentially large) scheduling // latency that otherwise arises from adding the ready'd // goroutines to the end of the run queue. // runnext éç©ºæ—¶ï¼Œä»£è¡¨çš„æ˜¯ä¸€ä¸ª runnable çŠ¶æ€çš„ Gï¼Œ //è¿™ä¸ª G è¢« å½“å‰ G ä¿®æ”¹ä¸º ready çŠ¶æ€ï¼Œç›¸æ¯” runq ä¸­çš„ G æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ã€‚ //å¦‚æœå½“å‰ G è¿˜æœ‰å‰©ä½™çš„å¯ç”¨æ—¶é—´ï¼Œé‚£ä¹ˆå°±åº”è¯¥è¿è¡Œè¿™ä¸ª G //è¿è¡Œä¹‹åï¼Œè¯¥ G ä¼šç»§æ‰¿å½“å‰ G çš„å‰©ä½™æ—¶é—´ runnext guintptr // Available G's (status == Gdead) //ç©ºé—²çš„g gFree struct { gList n int32 } sudogcache []*sudog sudogbuf [128]*sudog tracebuf traceBufPtr // traceSweep indicates the sweep events should be traced. // This is used to defer the sweep start event until a span // has actually been swept. traceSweep bool // traceSwept and traceReclaimed track the number of bytes // swept and reclaimed by sweeping in the current sweep loop. traceSwept, traceReclaimed uintptr palloc persistentAlloc // per-P to avoid mutex _ uint32 // Alignment for atomic fields below // Per-P GC state gcAssistTime int64 // Nanoseconds in assistAlloc gcFractionalMarkTime int64 // Nanoseconds in fractional mark worker (atomic) gcBgMarkWorker guintptr // (atomic) gcMarkWorkerMode gcMarkWorkerMode // gcMarkWorkerStartTime is the nanotime() at which this mark // worker started. gcMarkWorkerStartTime int64 // gcw is this P's GC work buffer cache. The work buffer is // filled by write barriers, drained by mutator assists, and // disposed on certain GC state transitions. gcw gcWork // wbBuf is this P's GC write barrier buffer. // // TODO: Consider caching this in the running G. wbBuf wbBuf runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point pad cpu.CacheLinePad }  è®°å½•ç€Pçš„ä¿¡æ¯ï¼Œä»¥åŠGçš„çŠ¶æ€ç­‰ã€‚åŒæ—¶Pæ˜¯æœ‰ç€æœ¬åœ°é˜Ÿåˆ—ï¼Œå­˜æ”¾ç€å¸¦å¾…è¿è¡Œçš„G,æœ¬åœ°é˜Ÿåˆ—ä¸èƒ½è¶…è¿‡256ä¸ªã€‚ Pçš„æ•°é‡ï¼šæ˜¯ç”±ç¯å¢ƒå˜é‡ $GOMAXPROCS æˆ–è€…æ˜¯ç”± runtime çš„æ–¹æ³• GOMAXPROCS() å†³å®šã€‚åœ¨ç¨‹åºå¯åŠ¨å¼åˆ›å»ºï¼Œå¹¶ä¿å­˜åœ¨æ•°ç»„ä¸­ï¼Œæœ€å¤šæœ‰ GOMAXPROCS(å¯é…ç½®) ä¸ª  M æ˜¯å†…æ ¸æ€çº¿ç¨‹çš„æŠ½è±¡  ä¸»è¦çš„å·¥ä½œæ‰§è¡Œåç¨‹Gæˆ–è€…åœ¨è°ƒåº¦Gåˆ°Pä¸­  Mçš„ç»“æ„ä½“å¦‚ä¸‹ï¼š type m struct { // ç³»ç»Ÿç®¡ç†çš„ä¸€ä¸ªgï¼Œæ‰§è¡Œè°ƒåº¦ä»£ç æ—¶ä½¿ç”¨çš„ã€‚æ¯”å¦‚æ‰§è¡Œç”¨æˆ·çš„goroutineæ—¶ï¼Œå°±éœ€è¦æŠŠæŠŠç”¨æˆ· // çš„æ ˆä¿¡æ¯æ¢åˆ°å†…æ ¸çº¿ç¨‹çš„æ ˆï¼Œä»¥ä¾¿èƒ½å¤Ÿæ‰§è¡Œç”¨æˆ·goroutine g0 *g // goroutine with scheduling stack morebuf gobuf // gobuf arg to morestack divmod uint32 // div/mod denominator for arm - known to liblink // Fields not known to debuggers. procid uint64 // for debuggers, but offset not hard-coded //å¤„ç†signalçš„ g gsignal *g // signal-handling g goSigStack gsignalStack // Go-allocated signal handling stack sigmask sigset // storage for saved signal mask //çº¿ç¨‹çš„æœ¬åœ°å­˜å‚¨TLSï¼Œè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆOSçº¿ç¨‹èƒ½è¿è¡ŒMå…³é”®åœ°æ–¹ tls [6]uintptr // thread-local storage (for x86 extern register) //go å…³é”®å­—è¿è¡Œçš„å‡½æ•° mstartfn func() //å½“å‰è¿è¡Œçš„ç”¨æˆ·goroutineçš„gç»“æ„ä½“å¯¹è±¡ curg *g // current running goroutine caughtsig guintptr // goroutine running during fatal signal //å½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„Pï¼Œå¦‚æœæ²¡æœ‰å°±ä¸ºnil p puintptr // attached p for executing go code (nil if not executing go code) //æš‚å­˜ä¸å½“å‰Mæ½œåœ¨å…³è”çš„P nextp puintptr //Mä¹‹å‰è°ƒç”¨çš„P oldp puintptr // the p that was attached before executing a syscall id int64 mallocing int32 throwing int32 //å½“å‰Mæ˜¯å¦å…³é—­æŠ¢å å¼è°ƒåº¦ preemptoff string // if != \u0026quot;\u0026quot;, keep curg running on this m locks int32 dying int32 profilehz int32 //Mçš„è‡ªæ—‹çŠ¶æ€ï¼Œä¸ºtrueæ—¶Må¤„äºè‡ªæ—‹çŠ¶æ€ï¼Œæ­£åœ¨ä»å…¶ä»–çº¿ç¨‹å·G; ä¸ºfalseï¼Œä¼‘çœ çŠ¶æ€ spinning bool // m is out of work and is actively looking for work blocked bool // m is blocked on a note newSigstack bool // minit on C thread called sigaltstack printlock int8 incgo bool // m is executing a cgo call freeWait uint32 // if == 0, safe to free g0 and delete m (atomic) fastrand [2]uint32 needextram bool traceback uint8 ncgocall uint64 // number of cgo calls in total ncgo int32 // number of cgo calls currently in progress cgoCallersUse uint32 // if non-zero, cgoCallers in use temporarily cgoCallers *cgoCallers // cgo traceback if crashing in cgo call //æ²¡æœ‰goroutineè¿è¡Œæ—¶ï¼Œå·¥ä½œçº¿ç¨‹ç¡çœ  //é€šè¿‡è¿™ä¸ªæ¥å”¤é†’å·¥ä½œçº¿ç¨‹ park note // ä¼‘çœ é” //è®°å½•æ‰€æœ‰å·¥ä½œçº¿ç¨‹çš„é“¾è¡¨ alllink *m // on allm schedlink muintptr //å½“å‰çº¿ç¨‹å†…å­˜åˆ†é…çš„æœ¬åœ°ç¼“å­˜ mcache *mcache //å½“å‰Mé”å®šçš„Gï¼Œ lockedg guintptr createstack [32]uintptr // stack that created this thread. lockedExt uint32 // tracking for external LockOSThread lockedInt uint32 // tracking for internal lockOSThread nextwaitm muintptr // next m waiting for lock waitunlockf func(*g, unsafe.Pointer) bool waitlock unsafe.Pointer waittraceev byte waittraceskip int startingtrace bool syscalltick uint32 //æ“ä½œç³»ç»Ÿçº¿ç¨‹id thread uintptr // thread handle freelink *m // on sched.freem // these are here because they are too large to be on the stack // of low-level NOSPLIT functions. libcall libcall libcallpc uintptr // for cpu profiler libcallsp uintptr libcallg guintptr syscall libcall // stores syscall parameters on windows vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call) vdsoPC uintptr // PC for traceback while in VDSO call dlogPerM mOS }  è®°å½•ç€Mçš„çº¿ç¨‹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä¸€äº›P,Gä»¥åŠä¿¡å·å’Œè‡ªæ—‹é”ç­‰ä¿¡æ¯ m æ•°é‡ï¼šå¯ä»¥é€šè¿‡SetMaxThreadså‡½æ•°ï¼Œè®¾ç½® M çš„æœ€å¤§æ•°é‡ï¼Œé»˜è®¤ä¸º10000(sched.maxmcount = 10000)ï¼Œå’ŒPä¸€æ ·åœ¨ç¨‹åºå¯åŠ¨æ—¶åˆ›å»ºã€‚  å…¨å±€é˜Ÿåˆ—ï¼ˆgQueueï¼‰  Pçš„æœ¬åœ°é˜Ÿåˆ—å¯ä»¥å­˜æ”¾ç€ä¸è¶…è¿‡256ä¸ªå¾…æ‰§è¡Œçš„G,Pæ˜¯æœ‰é™çš„ï¼Œå½“Gè¿‡å¤šæ—¶ï¼Œå³å½“Pæœ¬åœ°é˜Ÿåˆ—å­˜æ”¾ä¸ä¸‹æ—¶ï¼Œå°±éœ€è¦å°†Gå­˜æ”¾åœ¨å…¨å±€é˜Ÿåˆ—ä¸­ã€‚  å…¨å±€é˜Ÿåˆ—ç»“æ„å¦‚ä¸‹ï¼š type gQueue struct { head guintptr //é˜Ÿåˆ—å¤´ tail guintptr //é˜Ÿåˆ—å°¾ } Gã€Pã€Mã€gQueueå…³ç³»  Pä¸Mæ²¡æœ‰æ•°é‡å…³ç³»ï¼Œå½“ä¸€ä¸ªMå¤„äºé˜»å¡æ—¶ï¼ŒPå…ˆæ‰¾ç©ºé—²M,æ²¡æœ‰ç©ºé—²çš„Må°±åˆ›å»ºæ–°çš„M Gä¼˜å…ˆå­˜æ”¾åœ¨Pæœ¬åœ°é˜Ÿåˆ—ä¸­ï¼Œå½“Pä¸­Gæ»¡æ—¶ï¼Œä¼šå°†Pä¸­å‰ä¸€åŠGå­˜æ”¾åœ¨å…¨å±€ä¸­ã€‚å½“Pç©ºé—²æ—¶æ—¶ï¼Œä¼šä»å…¨å±€ä¸­æ‹¿å–Gæ”¾åœ¨æœ¬åœ°é˜Ÿåˆ—ã€‚å…¨å±€æ²¡æœ‰Gæ—¶ï¼Œä¼šä»å…¶Pçš„æœ¬åœ°é˜Ÿåˆ—ä¸­æ‹¿å–ä¸€åŠåˆ°æœ¬åœ°é˜Ÿåˆ—ã€‚ å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼š\n\ravatar\r  åˆ›å»ºgoroutine newproc()å‡½æ•°  goroutine æ˜¯ç”±å‡½æ•°newprocå‡½æ•°è¿›è¡Œåˆ›å»ºçš„ï¼Œnewprocæºç å¦‚ä¸‹  // å‚æ•°ï¼šåç¨‹å‡½æ•°çš„å‚æ•°å çš„å­—èŠ‚æ•°å’Œåç¨‹å…¥å£å‡½æ•°çš„funcvalæŒ‡é’ˆ func newproc(siz int32, fn *funcval) { // è·å¾—åç¨‹å‚æ•°çš„åœ°å€= fnå‡½æ•°åœ°å€+åç§»å€¼ argp := add(unsafe.Pointer(\u0026amp;fn), sys.PtrSize) gp := getg() // è·å¾—å½“å‰Gçš„æŒ‡é’ˆ //è°ƒç”¨è€…çš„pcï¼Œä¹Ÿå°±æ˜¯æ‰§è¡Œå®Œæ­¤å‡½æ•°è¿”å›è°ƒç”¨è€…æ—¶çš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€ pc := getcallerpc() // åˆ‡æ¢åˆ°ï¼ˆç³»ç»Ÿæ ˆï¼‰g0æ ˆä¸­ systemstack(func() { //æ‰§è¡Œè°ƒç”¨newproc1()å‡½æ•°æ‰§è¡Œåˆ›å»ºåç¨‹ newg := newproc1(fn, argp, siz, gp, pc) _p_ := getg().m.p.ptr() // æŠŠå½“å‰çš„Gå­˜æ”¾åœ¨runqé˜Ÿåˆ—ä¸­ runqput(_p_, newg, true) // å¦‚æœå½“å‰ç”±ç©ºé—²çš„P,æ²¡æœ‰ç¡çœ çš„M,ä¸»åç¨‹å¼€å§‹è¿è¡Œæ—¶ if mainStarted { wakep() // åˆ›å»ºm,å¹¶è®¾ç½®ä¸ºæ´»è·ƒçŠ¶æ€ } }) }  åœ¨newprocå‡½æ•°ä¸­ä¸ºä»€ä¹ˆè¦åˆ‡æ¢åœ¨g0æ ˆä¸­æ‰§è¡Œå‘¢ï¼Ÿæ˜¯å› ä¸ºnewproc1()å‡½æ•°ä¸æ”¯æŒæ ˆå¢é•¿ï¼Œåç¨‹çš„æ ˆç©ºé—´å°(å‡ KB)ï¼Œä¸ºäº†é˜²æ­¢è¿è¡Œåç¨‹å‡½æ•°æ—¶æ ˆæº¢å‡ºï¼Œéœ€è¦åœ¨g0çš„æ ˆä¸Šè¿è¡Œï¼Œg0æ˜¯åˆ†é…åœ¨çº¿ç¨‹çš„æ ˆç©ºé—´(4MB)ä¸Šã€‚g0çš„æ ˆç©ºé—´å¾ˆå¤§ï¼Œè¿è¡Œåç¨‹å‡½æ•°æ—¶æ ˆä¸æº¢å‡ºã€‚  newproc1()å‡½æ•°  newproc1()æ˜¯åˆ›å»ºåç¨‹ æºç å¦‚ä¸‹ï¼š  å‚æ•°ï¼šåç¨‹å…¥å£ã€å‚æ•°é¦–åœ°å€ã€å‚æ•°å¤§å°ã€çˆ¶åç¨‹æŒ‡é’ˆã€è¿”å›åœ°å€ func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g { _g_ := getg() // è·å¾—å½“å‰çš„G if fn == nil { _g_.m.throwing = -1 // do not dump full stacks throw(\u0026quot;go of nil func value\u0026quot;) } // ä¸ºäº†ä¿è¯æ•°æ®ä¸€è‡´æ€§ä¼šç¦æ­¢å½“å‰mè¢«æŠ¢å  acquirem() // disable preemption because it can be holding p in a local var siz := narg siz = (siz + 7) \u0026amp;^ 7 // We could allocate a larger initial stack if necessary. // Not worth it: this is almost always an error. // 4*sizeof(uintreg): extra space added below // sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall). if siz \u0026gt;= _StackMin-4*sys.RegSize-sys.RegSize { throw(\u0026quot;newproc: function arguments too large for new goroutine\u0026quot;) } _p_ := _g_.m.p.ptr() // å°è¯•è·å–ä¸€ä¸ªç©ºé—²çš„G,å¦‚æœæ²¡æœ‰ç©ºé—²çš„G,å°±ä¼šåˆ›å»ºæ–°çš„G,åˆ†é…æ ˆç©ºé—´,å¹¶æ·»åŠ åˆ°å…¨å±€allgsä¸­ newg := gfget(_p_) // å¦‚æœæ²¡æœ‰ç©ºé—²çš„G if newg == nil { // å°±ä¼šåˆ›å»ºæ–°çš„G,åˆ†é…æ ˆç©ºé—´å¤§å°ä¸ºæœ€å°çš„2KB newg = malg(_StackMin) // è®¾ç½®çŠ¶æ€ä¸ºç­‰å¾… casgstatus(newg, _Gidle, _Gdead) //å¹¶æ·»åŠ åˆ°å…¨å±€allgsä¸­ allgadd(newg) // publishes with a g-\u0026gt;status of Gdead so GC scanner doesn't look at uninitialized stack. } if newg.stack.hi == 0 { throw(\u0026quot;newproc1: newg missing stack\u0026quot;) } if readgstatus(newg) != _Gdead { throw(\u0026quot;newproc1: new g is not Gdead\u0026quot;) } totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame totalSize += -totalSize \u0026amp; (sys.SpAlign - 1) // align to spAlign sp := newg.stack.hi - totalSize spArg := sp if usesLR { // caller's LR *(*uintptr)(unsafe.Pointer(sp)) = 0 prepGoExitFrame(sp) spArg += sys.MinFrameSize } if narg \u0026gt; 0 { // å¦‚æœåç¨‹å…¥å£å‡½æ•°ç”±å‚æ•°ï¼Œä¼šå°†å‚æ•°ç§»åŠ¨åœ¨åç¨‹æ ˆä¸­ memmove(unsafe.Pointer(spArg), argp, uintptr(narg)) // This is a stack-to-stack copy. If write barriers // are enabled and the source stack is grey (the // destination is always black), then perform a // barrier copy. We do this *after* the memmove // because the destination stack may have garbage on // it. if writeBarrier.needed \u0026amp;\u0026amp; !_g_.m.curg.gcscandone { f := findfunc(fn.fn) stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps)) if stkmap.nbit \u0026gt; 0 { // We're in the prologue, so it's always stack map index 0. bv := stackmapdata(stkmap, 0) bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata) } } } // åˆå§‹åŒ–newg.schedè°ƒåº¦ç›¸å…³çš„ä¿¡æ¯ memclrNoHeapPointers(unsafe.Pointer(\u0026amp;newg.sched), unsafe.Sizeof(newg.sched)) newg.sched.sp = sp //è®¾ç½®ä¸ºåç¨‹æ ˆæŒ‡é’ˆ newg.stktopsp = sp // è®¾ç½®ä¸ºæŒ‡å‘åç¨‹å…¥å£å‡½æ•°çš„å…¥å£ï¼Œå½“åç¨‹è°ƒåº¦æ‰§è¡Œæ—¶ï¼Œè¿è¡Œåç¨‹å‡½æ•° newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function newg.sched.g = guintptr(unsafe.Pointer(newg)) gostartcallfn(\u0026amp;newg.sched, fn) // è®¾ç½®ä¸ºçˆ¶åç¨‹è°ƒç”¨newprocå‡½æ•°ç»“æŸåçš„è¿”å›åœ°å€ newg.gopc = callerpc newg.ancestors = saveAncestors(callergp) // è®¾ç½®startpcä¸ºåç¨‹å…¥å­”å‡½æ•°çš„èµ·å§‹åœ°å€ newg.startpc = fn.fn if _g_.m.curg != nil { newg.labels = _g_.m.curg.labels } if isSystemGoroutine(newg, false) { atomic.Xadd(\u0026amp;sched.ngsys, +1) } // è®¾ç½®åç¨‹ä¸ºè¿è¡ŒçŠ¶æ€ casgstatus(newg, _Gdead, _Grunnable) if _p_.goidcache == _p_.goidcacheend { // Sched.goidgen is the last allocated id, // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch]. // At startup sched.goidgen=0, so main goroutine receives goid=1. _p_.goidcache = atomic.Xadd64(\u0026amp;sched.goidgen, _GoidCacheBatch) _p_.goidcache -= _GoidCacheBatch - 1 _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch } // ç»™åç¨‹èµ‹äºˆä¸€ä¸ªå”¯ä¸€çš„goid newg.goid = int64(_p_.goidcache) _p_.goidcache++ if raceenabled { newg.racectx = racegostart(callerpc) } if trace.enabled { traceGoCreate(newg, newg.startpc) } // å…è®¸å½“å‰mè¢«æŠ¢å  releasem(_g_.m) return newg } å›¾ç¤ºå¦‚ä¸‹\n\ravatar\r\n æ€»ç»“goroutineåˆ›å»ºè¿‡ç¨‹   ä¸ºäº†ä¿è¯æ•°æ®ä¸€è‡´æ€§ä¼šç¦æ­¢å½“å‰mè¢«æŠ¢å  å°è¯•è·å–ä¸€ä¸ªç©ºé—²çš„G,å¦‚æœæ²¡æœ‰ç©ºé—²çš„G,å°±ä¼šåˆ›å»ºæ–°çš„G,åˆ†é…æ ˆç©ºé—´,çŠ¶æ€ä¸ºç­‰å¾…å¹¶æ·»åŠ åˆ°å…¨å±€allgsä¸­ å¦‚æœåç¨‹å…¥å£å‡½æ•°ç”±å‚æ•°ï¼Œä¼šå°†å‚æ•°ç§»åŠ¨åœ¨åç¨‹æ ˆä¸­ åˆå§‹åŒ–newg.schedè°ƒåº¦ç›¸å…³çš„ä¿¡æ¯ï¼Œè®¾ç½®çŠ¶æ€è¿è¡Œ å¾—åˆ°å”¯ä¸€çš„goid, å¹¶æ·»åŠ åˆ°runqé˜Ÿåˆ—ä¸­ å¦‚æœå½“å‰æœ‰ç©ºé—²çš„P,æ²¡æœ‰ç¡çœ çš„M,å¹¶ä¸”ä¸»åç¨‹å¼€å§‹è¿è¡Œæ—¶ï¼Œå°±ä¼šåˆ›å»ºæ–°çš„æ´»è·ƒçš„M å½“gè¿è¡Œç»“æŸåï¼Œè®¾ç½®å…è®¸å½“å‰mè¢«æŠ¢å   è°ƒåº¦å™¨çš„è®¾è®¡ç­–ç•¥  å‡å°‘çº¿ç¨‹çš„åˆ›å»ºä¸é”€æ¯cupçš„å¼€é”€ï¼ŒGPMæ˜¯çº¿ç¨‹çš„å¤ç”¨ã€‚å³å½“æ²¡æœ‰ å¯è¿è¡Œçš„Gæ—¶ï¼Œå°†Mä¼‘çœ ,Pç©ºé—²ã€‚å½“æœ‰å¯æ‰§è¡ŒGæ˜¯æ‰¾ç©ºé—²çš„Pï¼Œåœ¨å°†Må”¤é†’ï¼Œæ‰§è¡ŒGï¼Œç›´åˆ° main.main é€€å‡ºï¼Œruntime.main æ‰§è¡Œ Defer å’Œ Panic å¤„ç†ï¼Œæˆ–è°ƒç”¨ runtime.exit é€€å‡ºç¨‹åº work stealing æœºåˆ¶ï¼šå½“æœ¬çº¿ç¨‹æ— å¯è¿è¡Œçš„ G æ—¶ï¼Œå°è¯•ä»å…¶ä»–çº¿ç¨‹ç»‘å®šçš„ P å·å– Gï¼Œè€Œä¸æ˜¯é”€æ¯çº¿ç¨‹ã€‚ hand off æœºåˆ¶ï¼š\n1.å½“æœ¬çº¿ç¨‹å› ä¸º G è¿›è¡Œç³»ç»Ÿè°ƒç”¨é˜»å¡æ—¶ï¼Œçº¿ç¨‹é‡Šæ”¾ç»‘å®šçš„ Pï¼ŒæŠŠ P è½¬ç§»ç»™å…¶ä»–ç©ºé—²çš„çº¿ç¨‹æ‰§è¡Œã€‚\n2.åˆ©ç”¨å¹¶è¡Œï¼šGOMAXPROCS è®¾ç½® P çš„æ•°é‡ï¼Œæœ€å¤šæœ‰ GOMAXPROCS ä¸ªçº¿ç¨‹åˆ†å¸ƒåœ¨å¤šä¸ª CPU ä¸ŠåŒæ—¶è¿è¡Œã€‚GOMAXPROCS ä¹Ÿé™åˆ¶äº†å¹¶å‘çš„ç¨‹åº¦ï¼Œæ¯”å¦‚ GOMAXPROCS = æ ¸æ•°/2ï¼Œåˆ™æœ€å¤šåˆ©ç”¨äº†ä¸€åŠçš„ CPU æ ¸è¿›è¡Œå¹¶è¡Œã€‚ 3.æŠ¢å ï¼šåœ¨ coroutine ä¸­è¦ç­‰å¾…ä¸€ä¸ªåç¨‹ä¸»åŠ¨è®©å‡º CPU æ‰æ‰§è¡Œä¸‹ä¸€ä¸ªåç¨‹ï¼Œåœ¨ Go ä¸­ï¼Œä¸€ä¸ª goroutine æœ€å¤šå ç”¨ CPU 10msï¼Œé˜²æ­¢å…¶ä»– goroutine è¢«é¥¿æ­»ï¼Œè¿™å°±æ˜¯ goroutine ä¸åŒäº coroutine çš„ä¸€ä¸ªåœ°æ–¹ã€‚\n4.å…¨å±€ G é˜Ÿåˆ—ï¼šåœ¨æ–°çš„è°ƒåº¦å™¨ä¸­ä¾ç„¶æœ‰å…¨å±€ G é˜Ÿåˆ—ï¼Œä½†åŠŸèƒ½å·²ç»è¢«å¼±åŒ–äº†ï¼Œå½“ M æ‰§è¡Œ work stealing ä»å…¶ä»– P å·ä¸åˆ° G æ—¶ï¼Œå®ƒå¯ä»¥ä»å…¨å±€ G é˜Ÿåˆ—è·å– Gã€‚ è°ƒåº¦å¦‚å›¾æ‰€ç¤º\n\ravatar\r  å‚è€ƒæ–‡çŒ® 1ã€[å…¸è—ç‰ˆ]Golangè°ƒåº¦å™¨GPMåŸç†ä¸è°ƒåº¦å…¨åˆ†æ\n","date":"2021-10-06T22:00:38+08:00","permalink":"https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B/","title":"go goroutineä¸gmpæ¨¡å‹"},{"content":"ç†è§£è¿›ç¨‹ä¸çº¿ç¨‹ è¿›ç¨‹  è¿›ç¨‹æ˜¯ç¨‹åºä¸€æ¬¡åŠ¨æ€æ‰§è¡Œè¿‡ç¨‹ã€è¿›ç¨‹æ˜¯æ“ä½œç³»ç»Ÿåˆ†é…èµ„æº(å†…å­˜ã€ioèµ„æºã€cpuç­‰)å’Œèµ„æºè°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚ç¨‹åºæ˜¯æŒ‡ä»¤ã€æ•°æ®åŠå…¶ç»„ç»‡å½¢å¼çš„æè¿°ï¼Œè¿›ç¨‹æ˜¯ç¨‹åºçš„å®ä½“ã€‚ è¿›ç¨‹æ˜¯ç”± è¿›ç¨‹æ§åˆ¶å—PCBã€ç›¸å…³ç¨‹åºæ®µå’Œè¯¥ç¨‹åºæ®µè¿›è¡Œæ“ä½œçš„æ•°æ®ç»“æ„é›†ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆã€‚ è¿›ç¨‹çš„äº”ä¸­çŠ¶æ€ï¼šåˆ›å»ºã€å°±ç»ªã€è¿è¡Œã€é˜»å¡ã€ç»ˆæ­¢ äº”ç§çŠ¶æ€è½¬æ¢å¦‚å›¾æ‰€ç¤ºï¼š\n\ravatar\r  çº¿ç¨‹  çº¿ç¨‹æ˜¯cupè°ƒåº¦å’Œåˆ†é…çš„åŸºæœ¬å•ä½ä¹Ÿæ˜¯cupæ‰§è¡Œçš„æœ€å°å•ä½, æœ‰ç‹¬ç«‹çš„æ ˆç©ºé—´ï¼Œå…±äº«å †ç©ºé—´ã€‚  è¿›ç¨‹ä¸çº¿ç¨‹çš„å…³ç³»  ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åˆ›å»ºå’Œæ’¤é”€å¤šä¸ªçº¿ç¨‹ï¼Œ ä¸€ä¸ªè¿›ç¨‹å¿…é¡»æœ‰ä¸€ä¸ªçº¿ç¨‹(ä¸»çº¿ç¨‹), çº¿ç¨‹å…±äº«è¿›ç¨‹æ‰€æœ‰èµ„æºï¼Œè¿›ç¨‹æ˜¯çº¿ç¨‹çš„å®¹å™¨ï¼Œå…³ç³»å¦‚å›¾æ‰€ç¤ºï¼š\n\ravatar\r  å¹¶å‘ä¸å¹¶è¡Œ å¹¶å‘  å¹¶å‘ï¼šå¤šè¿›ç¨‹(çº¿ç¨‹)ç¨‹åºåœ¨ä¸€ä¸ªæ ¸cupä¸²è¡Œè¿è¡Œï¼Œå½“ä¸€ä¸ªè¿›ç¨‹(çº¿ç¨‹)é˜»å¡çš„æ—¶å€™ï¼Œåˆ‡æ¢åˆ°å¦å¤–ç­‰å¾…æ‰§è¡Œçš„è¿›ç¨‹(çº¿ç¨‹) å¦‚å›¾\n\ravatar\r  å¹¶è¡Œ  å¹¶è¡Œï¼šå¤šçº¿ç¨‹ç¨‹åºåœ¨å¤šæ ¸cupå¹¶è¡Œè¿è¡Œï¼Œå¦‚å›¾\n\ravatar\r  ç”¨æˆ·æ€å’Œå†…æ ¸æ€(ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´) ç‰¹æƒçº§åˆ’åˆ†  cpuä¸€å…±æœ‰0ï½4å››ä¸ªç‰¹æƒçº§ï¼ŒR0çº§æœ€é«˜ï¼ŒR3çº§æœ€ä½ã€‚ç”¨æˆ·æ€æŒ‡çš„æ˜¯ï¼šç¨‹åºè¿è¡Œåœ¨R3çº§ä»¥ä¸Šï¼Œé€šå¸¸åœ¨åº”ç”¨ç¨‹åºä¸­è¿è¡Œï¼Œå†…æ ¸æ€æ˜¯æŒ‡ï¼šç¨‹åºè¿è¡Œåœ¨R0çº§ä»¥ä¸Šï¼Œé€šå¸¸åœ¨å†…æ ¸ä¸­è¿è¡Œã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å†™çš„åº”ç”¨ç¨‹åºå°±æ˜¯è¿è¡Œåœ¨R3çº§è¡£ä»¥ä¸Šã€‚  3ä¸­ç§ç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„åˆ‡æ¢  ç³»ç»Ÿè°ƒç”¨ï¼šç”¨æˆ·æ€è¿›ç¨‹é€šè¿‡ç³»ç»Ÿè°ƒç”¨ç”³è¯·ä½¿ç”¨æ“ä½œç³»ç»Ÿæä¾›çš„æœåŠ¡ç¨‹åºå®Œæˆå·¥ä½œï¼Œæ¯”å¦‚å‰ä¾‹ä¸­fork()å®é™…ä¸Šå°±æ˜¯æ‰§è¡Œäº†ä¸€ä¸ªåˆ›å»ºæ–°è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨ã€‚è€Œç³»ç»Ÿè°ƒç”¨çš„æœºåˆ¶å…¶æ ¸å¿ƒè¿˜æ˜¯ä½¿ç”¨äº†æ“ä½œç³»ç»Ÿä¸ºç”¨æˆ·ç‰¹åˆ«å¼€æ”¾çš„ä¸€ä¸ªä¸­æ–­æ¥å®ç°ï¼Œä¾‹å¦‚Linuxçš„int 80hä¸­æ–­ã€‚ å¼‚å¸¸ï¼šå½“CPUåœ¨æ‰§è¡Œè¿è¡Œåœ¨ç”¨æˆ·æ€ä¸‹çš„ç¨‹åºæ—¶ï¼Œå‘ç”Ÿäº†æŸäº›äº‹å…ˆä¸å¯çŸ¥çš„å¼‚å¸¸ï¼Œè¿™æ—¶ä¼šè§¦å‘ç”±å½“å‰è¿è¡Œè¿›ç¨‹åˆ‡æ¢åˆ°å¤„ç†æ­¤å¼‚å¸¸çš„å†…æ ¸ç›¸å…³ç¨‹åºä¸­ï¼Œä¹Ÿå°±è½¬åˆ°äº†å†…æ ¸æ€ï¼Œæ¯”å¦‚ç¼ºé¡µå¼‚å¸¸ã€‚ å¤–å›´è®¾å¤‡çš„ä¸­æ–­ï¼š å½“å¤–å›´è®¾å¤‡å®Œæˆç”¨æˆ·è¯·æ±‚çš„æ“ä½œåï¼Œä¼šå‘CPUå‘å‡ºç›¸åº”çš„ä¸­æ–­ä¿¡å·ï¼Œè¿™æ—¶CPUä¼šæš‚åœæ‰§è¡Œä¸‹ä¸€æ¡å³å°†è¦æ‰§è¡Œçš„æŒ‡ä»¤è½¬è€Œå»æ‰§è¡Œä¸ä¸­æ–­ä¿¡å·å¯¹åº”çš„å¤„ç†ç¨‹åºï¼Œå¦‚æœå…ˆå‰æ‰§è¡Œçš„æŒ‡ä»¤æ˜¯ç”¨æˆ·æ€ä¸‹çš„ç¨‹åºï¼Œé‚£ä¹ˆè¿™ä¸ªè½¬æ¢çš„è¿‡ç¨‹è‡ªç„¶ä¹Ÿå°±å‘ç”Ÿäº†ç”±ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„åˆ‡æ¢ã€‚æ¯”å¦‚ç¡¬ç›˜è¯»å†™æ“ä½œçš„å®Œæˆï¼Œç³»ç»Ÿä¼šåˆ‡æ¢åˆ°ç¡¬ç›˜è¯»å†™çš„ä¸­æ–­å¤„ç†ç¨‹åºä¸­æ‰§è¡Œåç»­æ“ä½œç­‰ã€‚ ç”¨æˆ·æ€ä¸å†…æ ¸æ€ç»“æ„å¦‚å›¾ï¼š\n\ravatar\r ç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„åˆ‡æ¢æ˜¯éœ€è¦å¼€é”€ æ¥æºï¼šlinuxç”¨æˆ·æ€å’Œå†…æ ¸æ€ç†è§£(https://www.cnblogs.com/weifeng1463/p/11660260.html)  è¿›ç¨‹ä¸çº¿ç¨‹ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„å¼€é”€  å¤šè¿›ç¨‹(çº¿ç¨‹)å¯ä»¥æé«˜cpuçš„åˆ©ç”¨ç‡ï¼Œå‡å°‘ç¨‹åºé˜»å¡å¸¦æ¥cpué—²ç½®çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯æå‡cpuçš„è¿è¡Œæ—¶é—´ç‰‡ï¼Œä½†æ˜¯è¿‡å¤šçš„åˆ›å»ºè¿›ç¨‹(çº¿ç¨‹)ä¹Ÿä¼šèŠ±è´¹é¢å¤–çš„cpuæ—¶é—´ç‰‡è¿›è¡Œè¿›ç¨‹(çº¿ç¨‹)çš„èŠ±é”€ã€‚è¿›ç¨‹çš„åˆ›å»ºã€å°±ç»ªã€è¿è¡Œã€é˜»å¡ã€ç»ˆæ­¢ï¼Œè¿™äº›éƒ½ä¼šå¸¦æ¥cupèŠ±é”€ã€‚ä¾‹å¦‚åœ¨32ä½çš„æ“ä½œç³»ç»Ÿä¸­åˆ›å»ºä¸€ä¸ªè¿›ç¨‹éœ€è¦å¼€è¾Ÿ4GBçš„è™šæ‹Ÿå†…å­˜ç©ºé—´ï¼Œåˆ›å»ºä¸€ä¸ªçº¿ç¨‹éœ€è¦å ç”¨çº¦4MBçš„å†…å­˜ã€‚\n\ravatar\r è¿›ç¨‹(çº¿ç¨‹)çš„è°ƒåº¦ä¹Ÿä¼šå¸¦æ¥cupçš„èŠ±é”€ã€‚cupè¿›ç¨‹(çº¿ç¨‹)çš„è°ƒåº¦å°±æ˜¯è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢ï¼Œè¿›ç¨‹(çº¿ç¨‹)çš„åˆ‡æ¢å°±ä¼šè¿›è¡Œçº¿ç¨‹åœ¨å†…æ ¸æ€çš„è°ƒåº¦ã€‚cupåˆ‡æ¢çš„å†…æ ¸æ€çš„çº¿ç¨‹ï¼Œä¸æ“ä½œç”¨æˆ·æ€çš„çº¿ç¨‹ï¼Œç”¨æˆ·æ€çº¿ç¨‹é€šè¿‡ç³»ç»Ÿè°ƒç”¨è§¦å‘å†…æ ¸çº¿ç¨‹ã€‚ ä¸ºå‡å°‘cpuå†…æ ¸æ€çº¿ç¨‹ä¹‹é—´çš„åˆ‡æ¢ï¼Œæ“ä½œç³»ç»Ÿä¸­ä½¿ç”¨(ç”¨æˆ·æ€è¿›ç¨‹(çº¿ç¨‹):å†…æ ¸æ€è¿›ç¨‹(çº¿ç¨‹))1:1ï¼Œç”¨æˆ·æ€ç›´æ¥é€šè¿‡ç³»ç»Ÿï¼Œç›´æ¥ä¸å†…æ ¸æ€çš„çº¿ç¨‹ä¸€ä¸€å¯¹åº”ã€‚å¦‚å›¾\n\ravatar\r ç”¨æˆ·æ€ä¸€ä¸ªè¿›ç¨‹(çº¿ç¨‹)å¯¹åº”ä¸€ä¸ªå†…æ ¸æ€çš„è¿›ç¨‹(çº¿ç¨‹)æ˜¯å‡å°‘äº†å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢çš„èŠ±é”€ï¼Œä½†æ˜¯ä¹Ÿå¢åŠ äº†å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ›å»ºçš„å¼€é”€ã€‚å‡å°‘å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢ä¸åˆ›å»ºå¸¦æ¥çš„å¼€é”€ï¼Œæ“ä½œç³»ç»Ÿä¸­ä½¿ç”¨(ç”¨æˆ·æ€è¿›ç¨‹(çº¿ç¨‹):å†…æ ¸æ€è¿›ç¨‹(çº¿ç¨‹))N:1ï¼Œå‡å°‘å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)çš„åˆ›å»ºï¼ŒåŒæ—¶åœ¨ç”¨æˆ·æ€è¿›è¡Œçº¿ç¨‹çš„ä¹‹é—´çš„åˆ‡æ¢ï¼Œä¸ç‰µè¿å†…æ ¸æ€çº¿ç¨‹çš„åˆ‡æ¢ï¼Œå‡å°‘cupçš„èŠ±é”€ã€‚ \ravatar\r è™½ç„¶N:1å‡å°‘å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢ä¸åˆ›å»ºå¸¦æ¥çš„å¼€é”€ï¼Œä½†æ˜¯å½“ç”¨æˆ·æ€çš„è¿›ç¨‹(çº¿ç¨‹)é˜»å¡æ—¶ï¼Œå…¶ä»–è¿›ç¨‹(çº¿ç¨‹)å°±åªèƒ½ç­‰å¾…ï¼Œè¿™é€ æˆä¸å•çº¿ç¨‹ä¸€æ ·çš„é—®é¢˜ã€‚æ“ä½œç³»ç»Ÿç»“åˆ1:1å’Œn:1æ¨¡å‹çš„æœ‰ç‚¹å½¢æˆn:mæ¨¡å‹ï¼Œå†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)è¿›å…¥é˜»å¡çŠ¶æ€æ—¶ï¼Œ ç”¨æˆ·æ€çš„è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢å¦ä¸€ä¸ªå†…æ ¸æ€ä¸­çš„çº¿ç¨‹ã€‚\n\ravatar\r  åç¨‹  åç¨‹å’Œçº¿ç¨‹ä¸€æ ·æœ‰ç‹¬ç«‹çš„æ ˆç©ºé—´ï¼Œå…±äº«å †ç©ºé—´ï¼Œæ˜¯ç”¨æˆ·çº§çš„çº¿ç¨‹ï¼Œæ˜¯æœ‰ç”¨æˆ·è‡ªå·±è°ƒåº¦ã€‚ä¸€ä¸ªçº¿ç¨‹å¯ä»¥åˆ›å»ºå¤šä¸ªåç¨‹ï¼Œåç¨‹æ˜¯è½»é‡çº§çš„çº¿ç¨‹ã€‚åˆ›å»ºä¸€ä¸ªåç¨‹åªéœ€è¦å ç”¨4~5kBçš„è™šæ‹Ÿå†…å­˜ï¼Œåˆ›å»ºåç¨‹çš„å¼€é”€ç›¸æ¯”è¿›ç¨‹ä¸çº¿ç¨‹ä½å¤ªå¤šäº†ã€‚\n\ravatar\r  å‚è€ƒæ–‡çŒ® 1ã€å¹²è´§ | è¿›ç¨‹ã€çº¿ç¨‹ã€åç¨‹ 10 å¼ å›¾è®²æ˜ç™½äº†ï¼ 2ã€[å…¸è—ç‰ˆ]Golangè°ƒåº¦å™¨GPMåŸç†ä¸è°ƒåº¦å…¨åˆ†æ\n","date":"2021-09-28T22:00:38+08:00","permalink":"https://zcj-git520.github.io/p/c/c-/","title":"è¿›ç¨‹ã€çº¿ç¨‹ã€åç¨‹"},{"content":"goland åŸºç¡€ä¹‹map mapçš„å†…éƒ¨ç»“æ„  go mapæ˜¯ä½¿ç”¨çš„å“ˆå¸Œè¡¨æ„å»ºçš„ mapçš„ç»“æ„å¯åˆ†ä¸ºï¼šhmapçš„ç»“æ„ä½“å’Œbmap(æ¡¶)ï¼Œhmapç»“æ„ä½“è®°å½•è¿™mapçš„åŸºç¡€ä¿¡æ¯(åŒ…æ‹¬mapå­˜å‚¨ä¸ªæ•°ï¼Œ æ¡¶çš„ä¸ªæ•°ï¼Œhashç§å­ï¼Œæ¡¶çš„æ•°æ®ï¼Œæ‰©å®¹æ—¶æ—§æ¡¶çš„æ•°æ®ä»¥åŠè¿ç§»ä¸ªæ•°ï¼ˆmapæ‰©å®¹ä¸æ˜¯ä¸€æ¬¡æ€§è¿ç§»å®Œï¼‰) æºç å¦‚ä¸‹    å®šä¹‰hmapçš„ç»“æ„ï¼š type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. // map å­˜å‚¨å…ƒç´ çš„è®¡æ•° count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 // mapçš„çŠ¶æ€æ ‡è¯†ï¼Œæ¡¶æ˜¯å¦åœ¨å¢æ”¹ï¼Œæ‰©å®¹æˆ–è€…ç¼©å®¹ //æ¡¶çš„ä¸ªæ•°/é‡‡ç”¨çš„ä¸è¿ç®—æ³•è®¡ç®—æ¡¶çš„ä¸ªæ•°ï¼Œæ¡¶çš„ä¸ªæ•°ä¸º2çš„æ•´æ•°æ¬¡å¹‚ B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) //æº¢å‡ºçš„æ¡¶çš„æ•°é‡çš„è¿‘ä¼¼å€¼ noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed //æŒ‡å‘æ¡¶æ•°æ®çš„æŒ‡é’ˆ buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. // æŒ‡å‘æ—§æ¡¶æ•°æ®çš„æŒ‡é’ˆ oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing //æ‰©å®¹è®¡æ•° nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) // ä¿å­˜æº¢å‡ºæ¡¶çš„é“¾è¡¨å’Œæœªä½¿ç”¨çš„æº¢å‡ºæ¡¶æ•°ç»„çš„é¦–åœ°å€ extra *mapextra // optional fields } // æ¡¶çš„å®ç°ç»“æ„ type bmap struct { // å½“å‰ç‰ˆæœ¬bucketCntçš„å€¼æ˜¯8ï¼Œä¸€ä¸ªæ¡¶æœ€å¤šå­˜å‚¨8ä¸ªkey-valueå¯¹ tophash [bucketCnt]uint8 }  bmapå­˜å‚¨ç»“æ„å¦‚å›¾æ‰€ç¤º\n\ravatar\r å‰8ä¸ªæ˜¯hashå€¼ï¼Œ8ä¸ªkeyå’Œ8ä¸ªvalueã€åé¢æ˜¯æº¢å‡ºæ¡¶çš„æŒ‡é’ˆ æº¢å‡ºæ¡¶æ˜¯å‡å°‘mapæ‰©å®¹æ¬¡æ•°ï¼Œæº¢å‡ºæ¡¶çš„ç»“æ„ä¸bmapæ¡¶çš„ç»“æ„ä¸€æ ·çš„ æº¢å‡ºæ¡¶çš„åŸºç¡€ç»“æ„ï¼š    type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // type as containing no pointers. This avoids scanning such maps. // However, bmap.overflow is a pointer. In order to keep overflow buckets // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // overflow and oldoverflow are only used if key and elem do not contain pointers. // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap //è®°å½•å·²ç»è¢«ä½¿ç”¨çš„æº¢å‡ºæ¡¶ oldoverflow *[]*bmap // æ‰©å®¹é˜¶æ®µæ—§çš„æº¢å‡ºæ¡¶ // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap //æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—²çš„æº¢å‡ºæ¡¶ }  å½“æ¡¶çš„ä¸ªæ•°å¤§äº2çš„4æ¬¡æ–¹æ—¶å°±ä¼šä½¿ç”¨æº¢å‡ºæ¡¶æºç å¦‚ä¸‹  func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) { // æ¡¶çš„ä¸ªæ•° base := bucketShift(b) nbuckets := base // For small b, overflow buckets are unlikely. // Avoid the overhead of the calculation. if b \u0026gt;= 4 { // ä½¿ç”¨æº¢å‡ºæ¡¶ // Add on the estimated number of overflow buckets // required to insert the median number of elements // used with this value of b. nbuckets += bucketShift(b - 4)//è®¡ç®—æº¢å‡ºæ¡¶çš„æ•°é‡å’Œä¸æ˜¯æº¢å‡ºæ¡¶çš„æ•°é‡çš„å’Œ sz := t.bucket.size * nbuckets up := roundupsize(sz) if up != sz { nbuckets = up / t.bucket.size //å¾—å‡ºæ¡¶çš„æ•°é‡ } } if dirtyalloc == nil { // æ²¡æœ‰è¢«åˆ›å»ºæ¡¶ï¼Œç”³è¯·åˆ›å»ºæ¡¶çš„ï¼Œè¿”å›æ¡¶çš„é¦–åœ°å€ buckets = newarray(t.bucket, int(nbuckets)) } else { // dirtyalloc was previously generated by // the above newarray(t.bucket, int(nbuckets)) // but may not be empty. buckets = dirtyalloc size := t.bucket.size * nbuckets if t.bucket.ptrdata != 0 { memclrHasPointers(buckets, size) } else { memclrNoHeapPointers(buckets, size) } } if base != nbuckets { // We preallocated some overflow buckets. // To keep the overhead of tracking these overflow buckets to a minimum, // we use the convention that if a preallocated overflow bucket's overflow // pointer is nil, then there are more available by bumping the pointer. // We need a safe non-nil pointer for the last overflow bucket; just use buckets. //ç©ºé—²æ¡¶çš„åœ°å€ nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) last.setoverflow(t, (*bmap)(buckets)) } return buckets, nextOverflow }  å¦‚å›¾æ‰€ç¤º \ravatar\r ä½¿ç”¨mapæ—¶éœ€è¦make(map[type]type,len,cap)æ‰èƒ½ä½¿ç”¨ã€‚ make æºç å¦‚ä¸‹ï¼š    func makemap(t *maptype, hint int, h *hmap) *hmap { // åˆ¤æ–­æ˜¯å¦è¶…è¿‡å†…å­˜çš„é™åˆ¶ mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u0026gt; maxAlloc { hint = 0 } // initialize Hmap if h == nil { h = new(hmap) } h.hash0 = fastrand()// è·å–éšæœºçš„hashå€¼ // Find the size parameter B which will hold the requested # of elements. // For hint \u0026lt; 0 overLoadFactor returns false since hint \u0026lt; bucketCnt. B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. if h.B != 0 { var nextOverflow *bmap // åˆ›å»ºmapçš„å­˜å‚¨æ•°æ®ï¼Œè¿”å›çš„æ¡¶çš„æ•°æ®çš„åœ°å€ï¼Œä¸‹ä¸€ä¸ªæº¢å‡ºæ¡¶çš„åœ°å€ h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) h.extra.nextOverflow = nextOverflow } } return h }  mapçš„å®Œæ•´ç»“æ„å¦‚å›¾ï¼š   \ravatar\r ã€‚\n mapæ‰©å®¹ æ‰©å®¹æ¡ä»¶   å½“è´Ÿè½½å› å­(loadFactorNum*(bucketShift(B)/loadFactorDen\u0026gt;6.5 -\u0026gt; ç¿»å€æ‰©å®¹\n  å½“è´Ÿè½½å› å­å°äº6.5ï¼Œä½†æ˜¯æº¢å‡ºæ¡¶çš„æ•°é‡å¤§äº2çš„15æ¬¡æ–¹ -\u0026gt; ç­‰é‡æ‰©å®¹\n  æºä»£ç å¦‚ä¸‹ï¼š\n    // overLoadFactor reports whether count items placed in 1\u0026lt;\u0026lt;B buckets is over loadFactor. // è´Ÿè½½å› å­å¤§äº6.5 func overLoadFactor(count int, B uint8) bool { return count \u0026gt; bucketCnt \u0026amp;\u0026amp; uintptr(count) \u0026gt; loadFactorNum*(bucketShift(B)/loadFactorDen) } // æº¢å‡ºæ¡¶è¿‡å¤šæ—¶ func tooManyOverflowBuckets(noverflow uint16, B uint8) bool { // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // \u0026quot;too many\u0026quot; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B \u0026gt; 15 { B = 15 } // The compiler doesn't see here that B \u0026lt; 16; mask B to generate shorter shift code. return noverflow \u0026gt;= uint16(1)\u0026lt;\u0026lt;(B\u0026amp;15) } // æ‰©å®¹æºç  func hashGrow(t *maptype, h *hmap) { // If we've hit the load factor, get bigger. // Otherwise, there are too many overflow buckets, // so keep the same number of buckets and \u0026quot;grow\u0026quot; laterally. bigger := uint8(1) if !overLoadFactor(h.count+1, h.B) { //ç­‰é‡æ‰©å®¹ bigger = 0 h.flags |= sameSizeGrow } oldbuckets := h.buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)// ä»æ–°åˆ†é…æ•°æ®åœ°å€ flags := h.flags \u0026amp;^ (iterator | oldIterator) if h.flags\u0026amp;iterator != 0 { // è¿­ä»£çš„æ—¶å€™æ¬è¿æ—§æ¡¶ flags |= oldIterator } // commit the grow (atomic wrt gc) h.B += bigger // æ¡¶çš„ä¸ªæ•° h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets h.nevacuate = 0 h.noverflow = 0 // æº¢å‡ºæ¡¶é’»ä¾¿ä¸ºæ—§æº¢å‡ºæ¡¶ if h.extra != nil \u0026amp;\u0026amp; h.extra.overflow != nil { // Promote current overflow buckets to the old generation. if h.extra.oldoverflow != nil { throw(\u0026quot;oldoverflow is not nil\u0026quot;) } h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil } if nextOverflow != nil { if h.extra == nil { h.extra = new(mapextra) } h.extra.nextOverflow = nextOverflow } // the actual copying of the hash table data is done incrementally // by growWork() and evacuate(). } ","date":"2021-09-20T22:00:38+08:00","permalink":"https://zcj-git520.github.io/p/go-%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/","title":"go åŸºç¡€ä¹‹map"},{"content":"åˆ‡ç‰‡çš„å†…éƒ¨ç»“æ„  åˆ‡ç‰‡çš„ç»“æ„å¯åˆ†ä¸ºï¼šæ•°ç»„ï¼Œæ•°æ®ï¼ˆå…ƒç´ ï¼‰çš„åœ°å€\u0026amp;dataã€ä¹Ÿå­˜å…ƒç´ ä¸ªæ•°lenã€å¯ä»¥å­˜å‚¨å¤šå°‘å…ƒç´ cap æºç å¦‚ä¸‹    å®šä¹‰åˆ‡ç‰‡çš„ç»“æ„ï¼š type slice struct { array unsafe.Pointer len int cap int }  å¦‚å›¾æ‰€ç¤º  \ravatar\r\n var data [] int å£°æ˜ä¸€ä¸ªåˆ‡ç‰‡ï¼Œç›¸å½“äºç”Ÿæˆåˆ‡ç‰‡çš„ç»“æ„ï¼Œdataåœ°å€æŒ‡é’ˆä¸ºnil, lenå’Œcapéƒ½ä¸º0ã€‚è¿™å°±å¾ˆæ¸…æ¥šä¸ºä»€ä¹ˆï¼Œnilåˆ‡ç‰‡ä¸å¯ä»¥ç›´æ¥ä½¿ç”¨äº†ğŸ˜„ ç»“æ„å¦‚å›¾  \ravatar\r\n ä½¿ç”¨åˆ‡ç‰‡æ—¶éœ€è¦make([]type,len,cap)æˆ–è€…åˆå§‹åŒ–[]type{}æ‰èƒ½ä½¿ç”¨ï¼Œè¿™æ˜¯å› ä¸ºåœ¨åœ¨ç”Ÿæˆåˆ‡ç‰‡çš„ç»“æ„æ—¶ï¼ŒåŒæ—¶ä¹Ÿå¼€è¾Ÿäº†ä¸€æ®µæ–°çš„å†…å­˜ï¼Œç±»å‹ä¸ºtype, ç»“æ„é•¿åº¦ä¸ºcap,åŒæ—¶å€¼è¿›è¡Œåˆå§‹åŒ–ã€‚ make æºç å¦‚ä¸‹ï¼š    func makeslice(et *_type, len, cap int) unsafe.Pointer { mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // åˆ¤æ–­æ˜¯å¦è¶Šç•Œ if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 || len \u0026gt; cap { // NOTE: Produce a 'len out of range' error instead of a // 'cap out of range' error when someone does make([]T, bignumber). // 'cap out of range' is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. mem, overflow := math.MulUintptr(et.size, uintptr(len)) if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 { panicmakeslicelen() // è¶Šç•Œç›´æ¥ panic } panicmakeslicecap() // è¶Šç•Œç›´æ¥ panic } return mallocgc(mem, et, true) //å¼€è¾Ÿå†…å­˜ }  \ravatar\r\n   ä¹Ÿå¯ä»¥é€šè¿‡åº•å±‚æ•°ç»„åˆå§‹åŒ–ï¼Œåˆ‡ç‰‡çš„dataæŒ‡é’ˆæŒ‡å‘å°±æ˜¯ç›¸åŒç±»å‹çš„åº•å±‚æ•°ç»„ï¼›é€šè¿‡slince := array[n:m],è¡¨ç¤ºå®šä¹‰äº†ä¸€ä¸ªç±»å‹å’Œarrayç›¸åŒï¼Œlenä¸ºm-n,capé»˜è®¤ä¸ºarrayçš„é•¿åº¦çš„åˆ‡ç‰‡ã€‚åˆ‡ç‰‡å’Œæ•°ç»„éƒ½æŒ‡å‘äº†ç›¸åŒçš„åœ°å€ã€‚å¤šä¸ªåˆ‡ç‰‡å¯ä»¥å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ \ravatar\r\n  é€šè¿‡append å‡½æ•°å‘åˆ‡ç‰‡å¢åŠ åˆ‡ç‰‡çš„å…ƒç´ ï¼Œå¢åŠ äº†len, cap ä¸å˜ã€‚\nåˆ‡ç‰‡æ‰©å®¹   åœ¨èµ„æºå……è£•çš„æ¡ä»¶ä¸‹ï¼Œåˆ‡ç‰‡æ˜¯å¯ä»¥é€šè¿‡appendä¸æ–­å¢åŠ å…ƒç´ ï¼Œå½“lenä¸ªæ•°å¢åŠ åˆ°capä¸€æ ·æ—¶ï¼Œåœ¨å¢åŠ å…ƒç´ æ—¶ï¼Œå°±éœ€è¦å¢åŠ åˆ‡ç‰‡çš„å®¹é‡capï¼Œé‚£é—®é¢˜æ¥äº†ï¼Œåˆ‡ç‰‡æ˜¯æ€ä¹ˆæ‰©å®¹çš„å‘¢ï¼Ÿ\næ‰©å®¹è§„åˆ™ï¼ˆé¢„ä¼°è§„åˆ™ï¼‰     å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§ï¼Œåˆ™æ‰©å®¹ä¸ºéœ€è¦æ‰©å®¹çš„æ•°é‡\n  å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå°äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„2å€\n  å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå¤§äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„1.25å€\n  ä¼ªä»£ç å¦‚ä¸‹\n if oldcap2 \u0026lt; newcap æ—¶ï¼Œ æ‰©å®¹ä¸ºnewcap else{ if oldcap \u0026lt; 1024 newcap = 2oldcap ; else newcap = 1.25*oldcap }\n   æºä»£ç å¦‚ä¸‹ï¼š\n    newcap := old.cap doublecap := newcap + newcap //ä¸¤å€çš„oldcap if cap \u0026gt; doublecap { //å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§ï¼Œåˆ™æ‰©å®¹ä¸ºéœ€è¦æ‰©å®¹çš„æ•°é‡ newcap = cap } else { //å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå°äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„2å€ if old.cap \u0026lt; 1024 { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå¤§äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„1.25å€ for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } æ‰©å®¹è°ƒæ•´  åœ¨é¢„ä¼°æ‰©å®¹åï¼Œä¼šæ ¹æ®å†…å­˜å¯¹é½ï¼ˆå‡å°‘å†…å­˜æµªè´¹ï¼‰åœ¨è¿›è¡Œè°ƒæ•´ï¼Œä»£ç ï¼šcapmem := roundupsize(uintptr(newcap) * uintptr(et.size))newcapå°±æ˜¯å‰æ–‡ä¸­è®¡ç®—å‡ºçš„newcapï¼Œet.sizeä»£è¡¨sliceä¸­ä¸€ä¸ªå…ƒç´ çš„å¤§å°ï¼Œcapmemè®¡ç®—å‡ºæ¥çš„å°±æ˜¯æ­¤æ¬¡æ‰©å®¹éœ€è¦ç”³è¯·çš„å†…å­˜å¤§å°ã€‚roundupsizeå‡½æ•°å°±æ˜¯å¤„ç†å†…å­˜å¯¹é½çš„å‡½æ•° æºç å¦‚ä¸‹   var overflow bool var lenmem, newlenmem, capmem uintptr switch { case et.size == 1: //ä¾‹å¦‚byte å¤§å°ä¸º1ï¼Œ æ‰©å®¹çš„å¤§å°ä¸ºå‘ä¸Šå–æ•´çš„æ•°å€¼ lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) \u0026gt; maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) \u0026gt; maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): //å¤„ç†2çš„å€æ•° var shift uintptr if sys.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026amp; 63 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026amp; 31 } lenmem = uintptr(old.len) \u0026lt;\u0026lt; shift newlenmem = uintptr(cap) \u0026lt;\u0026lt; shift capmem = roundupsize(uintptr(newcap) \u0026lt;\u0026lt; shift) overflow = uintptr(newcap) \u0026gt; (maxAlloc \u0026gt;\u0026gt; shift) newcap = int(capmem \u0026gt;\u0026gt; shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } // The check of overflow in addition to capmem \u0026gt; maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // type T [1\u0026lt;\u0026lt;27 + 1]int64 // // var d T // var s []T // // func main() { // s = append(s, d, d, d, d) // print(len(s), \u0026quot;\\n\u0026quot;) // } if overflow || capmem \u0026gt; maxAlloc { panic(errorString(\u0026quot;growslice: cap out of range\u0026quot;)) } ### æ‰©å®¹åå†…å­˜åˆ†é… * åˆ†é… å¤§äºcapçš„å†…å­˜ï¼Œæ²¡æœ‰æ•°æ®æŒ‡é’ˆï¼ŒmemclrNoHeapPointersåˆ›å»º * æºç å¦‚ä¸‹ï¼š \u0026gt; var p unsafe.Pointer if et.ptrdata == 0 { p = mallocgc(capmem, nil, false) // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) } else { // Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory. p = mallocgc(capmem, et, true) //åˆ†é…å†…å­˜åœ°å€ if lenmem \u0026gt; 0 \u0026amp;\u0026amp; writeBarrier.enabled { // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata) } } memmove(p, old.array, lenmem) //æ•°æ®è¿ç§» return slice{p, old.len, newcap} } ","date":"2021-09-15T22:00:38+08:00","image":"https://zcj-git520.github.io/s4.png","permalink":"https://zcj-git520.github.io/p/go-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/","title":"go åŸºç¡€ä¹‹åˆ‡ç‰‡"},{"content":"ä¸ºä»€ä¹ˆå†™åšå®¢  æ€»ç»“å¼€å‘ä¸­é‡åˆ°çš„é—®é¢˜ã€‚å·¥ä½œè¿‡åå‘ç°è‡ªå·±å¹¶ä¸æ“…é•¿å¯¹çŸ¥è¯†ç‚¹çš„æ€»ç»“ï¼Œå¯¼è‡´æ€»æ˜¯é‡åˆ°ç›¸åŒçš„é—®é¢˜ï¼Œè¿‡æ®µæ—¶é—´éœ€è¦é‡æ–°æŸ¥æ‰¾è§£å†³æ–¹æ¡ˆ è®°å½•å­¦ä¹ çš„çŸ¥è¯†ï¼Œä¸æ–­çš„æ¸©ä¹ ã€‚å­¦çš„ä¸œè¥¿è¿‡äºç¢ç‰‡åŒ–ï¼Œå¯¼è‡´çŸ¥è¯†ä¸æˆä½“ç³»ã€‚æ—¶é—´é•¿äº†ï¼Œç¢ç‰‡çš„çŸ¥è¯†ä¹Ÿå¿˜è®°äº† æå‡è‡ªå·±çš„ä¸“ä¸šæŠ€èƒ½ã€‚é€šè¿‡å†™åšå®¢æå‡è‡ªå·±çš„èƒ½åŠ› å½¢æˆè‡ªå·±çš„æŠ€æœ¯æ ˆï¼Œé‡åˆ°çš„å¿—åŒé“åˆçš„æœ‹å‹  ä¸ºä»€ä¹ˆé€‰æ‹©hugoæ¥æ­å»ºè‡ªå·±çš„åšå®¢  Hugoæ˜¯ç”±Goè¯­è¨€å®ç°çš„é™æ€ç½‘ç«™ç”Ÿæˆå™¨ã€‚ç®€å•ã€æ˜“ç”¨ã€é«˜æ•ˆã€æ˜“æ‰©å±•ã€å¿«é€Ÿéƒ¨ç½²ã€‚ æ“ä½œç®€å•ï¼Œä½¿ç”¨Markdownç›´æ¥ç”Ÿæˆé™æ€ç½‘é¡µ å…è´¹ä¸”ä»¥ç»´æŠ¤, åœ¨githubä¸Šå°±å¯ä¾›ä»–äººè®¿é—®ï¼Œæ— éœ€è´­ä¹°æœåŠ¡å™¨ï¼Œç»´æŠ¤ç®€å• å‘è¡¨æ–‡ç« ç›´æ¥pushåˆ°è‡ªå·±ä»“åº“å³å¯  ä¸‹è½½hogoçš„æºç   git clone https://github.com/gohugoio/hugo.git\ngit branch æŸ¥çœ‹å•å‰ä»£ç çš„åˆ†æ”¯\ngit branch -a æŸ¥çœ‹å…¨éƒ¨åˆ†æ”¯\ngit checkout branch åˆ‡æ¢åˆ†æ”¯\ngit branch åˆ†æ”¯å åˆ›å»ºè‡ªå·±çš„æœ¬åœ°åˆ†å­\n ç¼–è¯‘æºç   åœ¨masteråˆ†æ”¯ä¸‹ï¼Œåœ¨main.go çš„ç›®å½•ä¸‹ä½¿ç”¨å‘½ä»¤: go build åœ¨ç›®å½•ä¸‹ç”Ÿæˆhugo.exe åœ¨cmdä¸‹ä½¿ç”¨hugo æŸ¥çœ‹æ˜¯å¦ç¼–è¯‘æˆåŠŸ ç¼–è¯‘æˆåŠŸ ä¼šæ‰“å°hugoçš„ç‰ˆæœ¬ å®‰è£…æˆåŠŸ  ç”Ÿæˆç«™ç‚¹  ä½¿ç”¨å‘½ä»¤ï¼šhugo new site /ç›®å½• cd /ç›®å½• æŸ¥çœ‹åˆ°   â–¸ archetypes/ â–¸ content/ â–¸ layouts/ â–¸ static/ config.toml   åˆ›å»ºç«™ç‚¹æˆåŠŸ  åˆ›å»ºmdæ–‡ç«   ä½¿ç”¨å‘½ä»¤: hugo new æ–‡ç« å.md åœ¨content/ ä¸‹ç”Ÿæˆè¯¥mdæ–‡ä»¶  é€‰æ‹©åšå®¢ä¸»é¢˜æ¨¡æ¿  hugo æä¾›å¾ˆå¤šçš„ä¸»é¢˜åšå®¢æ¨¡æ¿ï¼šhttps://themes.gohugo.io/ åˆ›å»ºthemeæ–‡ä»¶å¤¹ï¼Œå°†ä¸»é¢˜æ¨¡æ¿æ”¾åœ¨é‡Œé¢ ï¼šmkdir themes è¿›å…¥è¯¥æ–‡ä»¶å¤¹ï¼šcd themes ä¸‹è½½ä¸»é¢˜ï¼Œä½¿ç”¨git clone ä¸»é¢˜æ¨¡æ¿ ï¼šgit clone https://github.com/spf13/hyde.git  é…ç½®config.tomlæ–‡ä»¶  config.toul æ–‡ä»¶hugo çš„é…ç½®æ–‡ä»¶ï¼Œå¯ä»¥é…ç½®ä¸»é¢˜æ¨¡æ¿ï¼Œä¸ªäººä¿¡æ¯ç­‰(ä¸»é¢˜æ¨¡æ¿ä¸­ç›¸åº”çš„é…ç½®æ–‡ä»¶)å¦‚   baseurl = \u0026quot;http://****.com/\u0026quot; //å‘å¸ƒçš„ç½‘ç«™ languageCode = \u0026quot;ja\u0026quot; //ä½¿ç”¨çš„è¯­è¨€ title = \u0026quot;xxxx.COM\u0026quot; //ç½‘ç«™åç§°ç­‰ [Params] subtitle = \u0026quot;I would like to be a layer 3 switch.\u0026quot; facebook = \u0026quot;https://facebook.com/foobar\u0026quot; twitter = \u0026quot;https://twitter.com/foobar\u0026quot; github = \u0026quot;https://github.com/foobar\u0026quot; profile = \u0026quot;/images/profile.png\u0026quot; copyright = \u0026quot;Written by Asuka Suzuki\u0026quot; analytics = \u0026quot;UA-XXXXXXXX-X\u0026quot;    è¿è¡Œ æœ¬åœ°è¿è¡Œ  ä½¿ç”¨å‘½ä»¤ï¼šhugo server \u0026ndash;buildDrafts é…ç½®æ­£ç¡®åˆ™ä¼šå‡ºç°ï¼š http://localhost:1313/ (bind address 127.0.0.1) ç‚¹å‡»åœ¨æµè§ˆå™¨ä¸­è¿è¡Œ  æ¨é€åˆ°gitgub  é¦–å…ˆåœ¨GitHubä¸Šåˆ›å»ºä¸€ä¸ªRepositoryï¼Œå‘½åä¸ºï¼šgithubç”¨æˆ·å.github.io ä¿®æ”¹config.toml é…ç½®æ–‡ä»¶ï¼šå°†baseurl = \u0026ldquo;http://githubç”¨æˆ·å.github.io\u0026rdquo; ä½¿ç”¨å‘½ä»¤ï¼šhugo \u0026ndash;buildDrafts åœ¨æœ¬åœ°ç”Ÿæˆpublicçš„æ–‡ä»¶å¤¹ \u0026ndash;buildDrafts å‚æ•°çš„ä¸»ç”¨æ˜¯å°†ä½ çš„æ–‡ç« åœ¨ä¸»é¢˜ä¸­å‡ºç°   cd public è¿›å…¥åˆ°publicæ–‡ä»¶å¤¹ $ git init åˆå§‹åŒ–æœ¬åœ°ä»“åº“ $ git remote add origin https://github.com/githubç”¨æˆ·å/githubç”¨æˆ·å.github.io //æ·»åŠ åŸåˆ›ä»“åº“ æˆ–è€…ç›´æ¥ git clone $ git add -A $ git commit -m \u0026quot;first commit\u0026quot; $ git push -u origin master //æ¨åˆ°è¿œç«¯   ä½¿ç”¨ \u0026ldquo;http://githubç”¨æˆ·å.github.io\u0026quot;å°±å¯è®¿é—®  ","date":"2021-09-04T10:05:40+08:00","permalink":"https://zcj-git520.github.io/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%8D%9A%E5%AE%A2/","title":"æˆ‘çš„ç¬¬ä¸€ä»½åšå®¢"}]