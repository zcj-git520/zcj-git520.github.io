[{"content":"è™šæ‹Ÿåœ°å€ç©ºé—´å¸ƒå±€  ç¨‹åºé€šè¿‡ç¼–è¯‘æˆä¸ºä¸€å †çš„æœºå™¨æŒ‡ä»¤å†™å…¥å¯æ‰§è¡Œæ–‡ä»¶ï¼Œç¨‹åºåœ¨è¿è¡Œæ˜¯ä¼šå°†å¯æ‰§è¡Œæ–‡ä»¶åŠ è½½åœ¨è®¡ç®—æœºçš„å†…å­˜ä¸­ åœ¨è™šæ‹Ÿåœ°å€ç©ºé—´åˆ†å¸ƒä¸­å¤„äºä»£ç æ®µã€‚ ç¨‹åºä¸­çš„å±€éƒ¨å˜é‡ã€å‡½æ•°çš„å‚æ•°ã€å‡½æ•°çš„è¿”å›å€¼ç­‰æ•°æ®ä¼šä¿å­˜åœ¨è™šæ‹Ÿåœ°å€çš„æ ˆä¸­(æ ˆæ˜¯å…ˆè¿›åå‡ºçš„æ•°æ®ç»“æ„) æ ˆç©ºé—´çš„ç¼–è¯‘å™¨åˆ†é…å’Œé‡Šæ”¾ã€‚ ç¨‹åºçš„å…¨å±€å˜é‡å’Œé™æ€å˜é‡ä¼šä¿å­˜åœ¨è™šæ‹Ÿåœ°å€çš„æ•°æ®æ®µ åŠ¨æ€åˆ†é…å†…å­˜çš„åœ°å€ä¼šä¿å­˜åœ¨è™šæ‹Ÿåœ°å€ç©ºé—´çš„å †ä¸Šã€‚å †ç©ºé—´æ˜¯åŠ¨æ€å¼€è¾Ÿçš„å†…å­˜ç©ºé—´ï¼Œéœ€è¦ä¸»åŠ¨å¼€è¾Ÿå’Œé‡Šæ”¾ã€‚æˆ–è€… è°ƒç”¨GCé‡Šæ”¾ \r  å †ç©ºé—´å†…å­˜ç®¡ç†  å †å†…å­˜ç©ºé—´ä¸æ˜¯ç¼–è¯‘å™¨åˆ†é…ï¼Œè€Œæ˜¯æœ‰ç¨‹åºåŠ¨æ€åˆ†é…çš„å†…å­˜ç©ºé—´ã€‚  æ‰‹åŠ¨åƒåœ¾å›æ”¶  éœ€è¦ç¨‹åºä¸»åŠ¨é‡Šæ”¾æ²¡æœ‰ç”¨çš„æ•°æ®æ‰€åœ¨çš„å †ç©ºé—´ã€‚å¦‚ï¼šc++ä¸­è°ƒç”¨new()å‡½æ•°å‘è®¡ç®—æœºç”³è¯·å¼€è¾Ÿå†…å­˜ç©ºé—´åï¼Œä½¿ç”¨deleteæˆ–delete[]é‡Šæ”¾ä¸éœ€è¦çš„ å †å†…å­˜ç©ºé—´ã€‚è¿™ä¸€ç±»æ˜¯æ‰‹åŠ¨å†…å­˜åˆ†é…å’Œé‡Šæ”¾ã€‚æ‰‹åŠ¨å†…å­˜åˆ†é…ä½¿ç”¨ä¸æ°å½“ä¹Ÿä¼šé€ æˆï¼šå†…å­˜æ³„éœ² æ‚¬æŒ‚æŒ‡é’ˆçš„é—®é¢˜   è¿‡æ—©é‡Šæ”¾ä¼šé€ æˆæ‚¬æŒ‚æŒ‡é’ˆï¼ˆé‡æŒ‡é’ˆï¼‰ï¼šæå‰é‡Šæ”¾äº†åŠ¨æ€çš„å †å†…å­˜çš„ç©ºé—´ï¼Œå½“ç¨‹åºè®¿é—®è¿™æ®µåœ°å€æ—¶ä¼šæŠ¥é”™ã€‚å› ä¸ºè¿™æ®µæå‰é‡Šæ”¾çš„å†…å­˜ç©ºé—´è¢«æ¸…ç©ºã€ é‡æ–°åˆ†é…æˆ–è€…è¢«æ“ä½œç³»ç»Ÿå›æ”¶ã€‚é‡Šæ”¾æŒ‡é’ˆæ—¶å°†æŒ‡é’ˆèµ‹å€¼ä¸ºNULLï¼Œåœ¨è®¿é—®æ—¶å¯¹æŒ‡é’ˆè¿›è¡Œåˆ¤æ–­æ˜¯å¦ä¸ºNULL ä¸é‡Šæ”¾å†…å­˜ä¼šé€ æˆå†…å­˜æ³„æ¼ï¼šå †å†…å­˜éœ€è¦æ‰‹åŠ¨é‡Šæ”¾ï¼Œå½“ç¨‹åºè¿è¡Œç»“æŸä¸é‡Šæ”¾ï¼Œè¿™æ®µå†…å­˜å°±ä¼šè¢«ä¸€ç›´å ç”¨ã€‚å¦‚æœ ä¸€ç›´åœ¨åˆ†é…ä¸é‡Šæ”¾ä¼šä¸€ç›´å ç”¨è®¡ç®—æœºçš„å†…å­˜ï¼Œç›´åˆ°å†…å­˜è¢«å å®Œã€‚å°†newä¸deleteé…å¥—ä½¿ç”¨ï¼Œä½¿ç”¨å·¥å…·æ£€æµ‹æˆ–è€…æ‰“å°å‡ºå †ä¿¡æ¯  è‡ªåŠ¨åƒåœ¾å›æ”¶ï¼ˆGCï¼‰  åœ¨ç¨‹åºè¿è¡Œè¿‡ç¨‹ä¸­è‡ªåŠ¨é‡Šæ”¾æ²¡æœ‰ç”¨çš„æ•°æ®æ‰€åœ¨çš„å †ç©ºé—´ï¼ˆåƒåœ¾å›æ”¶).åœ¨è™šæ‹Ÿå†…å­˜ç©ºé—´ä¸­èƒ½ä»æ ˆæˆ–è€…æ•°æ®æ®µçš„æ ¹èŠ‚ç‚¹è¿½è¸ªä¸åˆ°çš„æ•°æ®ä¸ºæ²¡ç”¨çš„æ•°æ® ï¼ˆå†…å­˜åƒåœ¾ï¼‰ï¼Œå¸¸ç”¨çš„ç®—æ³•ï¼šæ ‡è®°æ³•, è®¡æ•°æ³•  æ ‡è®°æ³•å›æ”¶  æ ‡è®°æ³•ï¼šå°†æ ˆæˆ–è€…æ•°æ®æ®µä½œä¸ºæ ¹ï¼ˆrootï¼‰è¿›è¡Œè¿½è¸ª,å°†èƒ½è¿½è¸ªå¾—çš„æ•°æ®ï¼ˆå †ç©ºé—´ï¼‰è¿›è¡Œæ ‡è®°ã€‚æ²¡æœ‰è¢«æ ‡è®°çš„æ•°æ® ï¼ˆå †ç©ºé—´ï¼‰å°±æ˜¯åƒåœ¾ï¼Œå°†è¿™éƒ¨åˆ†åƒåœ¾è¿›è¡Œå›æ”¶ã€‚ä¸‰è‰²æŠ½è±¡ï¼š   åƒåœ¾å›æ”¶å¼€å§‹æ—¶ï¼Œå°†æ‰€æœ‰æ•°æ®ä¸ºç™½è‰² åƒåœ¾å›æ”¶å¼€å§‹æ—¶ï¼Œå°†æ‰€æœ‰çš„æ ˆæˆ–è€…æ•°æ®æ®µçš„æ ¹èŠ‚ç‚¹è®¾ç½®ä¸ºç°è‰² åœ¨æ ¹æ®æ ¹èŠ‚ç‚¹è¿›è¡Œè¿½è¸ªï¼Œç›´åˆ°æ‰€æœ‰çš„æ•°æ®èŠ‚ç‚¹è¿½è¸ªç»“æŸåå°†æ ¹èŠ‚ç‚¹ç½®ä¸ºé»‘è‰²ï¼Œåœ¨å°†æ ¹èŠ‚ç‚¹çš„ä¸‹ä¸€èŠ‚ç‚¹ä½œä¸ºæ ¹èŠ‚ç‚¹è¿›è¡Œè¿½è¸ª æ‰€æœ‰çš„æ•°æ®èŠ‚ç‚¹éƒ½è¿½è¸ªå®Œåï¼Œä¼šå‰©ä¸‹é»‘è‰²å’Œç™½è‰²çš„æ•°æ®èŠ‚ç‚¹ã€‚é»‘è‰²è¡¨ç¤ºæœ‰ç”¨çš„æ•°æ®ã€‚ç™½è‰²ä¸ºæ— ç”¨çš„æ•°æ®ã€‚å°†ç™½è‰²çš„æ•°æ®è¿›è¡Œå›æ”¶ï¼ˆå †ç©ºé—´çš„é‡Šæ”¾ï¼‰ \r   æ ‡è®°æ³•å®ç°ç®€å•ï¼Œä½†æ˜¯ä¼šé€ æˆå†…å­˜çš„ç¢ç‰‡åŒ–(å†…å­˜å—ä¸­æ˜¯å¯ä½¿ç”¨å°å†…å­˜å—ï¼Œé€ æˆå¤§å†…å­˜å—ä¸èƒ½ä½¿ç”¨è¿™å—å†…å­˜ï¼Œè¿™äº›å°å°å†…å­˜å—ä¹Ÿä¸èƒ½ä½¿ç”¨) å› ä¸ºå†…å­˜ç¢ç‰‡åŒ–çš„é—®é¢˜è¯ç”Ÿäº†   æ ‡è®°æ•´ç†æ³•ï¼Œå°±æ˜¯æ ‡è®°æ³•ä¹‹åï¼Œå°†æœ‰ç”¨çš„æ•°æ®å †å†…å­˜ç©ºé—´ç§»åŠ¨åœ¨ä¸€èµ·ï¼Œé‡Šæ”¾æ›´å¤šè¿ç»­çš„å †ç©ºé—´,ä½†æ˜¯è¿™ç§åšæ³•å¸¦æ¥ å¾ˆå¤§çš„å¼€é”€ï¼Œå› ä¸ºéœ€è¦ä¸æ–­çš„æ‰«æå†…å­˜å’Œç§»åŠ¨å†…å­˜ å¤åˆ¶å›æ”¶æ³•ã€‚å°†å †å†…å­˜åˆ†ä¸ºfromå’ŒToä¸¤ä¸ªç›¸åŒçš„å †å†…å­˜ç©ºé—´ã€‚ç¨‹åºæ‰§è¡Œæ—¶ï¼Œä½¿ç”¨fromçš„å †ç©ºé—´ã€‚åƒåœ¾å›æ”¶æ—¶ä¼šæ‰«æfrom çš„å †å†…å­˜ç©ºé—´ï¼Œå°†æœ‰ç”¨çš„æ•°æ®å¤åˆ¶åˆ°Toçš„å †ç©ºé—´ä¸Šã€‚åƒåœ¾å›æ”¶ç»“æŸæ—¶ï¼Œå°†Toå †ç©ºé—´è®¾ç½®ä¸ºFromå †ç©ºé—´ã€‚å°†åŸæ¥çš„from å †ç©ºé—´å…¨éƒ¨å›æ”¶åç½®ä¸ºTonå †ç©ºé—´ã€‚ä½†æ˜¯å¤åˆ¶å›æ”¶æ³•åªä¼šä½¿ç”¨ä¸€èˆ¬çš„å †å†…å­˜ç©ºé—´ï¼Œé€ æˆå †å†…å­˜ç©ºé—´åˆ©ç”¨ç‡ä¸é«˜ \r åˆ†ä»£æ³•å›æ”¶ï¼šå¤§éƒ¨åˆ†å¯¹è±¡éƒ½ä¼šåœ¨å¹´è½»æ—¶å€™æ­»äº¡ï¼ˆå¼±åˆ†ä»£å‡è¯´ï¼‰æŠŠæ–°å»ºçš„å¯¹è±¡ç§°ä¹‹ä¸ºæ–°ç”Ÿä»£å¯¹è±¡ã€‚ç»è¿‡ç‰¹å®šæ¬¡æ•°çš„GC(åƒåœ¾å›æ”¶)æ•°æ®ä¾ç„¶æœ‰ç”¨çš„å¯¹è±¡ç§°ä¸º è€å¹´ä»£å¯¹è±¡ã€‚è€Œå¤§éƒ¨åˆ†ä¼šåœ¨æ–°ç”Ÿä»£å¯¹è±¡å°±ä¼šåƒåœ¾å›æ”¶äº†ï¼Œåœ¨ç»“åˆå¤åˆ¶å›æ”¶æ³•ä½¿ç”¨ \r  è®¡æ•°æ³•å›æ”¶  å¼•ç”¨è®¡æ•°æŒ‡çš„æ˜¯å¯¹è±¡è¢«å¼•ç”¨çš„æ¬¡æ•°ï¼Œç¨‹åºåœ¨è¿è¡Œè¿‡ç¨‹ä¸­ä¼šæ›´æ–°å¼•ç”¨æ¬¡æ•°ã€‚å¯¹è±¡å¼•ç”¨è¶Šå¤šï¼Œè®¡æ•°è¶Šå¤§ï¼Œå½“è®¡æ•°ä¸º0æ—¶ï¼Œå›æ”¶è¯¥å¯¹è±¡ï¼ˆå †å†…å­˜ç©ºé—´ï¼‰ \r  ","date":"2021-10-18T22:00:38+08:00","image":"https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1_hu86f620222550b5f6f6b08ef9da75c8f9_105109_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"å†…å­˜ç®¡ç†"},{"content":"go Channel  ï¼ˆDo not communicate by sharing memory; instead, share memory by communicatingï¼‰  CSPå¹¶å‘æ¨¡å‹  CSP å³é€šä¿¡é¡ºåºè¿›ç¨‹ã€äº¤è°ˆå¾ªåºç¨‹åºï¼Œåˆè¢«è¯‘ä¸ºäº¤æ¢æ¶ˆæ¯çš„å¾ªåºç¨‹åº(communicating sequential processes)ï¼Œå®ƒæ˜¯ä¸€ç§ç”¨æ¥æè¿°å¹¶å‘æ€§ç³»ç»Ÿä¹‹é—´è¿›è¡Œäº¤äº’çš„æ¨¡å‹ã€‚ go Channeæ˜¯ä¸€ç§ç‰¹æ®Šçš„ç±»å‹ï¼Œæ˜¯æœ‰ç‰¹å®šç±»å‹çš„é˜Ÿåˆ—ã€‚æ˜¯é“¾æ¥goroutine(åç¨‹)çš„é€šä¿¡æœºåˆ¶ï¼Œé€šè¿‡é€šä¿¡å…±äº«å†…å­˜è€Œä¸æ˜¯é€šè¿‡å…±äº«å†…å­˜è€Œå®ç°é€šä¿¡. Channel æ”¶å‘æ“ä½œå‡éµå¾ªäº†å…ˆè¿›å…ˆå‡ºçš„è®¾è®¡ï¼Œå…·ä½“è§„åˆ™å¦‚ä¸‹ï¼š  å…ˆä» Channel è¯»å–æ•°æ®çš„ Goroutine ä¼šå…ˆæ¥æ”¶åˆ°æ•°æ®ï¼› å…ˆå‘ Channel å‘é€æ•°æ®çš„ Goroutine ä¼šå¾—åˆ°å…ˆå‘é€æ•°æ®çš„æƒåˆ©ï¼›    \r\nchannel æ•°æ®ç»“æ„å®šä¹‰ï¼š type hchan struct { // é˜Ÿåˆ—ä¸­å­˜å‚¨çš„æ•°é‡ qcount uint // total data in the queue //ç¯å½¢é˜Ÿåˆ—çš„å¤§å°(æœ€å¤§å­˜å‚¨æ•°é‡ ) dataqsiz uint // size of the circular queue // å­˜æ”¾ç¯å½¢é˜Ÿåˆ—çš„æ•°æ®ï¼Œæ•°ç»„ buf unsafe.Pointer // points to an array of dataqsiz elements // å…ƒç´ çš„å¤§å° elemsize uint16 // æ˜¯å¦å…³é—­çš„æ ‡è¯† closed uint32 // å…ƒç´ çš„ç±»å‹(æŒ‡å‘ç±»å‹çš„å…ƒæ•°æ® ) elemtype *_type // element type // å½“å‰å‘é€æ•°æ®åœ¨ç¯å½¢é˜Ÿåˆ—çš„ç´¢å¼• sendx uint // send index // å½“å‰æ¥å—æ•°æ®åœ¨ç¯å½¢é˜Ÿåˆ—çš„ç´¢å¼• recvx uint // receive index // æ¥æ”¶è€…ç­‰å¾…é˜Ÿåˆ—ï¼ˆ\u0026lt;-chï¼‰é˜»å¡åœ¨channelçš„åç¨‹é˜Ÿåˆ— recvq waitq // list of recv waiters // å‘é€è€…ç­‰å¾…é˜Ÿåˆ—ï¼ˆch\u0026lt;- dataï¼‰é˜»å¡åœ¨channelçš„åç¨‹é˜Ÿåˆ— sendq waitq // list of send waiters //é”ä¿æŠ¤hchanä¸­çš„æ‰€æœ‰å­—æ®µï¼Œä»¥åŠå‡ ä¸ª //åœ¨è¿™ä¸ªé€šé“ä¸Šé˜»å¡sudogsä¸­çš„å­—æ®µ //ä¿æŒè¿™ä¸ªé”æ—¶ä¸è¦æ”¹å˜å¦ä¸€ä¸ªGçš„çŠ¶æ€ //(ç‰¹åˆ«æ˜¯ï¼Œä¸è¦å‡†å¤‡ä¸€ä¸ªG)ï¼Œå› ä¸ºè¿™å¯èƒ½ä¼šæ­»é” //æ ˆæ”¶ç¼©ã€‚ lock mutex // ä¿æŠ¤hchanä¸­çš„æ‰€æœ‰å­—æ®µï¼Œä¿æŒåç¨‹çš„çŠ¶æ€ä¸è¢«æ›´æ”¹ï¼Œé¿å…é€ æˆæ ˆæ”¶ç¼©å¼•èµ·çš„æ­»é”ï¼Œä½¿ç”¨äº’æ–¥é”è§£å†³ç¨‹åºä¸­å¯èƒ½å­˜åœ¨çš„çº¿ç¨‹ç«äº‰é—®é¢˜æ˜¯å¾ˆå¸¸è§çš„ } å‘é€è€…/æ¥æ”¶è€…ç­‰å¾…é˜Ÿåˆ—çš„ç»“æ„ï¼šä¸€ä¸ªåŒå‘é“¾è¡¨ type waitq struct { first *sudog last *sudog } channel sudog(ç­‰å¾…é˜Ÿåˆ—)ç»“æ„å¦‚ä¸‹ type sudog struct { // The following fields are protected by the hchan.lock of the // channel this sudog is blocking on. shrinkstack depends on // this for sudogs involved in channel ops. //ä»¥ä¸‹å­—æ®µå—hchanä¿æŠ¤ã€‚é”çš„ //è¿™ä¸ªsudogæ­£åœ¨é˜»å¡ã€‚shrinkstackå–å†³äº //è¿™æ˜¯ä¸ºæ¶‰åŠé€šé“æ“ä½œçš„sudogsã€‚ g *g // ç­‰å¾…çš„åç¨‹åç¨‹ next *sudog prev *sudog // æ•°æ®å…ƒç´ (å¯ä»¥æŒ‡å‘å †æ ˆ)ï¼Œç­‰å¾…å‘é€/æ¥æ”¶çš„æ•°æ® elem unsafe.Pointer // data element (may point to stack) // The following fields are never accessed concurrently. // For channels, waitlink is only accessed by g. // For semaphores, all fields (including the ones above) // are only accessed when holding a semaRoot lock. //ä¸‹é¢çš„å­—æ®µæ°¸è¿œä¸ä¼šå¹¶å‘è®¿é—®ã€‚ //å¯¹äºé€šé“ï¼Œwaitlinkåªè¢«gè®¿é—®ã€‚ //å¯¹äºä¿¡å·é‡ï¼Œæ‰€æœ‰çš„å­—æ®µ(åŒ…æ‹¬ä¸Šé¢çš„å­—æ®µ) //åªåœ¨æŒæœ‰semaRooté”æ—¶è®¿é—®ã€‚ acquiretime int64 releasetime int64 ticket uint32 // isSelect indicates g is participating in a select, so // g.selectDone must be CAS'd to win the wake-up race. // è¡¨ç¤ºgè¢«é€‰æ‹© isSelect bool // success indicates whether communication over channel c // succeeded. It is true if the goroutine was awoken because a // value was delivered over channel c, and false if awoken // because c was closed. //æˆåŠŸè¡¨ç¤ºæ˜¯å¦é€šè¿‡é€šé“cé€šä¿¡ // æˆåŠŸäº†ã€‚ å¦‚æœ goroutine è¢«å”¤é†’æ˜¯å› ä¸ºä¸€ä¸ª // å€¼é€šè¿‡é€šé“ c ä¼ é€’ï¼Œå¦‚æœè¢«å”¤é†’åˆ™è¿”å› false // å› ä¸º c è¢«å…³é—­äº† success bool // c å› å…³é—­è€Œå”¤é†’ parent *sudog // semaRoot binary tree waitlink *sudog // g.waiting list or semaRoot waittail *sudog // semaRoot // ç­‰å¾…çš„channelè¢«å”¤é†’ c *hchan // channel }  ç»“æ„å¦‚å›¾æ‰€ç¤º \r  channel åˆ›å»º  channel å’Œ åˆ‡ç‰‡ã€mapä¸€æ ·ï¼Œéœ€è¦ä½¿ç”¨make(chan type, int )æ‰èƒ½ä½¿ç”¨,åº”ä¸ºmake()ä¼šè°ƒç”¨makeChan()åˆå§‹åŒ–  makechå‡½æ•°æºç å¦‚ä¸‹: // å‚æ•°ç±»å‹ï¼šåˆ›å»ºchançš„ç±»å‹å’Œç¯å‹ç¼“å†²åŒºçš„æ•°é‡ func makechan(t *chantype, size int) *hchan { elem := t.elem // compiler checks this but be safe. if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { throw(\u0026quot;makechan: invalid channel element type\u0026quot;) } if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026quot;makechan: bad alignment\u0026quot;) } //åˆ¤æ–­ç¯å‹ç¼“å†²åŒºæ˜¯å¦æº¢å‡º mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { panic(plainError(\u0026quot;makechan: size out of range\u0026quot;)) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG's are referenced from their owning thread so they can't be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. var c *hchan switch { case mem == 0: // Queue or element size is zero. // å½“é˜Ÿåˆ—æˆ–è€…å…ƒç´ å¤§å°ä¸º0æ—¶ï¼Œå®šä¹‰æ— ç¼“å†²chanï¼ˆåŒæ­¥chanï¼‰ c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. // Race ç«äº‰æ£€æŸ¥åˆ©ç”¨è¿™ä¸ªåœ°å€æ¥è¿›è¡ŒåŒæ­¥æ“ä½œ c.buf = c.raceaddr() case elem.ptrdata == 0: // Elements do not contain pointers. // Allocate hchan and buf in one call. // å…ƒç´ ä¸åŒ…å«æŒ‡é’ˆæ—¶ã€‚ä¸€æ¬¡åˆ†é… hchan å’Œ buf çš„å†…å­˜ã€‚ c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. // å®šä¹‰å¸¦ç¼“å­˜çš„chanæˆ–è€…å¼‚æ­¥çš„chan c = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) // chanå…ƒç´ çš„å¤§å° c.elemtype = elem // chanå…ƒç´ çš„ç±»å‹ c.dataqsiz = uint(size) // chanç¼“å­˜åŒºå¤§å° lockInit(\u0026amp;c.lock, lockRankHchan) //åˆå§‹åŒ–äº’æ–¥é” if debugChan { print(\u0026quot;makechan: chan=\u0026quot;, c, \u0026quot;; elemsize=\u0026quot;, elem.size, \u0026quot;; dataqsiz=\u0026quot;, size, \u0026quot;\\n\u0026quot;) } return c }  channelåˆ›å»ºè¿‡ç¨‹ï¼š   ç¼–è¯‘æ£€æŸ¥ã€ç¼“å†²åŒºå¤§å°æ£€æŸ¥ï¼Œåˆ¤æ–­æ˜¯å¦æº¢å‡º åˆ¤æ–­chançš„ç±»å‹\n1ã€å½“åˆ›å»ºæ— ç¼“å†²chanæ—¶,è°ƒç”¨mallocgc()åœ¨å †ä¸Šä¸ºchanå¼€è¾ŸhchanSizeçš„bufç¼“å­˜å†…å­˜ç©ºé—´\n2ã€åˆ›å»ºå¸¦ç¼“å†²çš„chanæ—¶,åˆ¤æ–­å…ƒç´ çš„ç±»å‹æ˜¯å¦ä¸ºæŒ‡é’ˆç±»å‹ï¼Œè‹¥ä¸æ˜¯ï¼Œåˆ™mallocgc()åœ¨å †ä¸Šä¸ºchanå’Œbufç¼“å†²åŒºæ•°ç»„å¼€è¾Ÿä¸€æ®µå¤§å°ä¸º hchanSize+memè¿ç»­çš„å†…å­˜ç©ºé—´ã€‚è‹¥æ˜¯åˆ™è°ƒç”¨mallocgc()åœ¨å †ä¸Šåˆ†åˆ«ä¸ºchanå’Œbufç¼“å†²åŒºåˆ†é…è¿ç»­å†…å­˜ç©ºé—´ã€‚ \r  channel å‘é€æ•°æ®ä¸æ¥æ”¶æ•°æ® channel å‘é€æ•°æ®  chan \u0026lt;- data  chanå‘é€æ•°æ®æºç å¦‚ä¸‹: func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { // åˆ¤æ–­chanæ˜¯å¦è¢«åˆå§‹åŒ–ï¼Œå‘chanä¸ºnilçš„chanå‘é€æ•°æ®å°†ä¼šæ°¸ä¹…é˜»å¡ if c == nil { if !block { return false } // ä½¿å½“å‰çš„groutineä¼‘çœ  gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026quot;unreachable\u0026quot;) } if debugChan { print(\u0026quot;chansend: chan=\u0026quot;, c, \u0026quot;\\n\u0026quot;) } // æ£€æŸ¥åœ¨æ²¡æœ‰è·å–é”çš„æƒ…å†µä¸‹ä¼šå¯¼è‡´å‘é€å¤±è´¥çš„éé˜»å¡æ“ä½œ if raceenabled { racereadpc(c.raceaddr(), callerpc, funcPC(chansend)) } // Fast path: check for failed non-blocking operation without acquiring the lock. // // After observing that the channel is not closed, we observe that the channel is // not ready for sending. Each of these observations is a single word-sized read // (first c.closed and second full()). // Because a closed channel cannot transition from 'ready for sending' to // 'not ready for sending', even if the channel is closed between the two observations, // they imply a moment between the two when the channel was both not yet closed // and not ready for sending. We behave as if we observed the channel at that moment, // and report that the send cannot proceed. // // It is okay if the reads are reordered here: if we observe that the channel is not // ready for sending and then observe that it is not closed, that implies that the // channel wasn't closed during the first observation. However, nothing here // guarantees forward progress. We rely on the side effects of lock release in // chanrecv() and closechan() to update this thread's view of c.closed and full(). if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } // è·å¾—åŒæ­¥é” lock(\u0026amp;c.lock) // å½“chanå…³é—­æ—¶,é‡Šæ”¾é”ï¼Œå¹¶panic // å‘ä¹Ÿå…³é—­çš„chanå‘é€æ¶ˆæ¯,ä¼šå¼•å‘panic if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026quot;send on closed channel\u0026quot;)) } // å¦‚æœæ¥æ”¶é˜Ÿåˆ—ä¸­æœ‰ç­‰å¾…çš„æ¥æ”¶è€…ï¼Œç›´æ¥å‘é€ç»™æ¥æ”¶è€…ï¼ˆæœ‰ç¼“å­˜åŒºæ—¶ï¼Œä¼šç»•è¿‡ç¼“å­˜åŒºï¼‰ if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } if c.qcount \u0026lt; c.dataqsiz { // æ²¡æœ‰æ¥æ”¶è€…ï¼Œå½“æœ‰ç¼“å­˜åŒºæ—¶ï¼Œå°†è¦å‘é€çš„å…ƒç´ æ”¾å…¥é˜Ÿåˆ—ä¸­ // Space is available in the channel buffer. Enqueue the element to send. qp := chanbuf(c, c.sendx) // è·å–ç¼“å­˜åœ°å€ if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) c.sendx++ // æŒ‡å‘ä¸‹ä¸€ä¸ªå­˜å‚¨çš„ä½ç½® if c.sendx == c.dataqsiz { c.sendx = 0 } c.qcount++ // ç¼“å­˜æ•°é‡ç›¸åŠ  unlock(\u0026amp;c.lock) return true } if !block { unlock(\u0026amp;c.lock) return false } // ç¼“å­˜åŒºæ»¡äº†ï¼Œå°†å½“å‰å‘é€åç¨‹åŠ å…¥åˆ°ç­‰å¾…sendé˜Ÿåˆ— // Block on the channel. Some receiver will complete our operation for us. gp := getg() // è·å–å½“å‰çš„gå‘é€åç¨‹ mysg := acquireSudog()// åˆ›å»ºsudogç­‰å¾…é˜Ÿåˆ— mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil // æŠŠå½“å‰çš„å‘é€åç¨‹ä¸ç­‰å¾…é˜Ÿåˆ—ç»‘å®š mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil // åŠ å…¥åˆ°å‘é€ç­‰å¾…é˜Ÿåˆ—ä¸­ c.sendq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren't considered as roots of the // stack tracer. KeepAlive(ep) // someone woke us up. // å‘é€åç¨‹è¢«å”¤é†’ï¼Œè§£é™¤ç­‰å¾…é˜Ÿåˆ—çš„é˜»å¡çŠ¶æ€ // åˆ¤æ–­çš„ç­‰å¾…é˜Ÿåˆ—æ˜¯å¦åœ¨ä¼‘çœ  if mysg != gp.waiting { throw(\u0026quot;G waiting list is corrupted\u0026quot;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) // é‡Šæ”¾ç­‰å¾…é˜Ÿåˆ— if closed { if c.closed == 0 { throw(\u0026quot;chansend: spurious wakeup\u0026quot;) } panic(plainError(\u0026quot;send on closed channel\u0026quot;)) } return true }  channel å‘é€æ•°æ®æ€»ç»“   åˆ¤æ–­chanæ˜¯å¦è¢«åˆå§‹åŒ–ï¼Œå‘chanä¸ºnilçš„chanå‘é€æ•°æ®å°†ä¼šæ°¸ä¹…é˜»å¡ æ£€æŸ¥åœ¨æ²¡æœ‰è·å–é”ï¼Œ åœ¨æ²¡æœ‰è·å–é”çš„æƒ…å†µä¸‹ä¼šå¯¼è‡´å‘é€å¤±è´¥çš„éé˜»å¡æ“ä½œ æ£€æŸ¥chanæ˜¯å¦å…³é—­ï¼Œå‘ä¹Ÿå…³é—­çš„chanå‘é€æ¶ˆæ¯,ä¼šå¼•å‘panic å¦‚æœæ¥æ”¶é˜Ÿåˆ—ä¸­æœ‰ç­‰å¾…çš„æ¥æ”¶è€…ï¼Œç›´æ¥å‘é€ç»™æ¥æ”¶è€…ï¼ˆæœ‰ç¼“å­˜åŒºæ—¶ï¼Œä¼šç»•è¿‡ç¼“å­˜åŒºï¼‰ æ²¡æœ‰æ¥æ”¶è€…ï¼Œå½“æœ‰ç¼“å­˜åŒºæ—¶ï¼Œå°†è¦å‘é€çš„å…ƒç´ æ”¾å…¥é˜Ÿåˆ—ä¸­ ç¼“å­˜åŒºæ»¡äº†ï¼Œå°†å½“å‰åç¨‹åŠ å…¥åˆ°sendç­‰å¾…é˜Ÿåˆ—ï¼Œå¹¶é˜»å¡ å½“å‘é€åç¨‹è¢«å”¤é†’ï¼Œè§£é™¤ç­‰å¾…é˜Ÿåˆ—çš„é˜»å¡çŠ¶æ€ï¼Œé‡Šæ”¾ç­‰å¾…é˜Ÿåˆ— \r  channel æ¥æ”¶æ•°æ®  \u0026lt;- data  chan æ¥æ”¶æ•°æ®æºç å¦‚ä¸‹: func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { // raceenabled: don't need to check ep, as it is always on the stack // or is new memory allocated by reflect. if debugChan { print(\u0026quot;chanrecv: chan=\u0026quot;, c, \u0026quot;\\n\u0026quot;) } // åˆ¤æ–­chanæ˜¯å¦åˆå§‹åŒ–ï¼Œè‹¥æ²¡æœ‰åˆå§‹åŒ–ï¼Œæ¥æ”¶channelæ•°æ®å°†é˜»å¡ if c == nil { if !block { return } gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026quot;unreachable\u0026quot;) } // æ£€æŸ¥chanæ˜¯å¦ä¸ºç©ºï¼Œæ˜¯å¦å…³é—­ // Fast path: check for failed non-blocking operation without acquiring the lock. if !block \u0026amp;\u0026amp; empty(c) { // After observing that the channel is not ready for receiving, we observe whether the // channel is closed. // // Reordering of these checks could lead to incorrect behavior when racing with a close. // For example, if the channel was open and not empty, was closed, and then drained, // reordered reads could incorrectly indicate \u0026quot;open and empty\u0026quot;. To prevent reordering, // we use atomic loads for both checks, and rely on emptying and closing to happen in // separate critical sections under the same lock. This assumption fails when closing // an unbuffered channel with a blocked send, but that is an error condition anyway. if atomic.Load(\u0026amp;c.closed) == 0 { // chanå…³é—­ï¼Œå°±è¿”å› // Because a channel cannot be reopened, the later observation of the channel // being not closed implies that it was also not closed at the moment of the // first observation. We behave as if we observed the channel at that moment // and report that the receive cannot proceed. return } // The channel is irreversibly closed. Re-check whether the channel has any pending data // to receive, which could have arrived between the empty and closed checks above. // Sequential consistency is also required here, when racing with such a send. if empty(c) { // å¦‚æœchanä¸ºç©º // The channel is irreversibly closed and empty. // // channel ä¸å¯é€†çš„å…³é—­äº†ä¸”ä¸ºç©º if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } } var t0 int64 if blockprofilerate \u0026gt; 0 { t0 = cputicks() } lock(\u0026amp;c.lock) // chan å…³é—­äº†ï¼Œæ¸…ç†ç¼“å†²åŒº if c.closed != 0 \u0026amp;\u0026amp; c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } unlock(\u0026amp;c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } // æ‰¾åˆ°ä¸€ä¸ªç­‰å¾…çš„å‘ä»¶äººã€‚å¦‚æœç¼“å†²åŒºå¤§å°ä¸º 0ï¼Œåˆ™ç›´æ¥ä»å‘é€æ–¹æ¥æ”¶å€¼ã€‚å¦åˆ™ï¼Œä»é˜Ÿåˆ—çš„å¤´éƒ¨æ¥æ”¶ // å¹¶å°†å‘é€è€…çš„å€¼æ·»åŠ åˆ°é˜Ÿåˆ—çš„å°¾éƒ¨ï¼ˆä¸¤è€…éƒ½æ˜ å°„åˆ° // ç›¸åŒçš„ç¼“å†²åŒºæ§½ï¼Œå› ä¸ºé˜Ÿåˆ—å·²æ»¡ï¼‰ // å¦‚æœæ˜¯æ— ç¼“å†²é˜Ÿåˆ—ï¼Œç›´æ¥ä»å‘é€æ–¹å–å€¼ // å¦‚æœæ˜¯å¾…ç¼“å†²çš„åŒºï¼Œå°±ä»ç¼“å†²åŒºå¤´éƒ¨è·å–å€¼ï¼Œå¹¶å°†å‘é€ç€çš„å€¼ä¿å­˜åœ¨ç¼“å†²åŒºå if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender's value to the tail of the queue (both map to // the same buffer slot because the queue is full). recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } // æ²¡æœ‰å‘é€çš„åç¨‹ï¼Œä½†æ˜¯ç¼“å†²åŒºæœ‰å…ƒç´ ï¼Œç›´æ¥è·å–ç¼“å†²åŒºå¤´éƒ¨çš„å€¼ if c.qcount \u0026gt; 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026amp;c.lock) return true, true } if !block { unlock(\u0026amp;c.lock) return false, false } // å½“æ²¡æœ‰å‘é€æ•°æ®çš„çš„åç¨‹ï¼Œä¸”ç¼“å†²åŒºå€¼ï¼Œå°±å°†æ¥æ”¶çš„åç¨‹æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ä¸­ // no sender available: block on this channel. gp := getg() // è·å–å½“å‰æ¥æ”¶åç¨‹ mysg := acquireSudog() // åˆ›å»ºç­‰å¾…é˜Ÿåˆ— mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg // å°†æ¥é€å†™åç¨‹ä¸ç­‰å¾…é˜Ÿåˆ—ç»‘å®š mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil // æ”¾å…¥åœ¨åç¨‹çš„ç­‰å¾…é˜Ÿåˆ—ä¸­ c.recvq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we're about // to park on a channel. The window between when this G's status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) //å½“æ¥æ”¶åç¨‹è¢«å”¤é†’æ—¶ï¼Œè§£é™¤é˜»å¡çŠ¶æ€ // someone woke us up if mysg != gp.waiting { throw(\u0026quot;G waiting list is corrupted\u0026quot;) } gp.waiting = nil gp.activeStackChans = false if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) // é‡Šæ”¾ç­‰å¾…é˜Ÿåˆ—å†…å­˜ return true, success }  channel å‘é€æ•°æ®æ€»ç»“   åˆ¤æ–­chanæ˜¯å¦åˆå§‹åŒ–ï¼Œè‹¥æ²¡æœ‰åˆå§‹åŒ–ï¼Œæ¥æ”¶channelæ•°æ®å°†é˜»å¡ æ£€æŸ¥chanæ˜¯å¦ä¸ºç©ºï¼Œæ˜¯å¦å…³é—­ å½“æœ‰å‘é€åç¨‹ï¼Œå¦‚æœæ˜¯æ— ç¼“å†²é˜Ÿåˆ—ï¼Œç›´æ¥ä»å‘é€æ–¹å–å€¼,å¦‚æœæ˜¯å¾…ç¼“å†²çš„åŒºï¼Œå°±ä»ç¼“å†²åŒºå¤´éƒ¨è·å–å€¼ï¼Œå¹¶å°†å‘é€ç€çš„å€¼ä¿å­˜åœ¨ç¼“å†²åŒºå å½“æ²¡æœ‰å‘é€åç¨‹ï¼Œä½†æ˜¯æœ‰ç¼“å†²åŒºæœ‰å…ƒç´ ï¼Œç›´æ¥è·å–ç¼“å†²åŒºå¤´éƒ¨çš„å€¼ å½“æ²¡æœ‰å‘é€æ•°æ®çš„çš„åç¨‹ï¼Œä¸”ç¼“å†²åŒºå€¼ï¼Œå°±å°†æ¥æ”¶çš„åç¨‹æ”¾å…¥ç­‰å¾…é˜Ÿåˆ—ä¸­ å½“æ¥æ”¶åç¨‹è¢«å”¤é†’æ—¶ï¼Œè§£é™¤é˜»å¡çŠ¶æ€ï¼Œé‡Šæ”¾ç­‰å¾…é˜Ÿåˆ—å†…å­˜ \r  channel å…³é—­  close(chan)  chan å…³é—­æºç å¦‚ä¸‹: func closechan(c *hchan) { // åˆ¤æ–­chanæ˜¯å¦åˆå§‹åŒ–ï¼Œæ²¡æœ‰åˆå§‹åŒ–ï¼Œå…³é—­æ²¡æœ‰åˆå§‹åŒ–çš„chan,ç›´æ¥panic if c == nil { panic(plainError(\u0026quot;close of nil channel\u0026quot;)) } // åˆ¤æ–­chanæ˜¯å¦ä¹Ÿè¢«å…³é—­ï¼Œå…³é—­ä¹Ÿå…³é—­çš„chan,ä¹Ÿä¼šå‘é€panic lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026quot;close of closed channel\u0026quot;)) } if raceenabled { callerpc := getcallerpc() racewritepc(c.raceaddr(), callerpc, funcPC(closechan)) racerelease(c.raceaddr()) } c.closed = 1 var glist gList // é‡Šæ”¾æ‰€æœ‰çš„æ¥æ”¶chanï¼Œå¹¶å°†æ‰€æœ‰çš„æ¥æ”¶é˜Ÿåˆ—åŠ å…¥åˆ°å¾…æ¸…é™¤é˜Ÿåˆ— glist ä¸­ // release all readers for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // é‡Šæ”¾æ‰€æœ‰çš„å‘é€chan,å‘é€è€…çš„ç­‰å¾…é˜Ÿåˆ— sendq ä¸­çš„ sudog æ”¾å…¥å¾…æ¸…é™¤é˜Ÿåˆ— glist ä¸­ // release all writers (they will panic) for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) æœ€åä¼šä¸ºæ‰€æœ‰è¢«é˜»å¡çš„ goroutine è°ƒç”¨ goready è§¦å‘è°ƒåº¦ã€‚å°†æ‰€æœ‰ glist ä¸­çš„ goroutine çŠ¶æ€ä» _Gwaiting è®¾ç½®ä¸º _Grunnable çŠ¶æ€ï¼Œç­‰å¾…è°ƒåº¦å™¨çš„è°ƒåº¦ã€‚ // Ready all Gs now that we've dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 goready(gp, 3) } }  channel å…³é—­æ€»ç»“   åˆ¤æ–­chanæ˜¯å¦åˆå§‹åŒ–ï¼Œæ²¡æœ‰åˆå§‹åŒ–ï¼Œå…³é—­æ²¡æœ‰åˆå§‹åŒ–çš„chan,ç›´æ¥panic åˆ¤æ–­chanæ˜¯å¦ä¹Ÿè¢«å…³é—­ï¼Œå…³é—­ä¹Ÿå…³é—­çš„chan,ä¹Ÿä¼šå‘é€panic å…ˆé‡Šæ”¾æ‰€æœ‰çš„æ¥æ”¶chanï¼Œå¹¶å°†æ‰€æœ‰çš„æ¥æ”¶é˜Ÿåˆ—åŠ å…¥åˆ°å¾…æ¸…é™¤é˜Ÿåˆ— glist ä¸­ é‡Šæ”¾æ‰€æœ‰çš„å‘é€chan,å‘é€è€…çš„ç­‰å¾…é˜Ÿåˆ— sendq ä¸­çš„ sudog æ”¾å…¥å¾…æ¸…é™¤é˜Ÿåˆ— glist ä¸­ æœ€åä¼šä¸ºæ‰€æœ‰è¢«é˜»å¡çš„ goroutine è°ƒç”¨ goready è§¦å‘è°ƒåº¦ã€‚å°†æ‰€æœ‰ glist ä¸­çš„goroutine çŠ¶æ€ä» _Gwaiting è®¾ç½®ä¸º _Grunnable çŠ¶æ€ï¼Œç­‰å¾…è°ƒåº¦å™¨çš„è°ƒåº¦ã€‚  ","date":"2021-10-15T22:00:38+08:00","image":"https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_huc32f323c0433538c753e80bb5a9a01bb_276268_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","title":"Go Channelçš„æ·±å…¥ç†è§£"},{"content":"é—®é¢˜  åœ¨æ”¶é›†æœåŠ¡çš„è®¿é—®è®°å½•æ—¶ï¼Œéœ€è¦å°†è®¿é—®è®°å½•ä¿å­˜ï¼Œå®šä¹‰ç»“æ„ä½“å¦‚ä¸‹    type accessData struct { RemoteAddr string // è¿œç¨‹è®¿é—®ä¸»æœºåœ°å€ RequestURI string //è®¿é—®çš„è·¯ç”± ServerName string // è®¿é—®çš„æœåŠ¡åç§° AccessDate string //è®¿é—®çš„æ—¶é—´ RunStatus bool //æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ RunError error //è¿è¡ŒæŠ¥é”™ï¼šæŠ¥é”™ä¿¡æ¯. ServerParam interface{} // è®¿é—®æœåŠ¡çš„å‚æ•° }   é€šè¿‡ç»“æ„ä½“è½¬jsonï¼ŒåŒæ—¶é€šè¿‡getè¯·æ±‚å¾—åˆ°å›¾ä¸‹ç»“æœ \r\n  \u0026ldquo;RunError\u0026rdquo;: {},è¢«jsonè½¬ä¸º{}çš„å­—ç¬¦ï¼Œ æ‰“å°ç»“æ„ä½“ï¼Œå‘ç°é”™è¯¯ä¿¡æ¯æ˜¯æœ‰çš„ï¼š{192.168.1.101:53364 /v1/alarms/out/d GetOutAlarms 2021-10-12 10:09:42 false æ²¡æœ‰è¿™ä¸ªæŠ¥è­¦ğŸ†”id },è¯´æ˜æ˜¯error è½¬jsoné—®é¢˜\né—®é¢˜åˆ†æä¸è§£å†³  é—®é¢˜åˆ†ææŸ¥çœ‹errorç±»å‹å®šä¹‰å‘ç°ï¼šerrorç±»å‹åªæ˜¯ä¸€ä¸ªæ¥å£ã€‚å®ƒå¯ä»¥åŒ…å«ä»»ä½•å®ç°å®ƒçš„å…·ä½“ç±»å‹çš„å€¼ è§£å†³ï¼šå°†ç»“æ„ä½“ä¸­é”™è¯¯è½¬åŒ–ä¸ºå­—ç¬¦ä¸²ç±»å‹ï¼ŒåŒæ—¶ç”¨err.Error()è¿”å›æ˜¯é”™è¯¯çš„å­—ç¬¦ä¸²  type accessData struct { RemoteAddr string // è¿œç¨‹è®¿é—®ä¸»æœºåœ°å€ RequestURI string //è®¿é—®çš„è·¯ç”± ServerName string // è®¿é—®çš„æœåŠ¡åç§° AccessDate string //è®¿é—®çš„æ—¶é—´ RunStatus bool //æœåŠ¡æ˜¯å¦æ­£å¸¸è¿è¡Œ RunError string //è¿è¡ŒæŠ¥é”™ï¼šæŠ¥é”™ä¿¡æ¯. ServerParam interface{} // è®¿é—®æœåŠ¡çš„å‚æ•° } type error interface { Error() string }   ç»“æœå¦‚å›¾\n  \r\n  ","date":"2021-10-09T22:00:38+08:00","image":"https://zcj-git520.github.io/p/golang/2_hu3607656af67f333528ae9e7b0ed06a62_30106_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/golang/","title":"go errorç±»å‹è½¬json"},{"content":"go åç¨‹goroutine  åç¨‹æ˜¯ç”¨æˆ·çº§çš„çº¿ç¨‹ï¼Œæœ‰ç”¨æˆ·è‡ªå·±è°ƒåº¦ï¼Œä½¿ç”¨åç¨‹ä½¿å¾—ç¨‹åºè°ƒåº¦æ›´åŠ çµæ´»ã€‚åŒæ—¶æ¯”çº¿ç¨‹æ›´è½»é‡ï¼Œå ç”¨çš„æ ˆå†…å­˜æ›´å°‘ã€‚goè¯­è¨€å¤©ç”Ÿæ”¯æŒé«˜å¹¶å‘ï¼Œgoä½¿ç”¨åç¨‹goroutineçš„è°ƒåº¦å™¨ã€‚goroutine çš„æ ˆå†…å­˜æœ€å°å€¼ä¸º2kb(_StackMin = 2048),å®ƒä¸æ˜¯å›ºå®šä¸å˜çš„ï¼Œå¯ä»¥éšéœ€æ±‚å¢å¤§å’Œç¼©å°ã€‚goroutine ç»´æŠ¤ç€å¾ˆå¤§çš„å†…å­˜ï¼Œæ— éœ€é¢‘ç¹å¼€è¾Ÿå†…å­˜ï¼Œgoroutineæ˜¯ä½¿ç”¨M:næ¨¡å‹ï¼Œåœ¨ç”¨æˆ·æ€åˆ‡æ¢åç¨‹ï¼ŒåŠ ä¸Šåˆ›å»ºåç¨‹ä»£ä»·ä½ï¼Œä½¿å¾—cpuçš„åˆ©ç”¨ç‡å¤§å¤§æå‡ï¼Œcupçš„æ€§èƒ½å¤§å¹…åº¦çš„è¢«åˆ©ç”¨ã€‚  goroutine è°ƒåº¦å™¨GPMæ¨¡å‹ G  G å°±æ˜¯goroutineåç¨‹  type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue. // It is stack.lo+StackGuard on g0 and gsignal stacks. // It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash). // è®°å½•è¯¥goroutineä½¿ç”¨çš„æ ˆ stack stack // offset known to runtime/cgo //ä¸‹é¢ä¸¤ä¸ªæˆå‘˜ç”¨äºæ ˆæº¢å‡ºæ£€æŸ¥ï¼Œå®ç°æ ˆçš„è‡ªåŠ¨ä¼¸ç¼©ï¼ŒæŠ¢å è°ƒåº¦ä¹Ÿä¼šç”¨åˆ°stackguard0 stackguard0 uintptr // offset known to liblink stackguard1 uintptr // offset known to liblink _panic *_panic // innermost panic - offset known to liblink _defer *_defer // innermost defer // æ­¤goroutineæ­£åœ¨è¢«å“ªä¸ªå·¥ä½œçº¿ç¨‹æ‰§è¡Œ m *m // current m; offset known to arm liblink //è¿™ä¸ªå­—æ®µè·Ÿè°ƒåº¦åˆ‡æ¢æœ‰å…³ï¼ŒGåˆ‡æ¢æ—¶ç”¨æ¥ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œä¿å­˜ä»€ä¹ˆï¼Œçœ‹ä¸‹é¢gobufç»“æ„ä½“ sched gobuf syscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc syscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc stktopsp uintptr // expected sp at top of stack, to check in traceback param unsafe.Pointer // passed parameter on wakeupï¼Œwakeupå”¤é†’æ—¶ä¼ é€’çš„å‚æ•° // çŠ¶æ€Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead atomicstatus uint32 stackLock uint32 // sigprof/scang lock; TODO: fold in to atomicstatus goid int64 //schedlinkå­—æ®µæŒ‡å‘å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„ä¸‹ä¸€ä¸ªgï¼Œ //æ‰€æœ‰ä½äºå…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­çš„gå½¢æˆä¸€ä¸ªé“¾è¡¨ schedlink guintptr waitsince int64 // approx time when the g become blocked waitreason waitReason // if status==Gwaitingï¼Œgè¢«é˜»å¡çš„åŸå›  //æŠ¢å ä¿¡å·ï¼Œstackguard0 = stackpreemptï¼Œå¦‚æœéœ€è¦æŠ¢å è°ƒåº¦ï¼Œè®¾ç½®preemptä¸ºtrue preempt bool // preemption signal, duplicates stackguard0 = stackpreempt paniconfault bool // panic (instead of crash) on unexpected fault address preemptscan bool // preempted g does scan for gc gcscandone bool // g has scanned stack; protected by _Gscan bit in status gcscanvalid bool // false at start of gc cycle, true if G has not run since last scan; TODO: remove? throwsplit bool // must not split stack raceignore int8 // ignore race detection events sysblocktraced bool // StartTrace has emitted EvGoInSyscall about this goroutine sysexitticks int64 // cputicks when syscall has returned (for tracing) traceseq uint64 // trace event sequencer tracelastp puintptr // last P emitted an event for this goroutine // å¦‚æœè°ƒç”¨äº† LockOsThreadï¼Œé‚£ä¹ˆè¿™ä¸ª g ä¼šç»‘å®šåˆ°æŸä¸ª m ä¸Š lockedm muintptr sig uint32 writebuf []byte sigcode0 uintptr sigcode1 uintptr sigpc uintptr // åˆ›å»ºè¿™ä¸ªgoroutineçš„goè¡¨è¾¾å¼çš„pc gopc uintptr // pc of go statement that created this goroutine ancestors *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors) startpc uintptr // pc of goroutine function racectx uintptr waiting *sudog // sudog structures this g is waiting on (that have a valid elem ptr); in lock order cgoCtxt []uintptr // cgo traceback context labels unsafe.Pointer // profiler labels timer *timer // cached timer for time.Sleep,ä¸º time.Sleep ç¼“å­˜çš„è®¡æ—¶å™¨ selectDone uint32 // are we participating in a select and did someone win the race? // Per-G GC state // gcAssistBytes is this G's GC assist credit in terms of // bytes allocated. If this is positive, then the G has credit // to allocate gcAssistBytes bytes without assisting. If this // is negative, then the G must correct this by performing // scan work. We track this in bytes to make it fast to update // and check for debt in the malloc hot path. The assist ratio // determines how this corresponds to scan work debt. gcAssistBytes int64 }  ä¿å­˜ç€goroutineæ‰€æœ‰ä¿¡æ¯ä»¥åŠæ ˆä¿¡æ¯ï¼Œgobufç»“æ„ä½“ï¼šcpué‡Œçš„å¯„å­˜å™¨ä¿¡æ¯  P processorå¤„ç†å™¨  è°ƒåº¦åç¨‹Gå’Œçº¿ç¨‹Mçš„å…³è”  P çš„ç»“æ„ä½“å¦‚ä¸‹ï¼š type p struct { //allpä¸­çš„ç´¢å¼• id int32 //pçš„çŠ¶æ€ status uint32 // one of pidle/prunning/... link puintptr schedtick uint32 // incremented on every scheduler call-\u0026gt;æ¯æ¬¡schedulerè°ƒç”¨+1 syscalltick uint32 // incremented on every system call-\u0026gt;æ¯æ¬¡ç³»ç»Ÿè°ƒç”¨+1 sysmontick sysmontick // last tick observed by sysmon //æŒ‡å‘ç»‘å®šçš„ mï¼Œå¦‚æœ p æ˜¯ idle çš„è¯ï¼Œé‚£è¿™ä¸ªæŒ‡é’ˆæ˜¯ nil m muintptr // back-link to associated m (nil if idle) mcache *mcache raceprocctx uintptr //ä¸åŒå¤§å°å¯ç”¨deferç»“æ„æ±  deferpool [5][]*_defer // pool of available defer structs of different sizes (see panic.go) deferpoolbuf [5][32]*_defer // Cache of goroutine ids, amortizes accesses to runtimeÂ·sched.goidgen. goidcache uint64 goidcacheend uint64 //æœ¬åœ°è¿è¡Œé˜Ÿåˆ—ï¼Œå¯ä»¥æ— é”è®¿é—® // Queue of runnable goroutines. Accessed without lock. runqhead uint32 //é˜Ÿåˆ—å¤´ runqtail uint32 //é˜Ÿåˆ—å°¾ //æ•°ç»„å®ç°çš„å¾ªç¯é˜Ÿåˆ— runq [256]guintptr // runnext, if non-nil, is a runnable G that was ready'd by // the current G and should be run next instead of what's in // runq if there's time remaining in the running G's time // slice. It will inherit the time left in the current time // slice. If a set of goroutines is locked in a // communicate-and-wait pattern, this schedules that set as a // unit and eliminates the (potentially large) scheduling // latency that otherwise arises from adding the ready'd // goroutines to the end of the run queue. // runnext éç©ºæ—¶ï¼Œä»£è¡¨çš„æ˜¯ä¸€ä¸ª runnable çŠ¶æ€çš„ Gï¼Œ //è¿™ä¸ª G è¢« å½“å‰ G ä¿®æ”¹ä¸º ready çŠ¶æ€ï¼Œç›¸æ¯” runq ä¸­çš„ G æœ‰æ›´é«˜çš„ä¼˜å…ˆçº§ã€‚ //å¦‚æœå½“å‰ G è¿˜æœ‰å‰©ä½™çš„å¯ç”¨æ—¶é—´ï¼Œé‚£ä¹ˆå°±åº”è¯¥è¿è¡Œè¿™ä¸ª G //è¿è¡Œä¹‹åï¼Œè¯¥ G ä¼šç»§æ‰¿å½“å‰ G çš„å‰©ä½™æ—¶é—´ runnext guintptr // Available G's (status == Gdead) //ç©ºé—²çš„g gFree struct { gList n int32 } sudogcache []*sudog sudogbuf [128]*sudog tracebuf traceBufPtr // traceSweep indicates the sweep events should be traced. // This is used to defer the sweep start event until a span // has actually been swept. traceSweep bool // traceSwept and traceReclaimed track the number of bytes // swept and reclaimed by sweeping in the current sweep loop. traceSwept, traceReclaimed uintptr palloc persistentAlloc // per-P to avoid mutex _ uint32 // Alignment for atomic fields below // Per-P GC state gcAssistTime int64 // Nanoseconds in assistAlloc gcFractionalMarkTime int64 // Nanoseconds in fractional mark worker (atomic) gcBgMarkWorker guintptr // (atomic) gcMarkWorkerMode gcMarkWorkerMode // gcMarkWorkerStartTime is the nanotime() at which this mark // worker started. gcMarkWorkerStartTime int64 // gcw is this P's GC work buffer cache. The work buffer is // filled by write barriers, drained by mutator assists, and // disposed on certain GC state transitions. gcw gcWork // wbBuf is this P's GC write barrier buffer. // // TODO: Consider caching this in the running G. wbBuf wbBuf runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point pad cpu.CacheLinePad }  è®°å½•ç€Pçš„ä¿¡æ¯ï¼Œä»¥åŠGçš„çŠ¶æ€ç­‰ã€‚åŒæ—¶Pæ˜¯æœ‰ç€æœ¬åœ°é˜Ÿåˆ—ï¼Œå­˜æ”¾ç€å¸¦å¾…è¿è¡Œçš„G,æœ¬åœ°é˜Ÿåˆ—ä¸èƒ½è¶…è¿‡256ä¸ªã€‚ Pçš„æ•°é‡ï¼šæ˜¯ç”±ç¯å¢ƒå˜é‡ $GOMAXPROCS æˆ–è€…æ˜¯ç”± runtime çš„æ–¹æ³• GOMAXPROCS() å†³å®šã€‚åœ¨ç¨‹åºå¯åŠ¨å¼åˆ›å»ºï¼Œå¹¶ä¿å­˜åœ¨æ•°ç»„ä¸­ï¼Œæœ€å¤šæœ‰ GOMAXPROCS(å¯é…ç½®) ä¸ª  M æ˜¯å†…æ ¸æ€çº¿ç¨‹çš„æŠ½è±¡  ä¸»è¦çš„å·¥ä½œæ‰§è¡Œåç¨‹Gæˆ–è€…åœ¨è°ƒåº¦Gåˆ°Pä¸­  Mçš„ç»“æ„ä½“å¦‚ä¸‹ï¼š type m struct { // ç³»ç»Ÿç®¡ç†çš„ä¸€ä¸ªgï¼Œæ‰§è¡Œè°ƒåº¦ä»£ç æ—¶ä½¿ç”¨çš„ã€‚æ¯”å¦‚æ‰§è¡Œç”¨æˆ·çš„goroutineæ—¶ï¼Œå°±éœ€è¦æŠŠæŠŠç”¨æˆ· // çš„æ ˆä¿¡æ¯æ¢åˆ°å†…æ ¸çº¿ç¨‹çš„æ ˆï¼Œä»¥ä¾¿èƒ½å¤Ÿæ‰§è¡Œç”¨æˆ·goroutine g0 *g // goroutine with scheduling stack morebuf gobuf // gobuf arg to morestack divmod uint32 // div/mod denominator for arm - known to liblink // Fields not known to debuggers. procid uint64 // for debuggers, but offset not hard-coded //å¤„ç†signalçš„ g gsignal *g // signal-handling g goSigStack gsignalStack // Go-allocated signal handling stack sigmask sigset // storage for saved signal mask //çº¿ç¨‹çš„æœ¬åœ°å­˜å‚¨TLSï¼Œè¿™é‡Œå°±æ˜¯ä¸ºä»€ä¹ˆOSçº¿ç¨‹èƒ½è¿è¡ŒMå…³é”®åœ°æ–¹ tls [6]uintptr // thread-local storage (for x86 extern register) //go å…³é”®å­—è¿è¡Œçš„å‡½æ•° mstartfn func() //å½“å‰è¿è¡Œçš„ç”¨æˆ·goroutineçš„gç»“æ„ä½“å¯¹è±¡ curg *g // current running goroutine caughtsig guintptr // goroutine running during fatal signal //å½“å‰å·¥ä½œçº¿ç¨‹ç»‘å®šçš„Pï¼Œå¦‚æœæ²¡æœ‰å°±ä¸ºnil p puintptr // attached p for executing go code (nil if not executing go code) //æš‚å­˜ä¸å½“å‰Mæ½œåœ¨å…³è”çš„P nextp puintptr //Mä¹‹å‰è°ƒç”¨çš„P oldp puintptr // the p that was attached before executing a syscall id int64 mallocing int32 throwing int32 //å½“å‰Mæ˜¯å¦å…³é—­æŠ¢å å¼è°ƒåº¦ preemptoff string // if != \u0026quot;\u0026quot;, keep curg running on this m locks int32 dying int32 profilehz int32 //Mçš„è‡ªæ—‹çŠ¶æ€ï¼Œä¸ºtrueæ—¶Må¤„äºè‡ªæ—‹çŠ¶æ€ï¼Œæ­£åœ¨ä»å…¶ä»–çº¿ç¨‹å·G; ä¸ºfalseï¼Œä¼‘çœ çŠ¶æ€ spinning bool // m is out of work and is actively looking for work blocked bool // m is blocked on a note newSigstack bool // minit on C thread called sigaltstack printlock int8 incgo bool // m is executing a cgo call freeWait uint32 // if == 0, safe to free g0 and delete m (atomic) fastrand [2]uint32 needextram bool traceback uint8 ncgocall uint64 // number of cgo calls in total ncgo int32 // number of cgo calls currently in progress cgoCallersUse uint32 // if non-zero, cgoCallers in use temporarily cgoCallers *cgoCallers // cgo traceback if crashing in cgo call //æ²¡æœ‰goroutineè¿è¡Œæ—¶ï¼Œå·¥ä½œçº¿ç¨‹ç¡çœ  //é€šè¿‡è¿™ä¸ªæ¥å”¤é†’å·¥ä½œçº¿ç¨‹ park note // ä¼‘çœ é” //è®°å½•æ‰€æœ‰å·¥ä½œçº¿ç¨‹çš„é“¾è¡¨ alllink *m // on allm schedlink muintptr //å½“å‰çº¿ç¨‹å†…å­˜åˆ†é…çš„æœ¬åœ°ç¼“å­˜ mcache *mcache //å½“å‰Mé”å®šçš„Gï¼Œ lockedg guintptr createstack [32]uintptr // stack that created this thread. lockedExt uint32 // tracking for external LockOSThread lockedInt uint32 // tracking for internal lockOSThread nextwaitm muintptr // next m waiting for lock waitunlockf func(*g, unsafe.Pointer) bool waitlock unsafe.Pointer waittraceev byte waittraceskip int startingtrace bool syscalltick uint32 //æ“ä½œç³»ç»Ÿçº¿ç¨‹id thread uintptr // thread handle freelink *m // on sched.freem // these are here because they are too large to be on the stack // of low-level NOSPLIT functions. libcall libcall libcallpc uintptr // for cpu profiler libcallsp uintptr libcallg guintptr syscall libcall // stores syscall parameters on windows vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call) vdsoPC uintptr // PC for traceback while in VDSO call dlogPerM mOS }  è®°å½•ç€Mçš„çº¿ç¨‹çš„ä¿¡æ¯ï¼ŒåŒ…æ‹¬ä¸€äº›P,Gä»¥åŠä¿¡å·å’Œè‡ªæ—‹é”ç­‰ä¿¡æ¯ m æ•°é‡ï¼šå¯ä»¥é€šè¿‡SetMaxThreadså‡½æ•°ï¼Œè®¾ç½® M çš„æœ€å¤§æ•°é‡ï¼Œé»˜è®¤ä¸º10000(sched.maxmcount = 10000)ï¼Œå’ŒPä¸€æ ·åœ¨ç¨‹åºå¯åŠ¨æ—¶åˆ›å»ºã€‚  å…¨å±€é˜Ÿåˆ—ï¼ˆgQueueï¼‰  Pçš„æœ¬åœ°é˜Ÿåˆ—å¯ä»¥å­˜æ”¾ç€ä¸è¶…è¿‡256ä¸ªå¾…æ‰§è¡Œçš„G,Pæ˜¯æœ‰é™çš„ï¼Œå½“Gè¿‡å¤šæ—¶ï¼Œå³å½“Pæœ¬åœ°é˜Ÿåˆ—å­˜æ”¾ä¸ä¸‹æ—¶ï¼Œå°±éœ€è¦å°†Gå­˜æ”¾åœ¨å…¨å±€é˜Ÿåˆ—ä¸­ã€‚  å…¨å±€é˜Ÿåˆ—ç»“æ„å¦‚ä¸‹ï¼š type gQueue struct { head guintptr //é˜Ÿåˆ—å¤´ tail guintptr //é˜Ÿåˆ—å°¾ } Gã€Pã€Mã€gQueueå…³ç³»  Pä¸Mæ²¡æœ‰æ•°é‡å…³ç³»ï¼Œå½“ä¸€ä¸ªMå¤„äºé˜»å¡æ—¶ï¼ŒPå…ˆæ‰¾ç©ºé—²M,æ²¡æœ‰ç©ºé—²çš„Må°±åˆ›å»ºæ–°çš„M Gä¼˜å…ˆå­˜æ”¾åœ¨Pæœ¬åœ°é˜Ÿåˆ—ä¸­ï¼Œå½“Pä¸­Gæ»¡æ—¶ï¼Œä¼šå°†Pä¸­å‰ä¸€åŠGå­˜æ”¾åœ¨å…¨å±€ä¸­ã€‚å½“Pç©ºé—²æ—¶æ—¶ï¼Œä¼šä»å…¨å±€ä¸­æ‹¿å–Gæ”¾åœ¨æœ¬åœ°é˜Ÿåˆ—ã€‚å…¨å±€æ²¡æœ‰Gæ—¶ï¼Œä¼šä»å…¶Pçš„æœ¬åœ°é˜Ÿåˆ—ä¸­æ‹¿å–ä¸€åŠåˆ°æœ¬åœ°é˜Ÿåˆ—ã€‚ å…³ç³»å¦‚å›¾æ‰€ç¤ºï¼š\n\r  åˆ›å»ºgoroutine newproc()å‡½æ•°  goroutine æ˜¯ç”±å‡½æ•°newprocå‡½æ•°è¿›è¡Œåˆ›å»ºçš„ï¼Œnewprocæºç å¦‚ä¸‹  // å‚æ•°ï¼šåç¨‹å‡½æ•°çš„å‚æ•°å çš„å­—èŠ‚æ•°å’Œåç¨‹å…¥å£å‡½æ•°çš„funcvalæŒ‡é’ˆ func newproc(siz int32, fn *funcval) { // è·å¾—åç¨‹å‚æ•°çš„åœ°å€= fnå‡½æ•°åœ°å€+åç§»å€¼ argp := add(unsafe.Pointer(\u0026amp;fn), sys.PtrSize) gp := getg() // è·å¾—å½“å‰Gçš„æŒ‡é’ˆ //è°ƒç”¨è€…çš„pcï¼Œä¹Ÿå°±æ˜¯æ‰§è¡Œå®Œæ­¤å‡½æ•°è¿”å›è°ƒç”¨è€…æ—¶çš„ä¸‹ä¸€æ¡æŒ‡ä»¤åœ°å€ pc := getcallerpc() // åˆ‡æ¢åˆ°ï¼ˆç³»ç»Ÿæ ˆï¼‰g0æ ˆä¸­ systemstack(func() { //æ‰§è¡Œè°ƒç”¨newproc1()å‡½æ•°æ‰§è¡Œåˆ›å»ºåç¨‹ newg := newproc1(fn, argp, siz, gp, pc) _p_ := getg().m.p.ptr() // æŠŠå½“å‰çš„Gå­˜æ”¾åœ¨runqé˜Ÿåˆ—ä¸­ runqput(_p_, newg, true) // å¦‚æœå½“å‰ç”±ç©ºé—²çš„P,æ²¡æœ‰ç¡çœ çš„M,ä¸»åç¨‹å¼€å§‹è¿è¡Œæ—¶ if mainStarted { wakep() // åˆ›å»ºm,å¹¶è®¾ç½®ä¸ºæ´»è·ƒçŠ¶æ€ } }) }  åœ¨newprocå‡½æ•°ä¸­ä¸ºä»€ä¹ˆè¦åˆ‡æ¢åœ¨g0æ ˆä¸­æ‰§è¡Œå‘¢ï¼Ÿæ˜¯å› ä¸ºnewproc1()å‡½æ•°ä¸æ”¯æŒæ ˆå¢é•¿ï¼Œåç¨‹çš„æ ˆç©ºé—´å°(å‡ KB)ï¼Œä¸ºäº†é˜²æ­¢è¿è¡Œåç¨‹å‡½æ•°æ—¶æ ˆæº¢å‡ºï¼Œéœ€è¦åœ¨g0çš„æ ˆä¸Šè¿è¡Œï¼Œg0æ˜¯åˆ†é…åœ¨çº¿ç¨‹çš„æ ˆç©ºé—´(4MB)ä¸Šã€‚g0çš„æ ˆç©ºé—´å¾ˆå¤§ï¼Œè¿è¡Œåç¨‹å‡½æ•°æ—¶æ ˆä¸æº¢å‡ºã€‚  newproc1()å‡½æ•°  newproc1()æ˜¯åˆ›å»ºåç¨‹ æºç å¦‚ä¸‹ï¼š  å‚æ•°ï¼šåç¨‹å…¥å£ã€å‚æ•°é¦–åœ°å€ã€å‚æ•°å¤§å°ã€çˆ¶åç¨‹æŒ‡é’ˆã€è¿”å›åœ°å€ func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g { _g_ := getg() // è·å¾—å½“å‰çš„G if fn == nil { _g_.m.throwing = -1 // do not dump full stacks throw(\u0026quot;go of nil func value\u0026quot;) } // ä¸ºäº†ä¿è¯æ•°æ®ä¸€è‡´æ€§ä¼šç¦æ­¢å½“å‰mè¢«æŠ¢å  acquirem() // disable preemption because it can be holding p in a local var siz := narg siz = (siz + 7) \u0026amp;^ 7 // We could allocate a larger initial stack if necessary. // Not worth it: this is almost always an error. // 4*sizeof(uintreg): extra space added below // sizeof(uintreg): caller's LR (arm) or return address (x86, in gostartcall). if siz \u0026gt;= _StackMin-4*sys.RegSize-sys.RegSize { throw(\u0026quot;newproc: function arguments too large for new goroutine\u0026quot;) } _p_ := _g_.m.p.ptr() // å°è¯•è·å–ä¸€ä¸ªç©ºé—²çš„G,å¦‚æœæ²¡æœ‰ç©ºé—²çš„G,å°±ä¼šåˆ›å»ºæ–°çš„G,åˆ†é…æ ˆç©ºé—´,å¹¶æ·»åŠ åˆ°å…¨å±€allgsä¸­ newg := gfget(_p_) // å¦‚æœæ²¡æœ‰ç©ºé—²çš„G if newg == nil { // å°±ä¼šåˆ›å»ºæ–°çš„G,åˆ†é…æ ˆç©ºé—´å¤§å°ä¸ºæœ€å°çš„2KB newg = malg(_StackMin) // è®¾ç½®çŠ¶æ€ä¸ºç­‰å¾… casgstatus(newg, _Gidle, _Gdead) //å¹¶æ·»åŠ åˆ°å…¨å±€allgsä¸­ allgadd(newg) // publishes with a g-\u0026gt;status of Gdead so GC scanner doesn't look at uninitialized stack. } if newg.stack.hi == 0 { throw(\u0026quot;newproc1: newg missing stack\u0026quot;) } if readgstatus(newg) != _Gdead { throw(\u0026quot;newproc1: new g is not Gdead\u0026quot;) } totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame totalSize += -totalSize \u0026amp; (sys.SpAlign - 1) // align to spAlign sp := newg.stack.hi - totalSize spArg := sp if usesLR { // caller's LR *(*uintptr)(unsafe.Pointer(sp)) = 0 prepGoExitFrame(sp) spArg += sys.MinFrameSize } if narg \u0026gt; 0 { // å¦‚æœåç¨‹å…¥å£å‡½æ•°ç”±å‚æ•°ï¼Œä¼šå°†å‚æ•°ç§»åŠ¨åœ¨åç¨‹æ ˆä¸­ memmove(unsafe.Pointer(spArg), argp, uintptr(narg)) // This is a stack-to-stack copy. If write barriers // are enabled and the source stack is grey (the // destination is always black), then perform a // barrier copy. We do this *after* the memmove // because the destination stack may have garbage on // it. if writeBarrier.needed \u0026amp;\u0026amp; !_g_.m.curg.gcscandone { f := findfunc(fn.fn) stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps)) if stkmap.nbit \u0026gt; 0 { // We're in the prologue, so it's always stack map index 0. bv := stackmapdata(stkmap, 0) bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata) } } } // åˆå§‹åŒ–newg.schedè°ƒåº¦ç›¸å…³çš„ä¿¡æ¯ memclrNoHeapPointers(unsafe.Pointer(\u0026amp;newg.sched), unsafe.Sizeof(newg.sched)) newg.sched.sp = sp //è®¾ç½®ä¸ºåç¨‹æ ˆæŒ‡é’ˆ newg.stktopsp = sp // è®¾ç½®ä¸ºæŒ‡å‘åç¨‹å…¥å£å‡½æ•°çš„å…¥å£ï¼Œå½“åç¨‹è°ƒåº¦æ‰§è¡Œæ—¶ï¼Œè¿è¡Œåç¨‹å‡½æ•° newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function newg.sched.g = guintptr(unsafe.Pointer(newg)) gostartcallfn(\u0026amp;newg.sched, fn) // è®¾ç½®ä¸ºçˆ¶åç¨‹è°ƒç”¨newprocå‡½æ•°ç»“æŸåçš„è¿”å›åœ°å€ newg.gopc = callerpc newg.ancestors = saveAncestors(callergp) // è®¾ç½®startpcä¸ºåç¨‹å…¥å­”å‡½æ•°çš„èµ·å§‹åœ°å€ newg.startpc = fn.fn if _g_.m.curg != nil { newg.labels = _g_.m.curg.labels } if isSystemGoroutine(newg, false) { atomic.Xadd(\u0026amp;sched.ngsys, +1) } // è®¾ç½®åç¨‹ä¸ºè¿è¡ŒçŠ¶æ€ casgstatus(newg, _Gdead, _Grunnable) if _p_.goidcache == _p_.goidcacheend { // Sched.goidgen is the last allocated id, // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch]. // At startup sched.goidgen=0, so main goroutine receives goid=1. _p_.goidcache = atomic.Xadd64(\u0026amp;sched.goidgen, _GoidCacheBatch) _p_.goidcache -= _GoidCacheBatch - 1 _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch } // ç»™åç¨‹èµ‹äºˆä¸€ä¸ªå”¯ä¸€çš„goid newg.goid = int64(_p_.goidcache) _p_.goidcache++ if raceenabled { newg.racectx = racegostart(callerpc) } if trace.enabled { traceGoCreate(newg, newg.startpc) } // å…è®¸å½“å‰mè¢«æŠ¢å  releasem(_g_.m) return newg } å›¾ç¤ºå¦‚ä¸‹\n\r\n æ€»ç»“goroutineåˆ›å»ºè¿‡ç¨‹   ä¸ºäº†ä¿è¯æ•°æ®ä¸€è‡´æ€§ä¼šç¦æ­¢å½“å‰mè¢«æŠ¢å  å°è¯•è·å–ä¸€ä¸ªç©ºé—²çš„G,å¦‚æœæ²¡æœ‰ç©ºé—²çš„G,å°±ä¼šåˆ›å»ºæ–°çš„G,åˆ†é…æ ˆç©ºé—´,çŠ¶æ€ä¸ºç­‰å¾…å¹¶æ·»åŠ åˆ°å…¨å±€allgsä¸­ å¦‚æœåç¨‹å…¥å£å‡½æ•°ç”±å‚æ•°ï¼Œä¼šå°†å‚æ•°ç§»åŠ¨åœ¨åç¨‹æ ˆä¸­ åˆå§‹åŒ–newg.schedè°ƒåº¦ç›¸å…³çš„ä¿¡æ¯ï¼Œè®¾ç½®çŠ¶æ€è¿è¡Œ å¾—åˆ°å”¯ä¸€çš„goid, å¹¶æ·»åŠ åˆ°runqé˜Ÿåˆ—ä¸­ å¦‚æœå½“å‰æœ‰ç©ºé—²çš„P,æ²¡æœ‰ç¡çœ çš„M,å¹¶ä¸”ä¸»åç¨‹å¼€å§‹è¿è¡Œæ—¶ï¼Œå°±ä¼šåˆ›å»ºæ–°çš„æ´»è·ƒçš„M å½“gè¿è¡Œç»“æŸåï¼Œè®¾ç½®å…è®¸å½“å‰mè¢«æŠ¢å   goroutineçš„è®©å‡ºä¸æ¢å¤ã€è°ƒåº¦ã€æŠ¢å ã€ç›‘æ§ goroutine è®©å‡ºä¸æ¢å¤  åç¨‹çš„è®©å‡ºæ˜¯ç”±å‡½æ•°gopark()æ‰§è¡Œçš„  æºç å¦‚ä¸‹ï¼š func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) { if reason != waitReasonSleep { checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy } // ç¦æ­¢å½“å‰mè¢«æŠ¢å  mp := acquirem() gp := mp.curg status := readgstatus(gp) // åˆ¤æ–­åç¨‹çš„æ˜¯å¦åœ¨è¿è¡ŒçŠ¶æ€ if status != _Grunning \u0026amp;\u0026amp; status != _Gscanrunning { throw(\u0026quot;gopark: bad g status\u0026quot;) } mp.waitlock = lock mp.waitunlockf = unlockf gp.waitreason = reason mp.waittraceev = traceEv mp.waittraceskip = traceskip // è§£é™¤å¯¹mçš„æŠ¢å  releasem(mp) // can't do anything that might move the G between Ms here. // ä¸èƒ½åšä»»ä½•å¯èƒ½åœ¨ Ms ä¹‹é—´ç§»åŠ¨ G çš„äº‹æƒ…ã€‚ // ä¿å­˜åç¨‹ï¼Œåˆ‡æ¢åœ¨go mcall(park_m) } func park_m(gp *g) { _g_ := getg() if trace.enabled { traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip) } //æ›´æ”¹åç¨‹ç”±è¿è¡ŒçŠ¶æ€åˆ°ç­‰å¾…çŠ¶æ€ casgstatus(gp, _Grunning, _Gwaiting) dropg() \u0026quot;\u0026quot;\u0026quot; func dropg() { _g_ := getg() // æŠŠmå½“å‰æ‰§è¡Œçš„ç½®ä¸ºnil(mä¸åœ¨è¿è¡Œè¿™ä¸ªå½“å‰å†™åç¨‹ï¼Œåç¨‹å°±æŒ‚èµ·äº†) setMNoWB(\u0026amp;_g_.m.curg.m, nil) setGNoWB(\u0026amp;_g_.m.curg, nil) } \u0026quot;\u0026quot;\u0026quot; if fn := _g_.m.waitunlockf; fn != nil { ok := fn(gp, _g_.m.waitlock) _g_.m.waitunlockf = nil _g_.m.waitlock = nil if !ok { if trace.enabled { traceGoUnpark(gp, 2) } casgstatus(gp, _Gwaiting, _Grunnable) execute(gp, true) // Schedule it back, never returns. } } schedule() // å¯»æ‰¾ä¸‹ä¸€ä¸ªG } //åœ¨Gä¸­ç”±å®šæ—¶è°ƒç”¨å›è°ƒå‡½æ•°f type timer struct { // If this timer is on a heap, which P's heap it is on. // puintptr rather than *p to match uintptr in the versions // of this struct defined in other packages. pp puintptr // Timer wakes up at when, and then at when+period, ... (period \u0026gt; 0 only) // each time calling f(arg, now) in the timer goroutine, so f must be // a well-behaved function and not block. // // when must be positive on an active timer. when int64 period int64 f func(interface{}, uintptr) arg interface{} seq uintptr // What to set the when field to in timerModifiedXX status. nextwhen int64 // The status field holds one of the values below. status uint32 } // Mark gp ready to run. // å°†ç­‰å¾…åç¨‹çŠ¶æ€ç½®ä¸ºè¿è¡Œçš„çŠ¶æ€ func ready(gp *g, traceskip int, next bool) { if trace.enabled { traceGoUnpark(gp, traceskip) } status := readgstatus(gp) // Mark runnable. _g_ := getg() //// ç¦æ­¢å½“å‰mè¢«æŠ¢å  mp := acquirem() // disable preemption because it can be holding p in a local var if status\u0026amp;^_Gscan != _Gwaiting { dumpgstatus(gp) throw(\u0026quot;bad g-\u0026gt;status in ready\u0026quot;) } // status is Gwaiting or Gscanwaiting, make Grunnable and put on runq casgstatus(gp, _Gwaiting, _Grunnable) // æŠŠåç¨‹ç­‰å¾…çš„è½¬æ€ç½®ä¸ºå¯è¿è¡ŒçŠ¶æ€ runqput(_g_.m.p.ptr(), gp, next) // æ·»åŠ åœ¨è¿è¡Œé˜Ÿåˆ—ä¸­ wakep()// å¦‚æœæ²¡æœ‰å¯æ‰§è¡Œçš„M,å°±åˆ›å»ºæ–°çš„m releasem(mp) // é‡Šæ”¾å½“å‰çš„m } å¦‚å›¾æ‰€ç¤º \r\n æ€»ç»“   gopark()æ˜¯è®©å‡ºå‡½æ•°ï¼Œç¦æ­¢å½“å‰mè¢«æŠ¢å ï¼Œåˆ¤æ–­å½“å‰çš„åç¨‹çŠ¶æ€æ˜¯å¦ä¸ºè¿è¡ŒçŠ¶æ€ã€‚ dropg()è®©å½“å‰çš„mä¸åœ¨æ‰§è¡Œå½“å‰çš„G,ä¿®æ”¹å½“å‰gçš„çŠ¶æ€ä¸ºç­‰å¾…(åç¨‹æŒ‚èµ·)ï¼Œè°ƒç”¨schedule() å¯»æ‰¾ä¸‹ä¸€ä¸ªå¯æ‰§è¡ŒG timers ç­‰å¾…çš„gä¸­æ•°æ®ç»“æ„ï¼Œå®šæ—¶è°ƒç”¨å›è°ƒå‡½æ•°fï¼Œå°†gç½®ä¸ºäº†è¿è¡ŒçŠ¶æ€ ready()å‡½æ•°æ˜¯å°†å”¤é†’ç­‰å¾…G,å°†Gçš„çŠ¶æ€æ›´æ”¹ä¸ºå¯è¿è¡ŒçŠ¶æ€ï¼Œå¹¶æ·»åŠ åœ¨è¿è¡Œçš„é˜Ÿåˆ—ä¸­mï¼Œå¦‚æœæ²¡æœ‰å¯æ‰§è¡Œçš„M,å°±åˆ›å»ºæ–°çš„m  goroutine ç›‘æ§  ä½¿ç”¨checkTimers()æ£€æŸ¥åˆ°æ—¶é—´è¿è¡Œçš„å”¤é†’g  æºç å¦‚ä¸‹ checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) { // If it's not yet time for the first timer, or the first adjusted // timer, then there is nothing to do. next := int64(atomic.Load64(\u0026amp;pp.timer0When)) nextAdj := int64(atomic.Load64(\u0026amp;pp.timerModifiedEarliest)) if next == 0 || (nextAdj != 0 \u0026amp;\u0026amp; nextAdj \u0026lt; next) { next = nextAdj } if next == 0 { // No timers to run or adjust. return now, 0, false } if now == 0 { now = nanotime() } if now \u0026lt; next { // Next timer is not ready to run, but keep going // if we would clear deleted timers. // This corresponds to the condition below where // we decide whether to call clearDeletedTimers. if pp != getg().m.p.ptr() || int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026lt;= int(atomic.Load(\u0026amp;pp.numTimers)/4) { return now, next, false } } lock(\u0026amp;pp.timersLock) if len(pp.timers) \u0026gt; 0 { adjusttimers(pp, now) for len(pp.timers) \u0026gt; 0 { // Note that runtimer may temporarily unlock // pp.timersLock. if tw := runtimer(pp, now); tw != 0 { if tw \u0026gt; 0 { pollUntil = tw } break } ran = true } } // If this is the local P, and there are a lot of deleted timers, // clear them out. We only do this for the local P to reduce // lock contention on timersLock. if pp == getg().m.p.ptr() \u0026amp;\u0026amp; int(atomic.Load(\u0026amp;pp.deletedTimers)) \u0026gt; len(pp.timers)/4 { clearDeletedTimers(pp) } unlock(\u0026amp;pp.timersLock) return now, pollUntil, ran }  åç¨‹çš„ç›‘æ§æ˜¯ç”±ä¸“é—¨çš„ç›‘æ§åç¨‹ç¨‹æ¥è¿è¡Œï¼Œç›‘æ§åç¨‹æ˜¯ç”±ä¸»åç¨‹åˆ›å»ºè€Œæ¥ ï¼Œç›‘æ§åç¨‹ä¸gpmä¸­çš„åç¨‹ä¸ä¸€æ ·ï¼Œå®ƒä¸æ˜¯ç”±gpmè¿›è¡Œè°ƒåº¦ï¼Œå½“ç„¶äº†ä¹Ÿä¸éœ€è¦P, ç›‘æ§timerï¼Œå¹¶æŒ‰éœ€è°ƒæ•´gçš„ä¼‘çœ æ—¶é—´ï¼Œå¦‚æœæ²¡æœ‰å¯æ‰§è¡Œçš„M,å°±åˆ›å»ºæ–°çš„mæ‰§è¡Œè¢«å”¤é†’çš„G, ç¡®ä¿è¢«å”¤é†’gè¢«æ‰§è¡Œã€‚ å¦‚å›¾ \r  goroutine æŠ¢å   å¯¹è¿è¡Œè¿‡é•¿çš„gè¿›è¡ŒæŠ¢å ï¼Œå³å½“gè¿è¡Œæ—¶é—´è¶…è¿‡è¿è¡Œé˜ˆå€¼çš„gå¼ºåˆ¶è®©å‡ºm è¿è¡Œæ—¶é—´æ˜¯ç”±Pçš„ç»“æ„syscalltickã€schedtickã€timer0Whenç­‰è®°å½•ã€‚ é€šè¿‡æ ˆå¢é•¿æ—¶ï¼šå½“stackguard = stackPreempt,ä¸æ‰§è¡Œæ ˆå¢é•¿ï¼Œè€Œæ˜¯æ‰§è¡Œåç¨‹è°ƒåº¦, è¿™æ ·å°±è®©åç¨‹è®©å‡ºæ ˆã€‚ è¿™ç§æŠ¢å ä¾èµ–æ ˆå¢é•¿ï¼Œæœ‰ç¼ºé™·ã€‚æ‰€ä»¥æœ‰asyncPreempté€šè¿‡ä¿¡å·æ–¹å¼è¿›è¡Œå¼‚æ­¥æŠ¢å \nå¦‚å›¾æ‰€ç¤º \r  goroutine è°ƒåº¦  è°ƒç”¨schedule()å‡½æ•°è¿›è¡Œåç¨‹çš„è°ƒåº¦  æºç å¦‚ä¸‹ï¼š func schedule() { _g_ := getg() // è·å¾—å½“å‰çš„G if _g_.m.locks != 0 { throw(\u0026quot;schedule: holding locks\u0026quot;) } // åˆ¤æ–­å½“å‰çš„Må’Œå½“å‰çš„Gæ˜¯å¦ç»‘å®š if _g_.m.lockedg != 0 { // å¦‚æœå½“å‰çš„Mç»‘å®šG,å°±é˜»å¡m(ä¼‘çœ M) stoplockedm() execute(_g_.m.lockedg.ptr(), false) // Never returns. } // We should not schedule away from a g that is executing a cgo call, // since the cgo call is using the m's g0 stack. if _g_.m.incgo { throw(\u0026quot;schedule: in cgo\u0026quot;) } top: pp := _g_.m.p.ptr() pp.preempt = false // åˆ¤æ–­Gcæ˜¯å¦åœ¨ç­‰å¾…æ‰§è¡Œ if sched.gcwaiting != 0 { //æ˜¯åœ¨ç­‰å¾…æ‰§è¡Œï¼Œå…ˆæ‰§è¡Œgcï¼Œæ‰§è¡Œå®Œåœ¨æ‰§è¡Œåç»­æ“ä½œ gcstopm() goto top } if pp.runSafePointFn != 0 { runSafePointFn() } // Sanity check: if we are spinning, the run queue should be empty. // Check this before calling checkTimers, as that might call // goready to put a ready goroutine on the local run queue. if _g_.m.spinning \u0026amp;\u0026amp; (pp.runnext != 0 || pp.runqhead != pp.runqtail) { throw(\u0026quot;schedule: spinning with local work\u0026quot;) } //æ£€æŸ¥æ˜¯å¦æœ‰è¦è¢«æ‰§è¡Œçš„Timer checkTimers(pp, 0) var gp *g var inheritTime bool // Normal goroutines will check for need to wakeP in ready, // but GCworkers and tracereaders will not, so the check must // be done here instead. // æ™®é€šçš„ goroutine ä¼šæ£€æŸ¥æ˜¯å¦éœ€è¦åœ¨å‡†å¤‡å¥½æ—¶å”¤é†’ï¼Œ // ä½† GCworkers å’Œè·Ÿè¸ªè¯»å–å™¨ä¸ä¼šï¼Œæ‰€ä»¥æ£€æŸ¥å¿…é¡» // åœ¨è¿™é‡Œå®Œæˆã€‚ tryWakeP := false if trace.enabled || trace.shutdown { gp = traceReader() if gp != nil { casgstatus(gp, _Gwaiting, _Grunnable) traceGoUnpark(gp, 0) tryWakeP = true } } if gp == nil \u0026amp;\u0026amp; gcBlackenEnabled != 0 { gp = gcController.findRunnableGCWorker(_g_.m.p.ptr()) tryWakeP = tryWakeP || gp != nil } if gp == nil { // Check the global runnable queue once in a while to ensure fairness. // Otherwise two goroutines can completely occupy the local runqueue // by constantly respawning each other. / æ¯éš”ä¸€æ®µæ—¶é—´æ£€æŸ¥ä¸€ä¸‹å…¨å±€å¯è¿è¡Œé˜Ÿåˆ—ä»¥ç¡®ä¿å…¬å¹³ã€‚ // å¦åˆ™ä¸¤ä¸ª goroutine å¯ä»¥å®Œå…¨å ç”¨æœ¬åœ°è¿è¡Œé˜Ÿåˆ— // é€šè¿‡ä¸æ–­ç›¸äº’é‡ç”Ÿã€‚ // æœ‰%61çš„æ¦‚ç‡æŠŠGä»å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­æ¬ç§»åˆ°æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—ï¼Œä¿éšœæœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ— æœ‰Gè¿è¡Œï¼Œå…¨å±€é˜Ÿåˆ—ä¹Ÿèƒ½æ”¾åœ¨æœ¬éƒ½é˜Ÿåˆ—ä¸­ if _g_.m.p.ptr().schedtick%61 == 0 \u0026amp;\u0026amp; sched.runqsize \u0026gt; 0 { lock(\u0026amp;sched.lock) gp = globrunqget(_g_.m.p.ptr(), 1) unlock(\u0026amp;sched.lock) } } if gp == nil { // æ²¡æœ‰å¾…è¿è¡Œçš„G å°±ç°åœ¨æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—æŸ¥æ‰¾ gp, inheritTime = runqget(_g_.m.p.ptr()) // We can see gp != nil here even if the M is spinning, // if checkTimers added a local goroutine via goready. } if gp == nil { // æœ¬åœ°é˜Ÿåˆ—æ²¡æœ‰ï¼Œå°±è°ƒç”¨findrunnable()ï¼Œç›´åˆ°æœ‰å¾…æ‰§è¡Œçš„gæ‰è¿”å›(å…ˆåœ¨æœ¬åœ° è¿è¡Œé˜Ÿåˆ—ï¼Œå…¨å±€é˜Ÿåˆ—ã€ç­‰å¾…çš„io, å…¶ä»–çš„P) gp, inheritTime = findrunnable() // blocks until work is available } // This thread is going to run a goroutine and is not spinning anymore, // so if it was marked as spinning we need to reset it now and potentially // start a new spinning M. if _g_.m.spinning { resetspinning() } if sched.disable.user \u0026amp;\u0026amp; !schedEnabled(gp) { // Scheduling of this goroutine is disabled. Put it on // the list of pending runnable goroutines for when we // re-enable user scheduling and look again. lock(\u0026amp;sched.lock) if schedEnabled(gp) { // Something re-enabled scheduling while we // were acquiring the lock. unlock(\u0026amp;sched.lock) } else { sched.disable.runnable.pushBack(gp) sched.disable.n++ unlock(\u0026amp;sched.lock) goto top } } // If about to schedule a not-normal goroutine (a GCworker or tracereader), // wake a P if there is one. if tryWakeP { wakep() } // åˆ¤æ–­è·å¾—çš„Gæœ‰æ²¡æœ‰ç»‘å®šçš„M,æœ‰å°±é˜»å¡g, å†æ¬¡è¿›è¡Œè°ƒåº¦ if gp.lockedm != 0 { // Hands off own p to the locked m, // then blocks waiting for a new p. startlockedm(gp) goto top } // ä½¿ç”¨executeå‡½æ•°è®©mæ‰§è¡Œg execute(gp, inheritTime) } å¦‚å›¾æ‰€ç¤º \r\n æ€»ç»“   åˆ¤æ–­å½“å‰çš„Må’Œå½“å‰çš„Gæ˜¯å¦ç»‘å®šï¼Œå¦‚æœå½“å‰çš„Mç»‘å®šG,å°±é˜»å¡m(ä¼‘çœ M) åˆ¤æ–­Gcæ˜¯å¦åœ¨ç­‰å¾…æ‰§è¡Œï¼Œæ˜¯åœ¨ç­‰å¾…æ‰§è¡Œï¼Œå…ˆæ‰§è¡Œgcï¼Œæ‰§è¡Œå®Œåœ¨æ‰§è¡Œåç»­æ“ä½œ æ£€æŸ¥æ˜¯å¦æœ‰è¦è¢«æ‰§è¡Œçš„Timer æ™®é€šçš„ goroutine ä¼šæ£€æŸ¥æ˜¯å¦éœ€è¦åœ¨å‡†å¤‡å¥½æ—¶å”¤é†’ï¼Œä½† GCworkers å’Œè·Ÿè¸ªè¯»å–å™¨ä¸ä¼šï¼Œæ‰€ä»¥æ£€æŸ¥å¿…é¡» æœ‰%61çš„æ¦‚ç‡æŠŠGä»å…¨å±€è¿è¡Œé˜Ÿåˆ—ä¸­æ¬ç§»åˆ°æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—ï¼Œä¿éšœæœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—æœ‰Gè¿è¡Œï¼Œå…¨å±€é˜Ÿåˆ—ä¹Ÿèƒ½æ”¾åœ¨æœ¬éƒ½é˜Ÿåˆ—ä¸­ æ²¡æœ‰å¾…è¿è¡Œçš„Gå°±ç°åœ¨æœ¬åœ°å¯è¿è¡Œé˜Ÿåˆ—æŸ¥æ‰¾ï¼Œæœ¬åœ°é˜Ÿåˆ—æ²¡æœ‰ï¼Œå°±è°ƒç”¨findrunnable()ï¼Œç›´åˆ°æœ‰å¾…æ‰§è¡Œçš„gæ‰è¿”å›(å…ˆåœ¨æœ¬åœ° è¿è¡Œé˜Ÿåˆ—ï¼Œå…¨å±€é˜Ÿåˆ—ã€ç­‰å¾…çš„io, å…¶ä»–çš„Pä¸­åˆ†é…G) åˆ¤æ–­è·å¾—çš„Gæœ‰æ²¡æœ‰ç»‘å®šçš„M,æœ‰å°±é˜»å¡g, å†æ¬¡è¿›è¡Œè°ƒåº¦ ä½¿ç”¨executeå‡½æ•°è®©mæ‰§è¡Œg,å¾…è¿è¡Œgç»‘å®šm,è°ƒç”¨gogo(\u0026amp;gp.sched)åç¨‹çš„ç°åœºæ¢å¤ç­‰  è°ƒåº¦å™¨çš„è®¾è®¡ç­–ç•¥  å‡å°‘çº¿ç¨‹çš„åˆ›å»ºä¸é”€æ¯cupçš„å¼€é”€ï¼ŒGPMæ˜¯çº¿ç¨‹çš„å¤ç”¨ã€‚å³å½“æ²¡æœ‰ å¯è¿è¡Œçš„Gæ—¶ï¼Œå°†Mä¼‘çœ ,Pç©ºé—²ã€‚å½“æœ‰å¯æ‰§è¡ŒGæ˜¯æ‰¾ç©ºé—²çš„Pï¼Œåœ¨å°†Må”¤é†’ï¼Œæ‰§è¡ŒGï¼Œç›´åˆ° main.main é€€å‡ºï¼Œruntime.main æ‰§è¡Œ Defer å’Œ Panic å¤„ç†ï¼Œæˆ–è°ƒç”¨ runtime.exit é€€å‡ºç¨‹åº work stealing æœºåˆ¶ï¼šå½“æœ¬çº¿ç¨‹æ— å¯è¿è¡Œçš„ G æ—¶ï¼Œå°è¯•ä»å…¶ä»–çº¿ç¨‹ç»‘å®šçš„ P å·å– Gï¼Œè€Œä¸æ˜¯é”€æ¯çº¿ç¨‹ã€‚ hand off æœºåˆ¶ï¼š\n1.å½“æœ¬çº¿ç¨‹å› ä¸º G è¿›è¡Œç³»ç»Ÿè°ƒç”¨é˜»å¡æ—¶ï¼Œçº¿ç¨‹é‡Šæ”¾ç»‘å®šçš„ Pï¼ŒæŠŠ P è½¬ç§»ç»™å…¶ä»–ç©ºé—²çš„çº¿ç¨‹æ‰§è¡Œã€‚\n2.åˆ©ç”¨å¹¶è¡Œï¼šGOMAXPROCS è®¾ç½® P çš„æ•°é‡ï¼Œæœ€å¤šæœ‰ GOMAXPROCS ä¸ªçº¿ç¨‹åˆ†å¸ƒåœ¨å¤šä¸ª CPU ä¸ŠåŒæ—¶è¿è¡Œã€‚GOMAXPROCS ä¹Ÿé™åˆ¶äº†å¹¶å‘çš„ç¨‹åº¦ï¼Œæ¯”å¦‚ GOMAXPROCS = æ ¸æ•°/2ï¼Œåˆ™æœ€å¤šåˆ©ç”¨äº†ä¸€åŠçš„ CPU æ ¸è¿›è¡Œå¹¶è¡Œã€‚ 3.æŠ¢å ï¼šåœ¨ coroutine ä¸­è¦ç­‰å¾…ä¸€ä¸ªåç¨‹ä¸»åŠ¨è®©å‡º CPU æ‰æ‰§è¡Œä¸‹ä¸€ä¸ªåç¨‹ï¼Œåœ¨ Go ä¸­ï¼Œä¸€ä¸ª goroutine æœ€å¤šå ç”¨ CPU 10msï¼Œé˜²æ­¢å…¶ä»– goroutine è¢«é¥¿æ­»ï¼Œè¿™å°±æ˜¯ goroutine ä¸åŒäº coroutine çš„ä¸€ä¸ªåœ°æ–¹ã€‚\n4.å…¨å±€ G é˜Ÿåˆ—ï¼šåœ¨æ–°çš„è°ƒåº¦å™¨ä¸­ä¾ç„¶æœ‰å…¨å±€ G é˜Ÿåˆ—ï¼Œä½†åŠŸèƒ½å·²ç»è¢«å¼±åŒ–äº†ï¼Œå½“ M æ‰§è¡Œ work stealing ä»å…¶ä»– P å·ä¸åˆ° G æ—¶ï¼Œå®ƒå¯ä»¥ä»å…¨å±€ G é˜Ÿåˆ—è·å– Gã€‚ è°ƒåº¦å¦‚å›¾æ‰€ç¤º\n\r  å‚è€ƒæ–‡çŒ® 1ã€https://www.jianshu.com/p/fa696563c38a 2.https://www.zhihu.com/people/kylin-lab\n","date":"2021-10-06T22:00:38+08:00","image":"https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1_huda718813a1636432ee91da972c85e460_240629_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","title":"go goroutineä¸gmpæ¨¡å‹çš„æ·±å…¥ç†è§£"},{"content":"ç†è§£è¿›ç¨‹ä¸çº¿ç¨‹ è¿›ç¨‹  è¿›ç¨‹æ˜¯ç¨‹åºä¸€æ¬¡åŠ¨æ€æ‰§è¡Œè¿‡ç¨‹ã€è¿›ç¨‹æ˜¯æ“ä½œç³»ç»Ÿåˆ†é…èµ„æº(å†…å­˜ã€ioèµ„æºã€cpuç­‰)å’Œèµ„æºè°ƒåº¦çš„åŸºæœ¬å•ä½ã€‚ç¨‹åºæ˜¯æŒ‡ä»¤ã€æ•°æ®åŠå…¶ç»„ç»‡å½¢å¼çš„æè¿°ï¼Œè¿›ç¨‹æ˜¯ç¨‹åºçš„å®ä½“ã€‚ è¿›ç¨‹æ˜¯ç”± è¿›ç¨‹æ§åˆ¶å—PCBã€ç›¸å…³ç¨‹åºæ®µå’Œè¯¥ç¨‹åºæ®µè¿›è¡Œæ“ä½œçš„æ•°æ®ç»“æ„é›†ä¸‰ä¸ªéƒ¨åˆ†ç»„æˆã€‚ è¿›ç¨‹çš„äº”ä¸­çŠ¶æ€ï¼šåˆ›å»ºã€å°±ç»ªã€è¿è¡Œã€é˜»å¡ã€ç»ˆæ­¢ äº”ç§çŠ¶æ€è½¬æ¢å¦‚å›¾æ‰€ç¤ºï¼š \r  çº¿ç¨‹  çº¿ç¨‹æ˜¯cupè°ƒåº¦å’Œåˆ†é…çš„åŸºæœ¬å•ä½ä¹Ÿæ˜¯cupæ‰§è¡Œçš„æœ€å°å•ä½, æœ‰ç‹¬ç«‹çš„æ ˆç©ºé—´ï¼Œå…±äº«å †ç©ºé—´ã€‚  è¿›ç¨‹ä¸çº¿ç¨‹çš„å…³ç³»  ä¸€ä¸ªè¿›ç¨‹å¯ä»¥åˆ›å»ºå’Œæ’¤é”€å¤šä¸ªçº¿ç¨‹ï¼Œ ä¸€ä¸ªè¿›ç¨‹å¿…é¡»æœ‰ä¸€ä¸ªçº¿ç¨‹(ä¸»çº¿ç¨‹), çº¿ç¨‹å…±äº«è¿›ç¨‹æ‰€æœ‰èµ„æºï¼Œè¿›ç¨‹æ˜¯çº¿ç¨‹çš„å®¹å™¨ï¼Œå…³ç³»å¦‚å›¾æ‰€ç¤ºï¼š\n\r  å¹¶å‘ä¸å¹¶è¡Œ å¹¶å‘  å¹¶å‘ï¼šå¤šè¿›ç¨‹(çº¿ç¨‹)ç¨‹åºåœ¨ä¸€ä¸ªæ ¸cupä¸²è¡Œè¿è¡Œï¼Œå½“ä¸€ä¸ªè¿›ç¨‹(çº¿ç¨‹)é˜»å¡çš„æ—¶å€™ï¼Œåˆ‡æ¢åˆ°å¦å¤–ç­‰å¾…æ‰§è¡Œçš„è¿›ç¨‹(çº¿ç¨‹) å¦‚å›¾\n\r  å¹¶è¡Œ  å¹¶è¡Œï¼šå¤šçº¿ç¨‹ç¨‹åºåœ¨å¤šæ ¸cupå¹¶è¡Œè¿è¡Œï¼Œå¦‚å›¾\n\r  ç”¨æˆ·æ€å’Œå†…æ ¸æ€(ç”¨æˆ·ç©ºé—´å’Œå†…æ ¸ç©ºé—´) ç‰¹æƒçº§åˆ’åˆ†  cpuä¸€å…±æœ‰0ï½4å››ä¸ªç‰¹æƒçº§ï¼ŒR0çº§æœ€é«˜ï¼ŒR3çº§æœ€ä½ã€‚ç”¨æˆ·æ€æŒ‡çš„æ˜¯ï¼šç¨‹åºè¿è¡Œåœ¨R3çº§ä»¥ä¸Šï¼Œé€šå¸¸åœ¨åº”ç”¨ç¨‹åºä¸­è¿è¡Œï¼Œå†…æ ¸æ€æ˜¯æŒ‡ï¼šç¨‹åºè¿è¡Œåœ¨R0çº§ä»¥ä¸Šï¼Œé€šå¸¸åœ¨å†…æ ¸ä¸­è¿è¡Œã€‚ä¸€èˆ¬æ¥è¯´ï¼Œæˆ‘ä»¬å†™çš„åº”ç”¨ç¨‹åºå°±æ˜¯è¿è¡Œåœ¨R3çº§è¡£ä»¥ä¸Šã€‚  3ä¸­ç§ç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„åˆ‡æ¢   ç³»ç»Ÿè°ƒç”¨ï¼šç”¨æˆ·æ€è¿›ç¨‹é€šè¿‡ç³»ç»Ÿè°ƒç”¨ç”³è¯·ä½¿ç”¨æ“ä½œç³»ç»Ÿæä¾›çš„æœåŠ¡ç¨‹åºå®Œæˆå·¥ä½œï¼Œæ¯”å¦‚å‰ä¾‹ä¸­fork()å®é™…ä¸Šå°±æ˜¯æ‰§è¡Œäº†ä¸€ä¸ªåˆ›å»ºæ–°è¿›ç¨‹çš„ç³»ç»Ÿè°ƒç”¨ã€‚è€Œç³»ç»Ÿè°ƒç”¨çš„æœºåˆ¶å…¶æ ¸å¿ƒè¿˜æ˜¯ä½¿ç”¨äº†æ“ä½œç³»ç»Ÿä¸ºç”¨æˆ·ç‰¹åˆ«å¼€æ”¾çš„ä¸€ä¸ªä¸­æ–­æ¥å®ç°ï¼Œä¾‹å¦‚Linuxçš„int 80hä¸­æ–­ã€‚\n  å¼‚å¸¸ï¼šå½“CPUåœ¨æ‰§è¡Œè¿è¡Œåœ¨ç”¨æˆ·æ€ä¸‹çš„ç¨‹åºæ—¶ï¼Œå‘ç”Ÿäº†æŸäº›äº‹å…ˆä¸å¯çŸ¥çš„å¼‚å¸¸ï¼Œè¿™æ—¶ä¼šè§¦å‘ç”±å½“å‰è¿è¡Œè¿›ç¨‹åˆ‡æ¢åˆ°å¤„ç†æ­¤å¼‚å¸¸çš„å†…æ ¸ç›¸å…³ç¨‹åºä¸­ï¼Œä¹Ÿå°±è½¬åˆ°äº†å†…æ ¸æ€ï¼Œæ¯”å¦‚ç¼ºé¡µå¼‚å¸¸ã€‚\n  å¤–å›´è®¾å¤‡çš„ä¸­æ–­ï¼š å½“å¤–å›´è®¾å¤‡å®Œæˆç”¨æˆ·è¯·æ±‚çš„æ“ä½œåï¼Œä¼šå‘CPUå‘å‡ºç›¸åº”çš„ä¸­æ–­ä¿¡å·ï¼Œè¿™æ—¶CPUä¼šæš‚åœæ‰§è¡Œä¸‹ä¸€æ¡å³å°†è¦æ‰§è¡Œçš„æŒ‡ä»¤è½¬è€Œå»æ‰§è¡Œä¸ä¸­æ–­ä¿¡å·å¯¹åº”çš„å¤„ç†ç¨‹åºï¼Œå¦‚æœå…ˆå‰æ‰§è¡Œçš„æŒ‡ä»¤æ˜¯ç”¨æˆ·æ€ä¸‹çš„ç¨‹åºï¼Œé‚£ä¹ˆè¿™ä¸ªè½¬æ¢çš„è¿‡ç¨‹è‡ªç„¶ä¹Ÿå°±å‘ç”Ÿäº†ç”±ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„åˆ‡æ¢ã€‚æ¯”å¦‚ç¡¬ç›˜è¯»å†™æ“ä½œçš„å®Œæˆï¼Œç³»ç»Ÿä¼šåˆ‡æ¢åˆ°ç¡¬ç›˜è¯»å†™çš„ä¸­æ–­å¤„ç†ç¨‹åºä¸­æ‰§è¡Œåç»­æ“ä½œç­‰ã€‚\n  ç”¨æˆ·æ€ä¸å†…æ ¸æ€ç»“æ„å¦‚å›¾ï¼š\n\r\n  ç”¨æˆ·æ€ä¸å†…æ ¸æ€çš„åˆ‡æ¢æ˜¯éœ€è¦å¼€é”€\n  æ¥æºï¼šlinuxç”¨æˆ·æ€å’Œå†…æ ¸æ€ç†è§£(https://www.cnblogs.com/weifeng1463/p/11660260.html)\n  è¿›ç¨‹ä¸çº¿ç¨‹ç”¨æˆ·æ€åˆ°å†…æ ¸æ€çš„å¼€é”€   å¤šè¿›ç¨‹(çº¿ç¨‹)å¯ä»¥æé«˜cpuçš„åˆ©ç”¨ç‡ï¼Œå‡å°‘ç¨‹åºé˜»å¡å¸¦æ¥cpué—²ç½®çš„æƒ…å†µï¼Œä¹Ÿå°±æ˜¯æå‡cpuçš„è¿è¡Œæ—¶é—´ç‰‡ï¼Œä½†æ˜¯è¿‡å¤šçš„åˆ›å»ºè¿›ç¨‹(çº¿ç¨‹)ä¹Ÿä¼šèŠ±è´¹é¢å¤–çš„cpuæ—¶é—´ç‰‡è¿›è¡Œè¿›ç¨‹(çº¿ç¨‹)çš„èŠ±é”€ã€‚è¿›ç¨‹çš„åˆ›å»ºã€å°±ç»ªã€è¿è¡Œã€é˜»å¡ã€ç»ˆæ­¢ï¼Œè¿™äº›éƒ½ä¼šå¸¦æ¥cupèŠ±é”€ã€‚ä¾‹å¦‚åœ¨32ä½çš„æ“ä½œç³»ç»Ÿä¸­åˆ›å»ºä¸€ä¸ªè¿›ç¨‹éœ€è¦å¼€è¾Ÿ4GBçš„è™šæ‹Ÿå†…å­˜ç©ºé—´ï¼Œåˆ›å»ºä¸€ä¸ªçº¿ç¨‹éœ€è¦å ç”¨çº¦4MBçš„å†…å­˜ã€‚\n\r\n  è¿›ç¨‹(çº¿ç¨‹)çš„è°ƒåº¦ä¹Ÿä¼šå¸¦æ¥cupçš„èŠ±é”€ã€‚cupè¿›ç¨‹(çº¿ç¨‹)çš„è°ƒåº¦å°±æ˜¯è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢ï¼Œè¿›ç¨‹(çº¿ç¨‹)çš„åˆ‡æ¢å°±ä¼šè¿›è¡Œçº¿ç¨‹åœ¨å†…æ ¸æ€çš„è°ƒåº¦ã€‚cupåˆ‡æ¢çš„å†…æ ¸æ€çš„çº¿ç¨‹ï¼Œä¸æ“ä½œç”¨æˆ·æ€çš„çº¿ç¨‹ï¼Œç”¨æˆ·æ€çº¿ç¨‹é€šè¿‡ç³»ç»Ÿè°ƒç”¨è§¦å‘å†…æ ¸çº¿ç¨‹ã€‚\n  ä¸ºå‡å°‘cpuå†…æ ¸æ€çº¿ç¨‹ä¹‹é—´çš„åˆ‡æ¢ï¼Œæ“ä½œç³»ç»Ÿä¸­ä½¿ç”¨(ç”¨æˆ·æ€è¿›ç¨‹(çº¿ç¨‹):å†…æ ¸æ€è¿›ç¨‹(çº¿ç¨‹))1:1ï¼Œç”¨æˆ·æ€ç›´æ¥é€šè¿‡ç³»ç»Ÿï¼Œç›´æ¥ä¸å†…æ ¸æ€çš„çº¿ç¨‹ä¸€ä¸€å¯¹åº”ã€‚å¦‚å›¾\n\r\n  ç”¨æˆ·æ€ä¸€ä¸ªè¿›ç¨‹(çº¿ç¨‹)å¯¹åº”ä¸€ä¸ªå†…æ ¸æ€çš„è¿›ç¨‹(çº¿ç¨‹)æ˜¯å‡å°‘äº†å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢çš„èŠ±é”€ï¼Œä½†æ˜¯ä¹Ÿå¢åŠ äº†å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ›å»ºçš„å¼€é”€ã€‚å‡å°‘å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢ä¸åˆ›å»ºå¸¦æ¥çš„å¼€é”€ï¼Œæ“ä½œç³»ç»Ÿä¸­ä½¿ç”¨(ç”¨æˆ·æ€è¿›ç¨‹(çº¿ç¨‹):å†…æ ¸æ€è¿›ç¨‹(çº¿ç¨‹))N:1ï¼Œå‡å°‘å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)çš„åˆ›å»ºï¼ŒåŒæ—¶åœ¨ç”¨æˆ·æ€è¿›è¡Œçº¿ç¨‹çš„ä¹‹é—´çš„åˆ‡æ¢ï¼Œä¸ç‰µè¿å†…æ ¸æ€çº¿ç¨‹çš„åˆ‡æ¢ï¼Œå‡å°‘cupçš„èŠ±é”€ã€‚ \r\n  è™½ç„¶N:1å‡å°‘å†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢ä¸åˆ›å»ºå¸¦æ¥çš„å¼€é”€ï¼Œä½†æ˜¯å½“ç”¨æˆ·æ€çš„è¿›ç¨‹(çº¿ç¨‹)é˜»å¡æ—¶ï¼Œå…¶ä»–è¿›ç¨‹(çº¿ç¨‹)å°±åªèƒ½ç­‰å¾…ï¼Œè¿™é€ æˆä¸å•çº¿ç¨‹ä¸€æ ·çš„é—®é¢˜ã€‚æ“ä½œç³»ç»Ÿç»“åˆ1:1å’Œn:1æ¨¡å‹çš„æœ‰ç‚¹å½¢æˆn:mæ¨¡å‹ï¼Œå†…æ ¸æ€ä¸­è¿›ç¨‹(çº¿ç¨‹)è¿›å…¥é˜»å¡çŠ¶æ€æ—¶ï¼Œ ç”¨æˆ·æ€çš„è¿›ç¨‹(çº¿ç¨‹)åˆ‡æ¢å¦ä¸€ä¸ªå†…æ ¸æ€ä¸­çš„çº¿ç¨‹ã€‚\n\r\n  åç¨‹  åç¨‹å’Œçº¿ç¨‹ä¸€æ ·æœ‰ç‹¬ç«‹çš„æ ˆç©ºé—´ï¼Œå…±äº«å †ç©ºé—´ï¼Œæ˜¯ç”¨æˆ·çº§çš„çº¿ç¨‹ï¼Œæ˜¯æœ‰ç”¨æˆ·è‡ªå·±è°ƒåº¦ã€‚ä¸€ä¸ªçº¿ç¨‹å¯ä»¥åˆ›å»ºå¤šä¸ªåç¨‹ï¼Œåç¨‹æ˜¯è½»é‡çº§çš„çº¿ç¨‹ã€‚åˆ›å»ºä¸€ä¸ªåç¨‹åªéœ€è¦å ç”¨4~5kBçš„è™šæ‹Ÿå†…å­˜ï¼Œåˆ›å»ºåç¨‹çš„å¼€é”€ç›¸æ¯”è¿›ç¨‹ä¸çº¿ç¨‹ä½å¤ªå¤šäº†ã€‚\n\r  å‚è€ƒæ–‡çŒ® 1ã€https://zhuanlan.zhihu.com/p/337978321 2ã€https://www.jianshu.com/p/fa696563c38a\n","date":"2021-09-28T22:00:38+08:00","image":"https://zcj-git520.github.io/p/c/c/10_hu5bb3a4baa791897c79c1df91e792ef0e_243913_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/c/c-/","title":"è¿›ç¨‹ã€çº¿ç¨‹ã€åç¨‹"},{"content":"goland åŸºç¡€ä¹‹map mapçš„å†…éƒ¨ç»“æ„  go mapæ˜¯ä½¿ç”¨çš„å“ˆå¸Œè¡¨æ„å»ºçš„ mapçš„ç»“æ„å¯åˆ†ä¸ºï¼šhmapçš„ç»“æ„ä½“å’Œbmap(æ¡¶)ï¼Œhmapç»“æ„ä½“è®°å½•è¿™mapçš„åŸºç¡€ä¿¡æ¯(åŒ…æ‹¬mapå­˜å‚¨ä¸ªæ•°ï¼Œ æ¡¶çš„ä¸ªæ•°ï¼Œhashç§å­ï¼Œæ¡¶çš„æ•°æ®ï¼Œæ‰©å®¹æ—¶æ—§æ¡¶çš„æ•°æ®ä»¥åŠè¿ç§»ä¸ªæ•°ï¼ˆmapæ‰©å®¹ä¸æ˜¯ä¸€æ¬¡æ€§è¿ç§»å®Œï¼‰) æºç å¦‚ä¸‹    å®šä¹‰hmapçš„ç»“æ„ï¼š type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler's definition. // map å­˜å‚¨å…ƒç´ çš„è®¡æ•° count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 // mapçš„çŠ¶æ€æ ‡è¯†ï¼Œæ¡¶æ˜¯å¦åœ¨å¢æ”¹ï¼Œæ‰©å®¹æˆ–è€…ç¼©å®¹ //æ¡¶çš„ä¸ªæ•°/é‡‡ç”¨çš„ä¸è¿ç®—æ³•è®¡ç®—æ¡¶çš„ä¸ªæ•°ï¼Œæ¡¶çš„ä¸ªæ•°ä¸º2çš„æ•´æ•°æ¬¡å¹‚ B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) //æº¢å‡ºçš„æ¡¶çš„æ•°é‡çš„è¿‘ä¼¼å€¼ noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed //æŒ‡å‘æ¡¶æ•°æ®çš„æŒ‡é’ˆ buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0. // æŒ‡å‘æ—§æ¡¶æ•°æ®çš„æŒ‡é’ˆ oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing //æ‰©å®¹è®¡æ•° nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated) // ä¿å­˜æº¢å‡ºæ¡¶çš„é“¾è¡¨å’Œæœªä½¿ç”¨çš„æº¢å‡ºæ¡¶æ•°ç»„çš„é¦–åœ°å€ extra *mapextra // optional fields } // æ¡¶çš„å®ç°ç»“æ„ type bmap struct { // å½“å‰ç‰ˆæœ¬bucketCntçš„å€¼æ˜¯8ï¼Œä¸€ä¸ªæ¡¶æœ€å¤šå­˜å‚¨8ä¸ªkey-valueå¯¹ tophash [bucketCnt]uint8 }  bmapå­˜å‚¨ç»“æ„å¦‚å›¾æ‰€ç¤º\n\r å‰8ä¸ªæ˜¯hashå€¼ï¼Œ8ä¸ªkeyå’Œ8ä¸ªvalueã€åé¢æ˜¯æº¢å‡ºæ¡¶çš„æŒ‡é’ˆ æº¢å‡ºæ¡¶æ˜¯å‡å°‘mapæ‰©å®¹æ¬¡æ•°ï¼Œæº¢å‡ºæ¡¶çš„ç»“æ„ä¸bmapæ¡¶çš„ç»“æ„ä¸€æ ·çš„ æº¢å‡ºæ¡¶çš„åŸºç¡€ç»“æ„ï¼š    type mapextra struct { // If both key and elem do not contain pointers and are inline, then we mark bucket // type as containing no pointers. This avoids scanning such maps. // However, bmap.overflow is a pointer. In order to keep overflow buckets // alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow. // overflow and oldoverflow are only used if key and elem do not contain pointers. // overflow contains overflow buckets for hmap.buckets. // oldoverflow contains overflow buckets for hmap.oldbuckets. // The indirection allows to store a pointer to the slice in hiter. overflow *[]*bmap //è®°å½•å·²ç»è¢«ä½¿ç”¨çš„æº¢å‡ºæ¡¶ oldoverflow *[]*bmap // æ‰©å®¹é˜¶æ®µæ—§çš„æº¢å‡ºæ¡¶ // nextOverflow holds a pointer to a free overflow bucket. nextOverflow *bmap //æŒ‡å‘ä¸‹ä¸€ä¸ªç©ºé—²çš„æº¢å‡ºæ¡¶ }  å½“æ¡¶çš„ä¸ªæ•°å¤§äº2çš„4æ¬¡æ–¹æ—¶å°±ä¼šä½¿ç”¨æº¢å‡ºæ¡¶æºç å¦‚ä¸‹  func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) { // æ¡¶çš„ä¸ªæ•° base := bucketShift(b) nbuckets := base // For small b, overflow buckets are unlikely. // Avoid the overhead of the calculation. if b \u0026gt;= 4 { // ä½¿ç”¨æº¢å‡ºæ¡¶ // Add on the estimated number of overflow buckets // required to insert the median number of elements // used with this value of b. nbuckets += bucketShift(b - 4)//è®¡ç®—æº¢å‡ºæ¡¶çš„æ•°é‡å’Œä¸æ˜¯æº¢å‡ºæ¡¶çš„æ•°é‡çš„å’Œ sz := t.bucket.size * nbuckets up := roundupsize(sz) if up != sz { nbuckets = up / t.bucket.size //å¾—å‡ºæ¡¶çš„æ•°é‡ } } if dirtyalloc == nil { // æ²¡æœ‰è¢«åˆ›å»ºæ¡¶ï¼Œç”³è¯·åˆ›å»ºæ¡¶çš„ï¼Œè¿”å›æ¡¶çš„é¦–åœ°å€ buckets = newarray(t.bucket, int(nbuckets)) } else { // dirtyalloc was previously generated by // the above newarray(t.bucket, int(nbuckets)) // but may not be empty. buckets = dirtyalloc size := t.bucket.size * nbuckets if t.bucket.ptrdata != 0 { memclrHasPointers(buckets, size) } else { memclrNoHeapPointers(buckets, size) } } if base != nbuckets { // We preallocated some overflow buckets. // To keep the overhead of tracking these overflow buckets to a minimum, // we use the convention that if a preallocated overflow bucket's overflow // pointer is nil, then there are more available by bumping the pointer. // We need a safe non-nil pointer for the last overflow bucket; just use buckets. //ç©ºé—²æ¡¶çš„åœ°å€ nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize))) last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize))) last.setoverflow(t, (*bmap)(buckets)) } return buckets, nextOverflow }  å¦‚å›¾æ‰€ç¤º\n\r ä½¿ç”¨mapæ—¶éœ€è¦make(map[type]type,len,cap)æ‰èƒ½ä½¿ç”¨ã€‚ make æºç å¦‚ä¸‹ï¼š    func makemap(t *maptype, hint int, h *hmap) *hmap { // åˆ¤æ–­æ˜¯å¦è¶…è¿‡å†…å­˜çš„é™åˆ¶ mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size) if overflow || mem \u0026gt; maxAlloc { hint = 0 } // initialize Hmap if h == nil { h = new(hmap) } h.hash0 = fastrand()// è·å–éšæœºçš„hashå€¼ // Find the size parameter B which will hold the requested # of elements. // For hint \u0026lt; 0 overLoadFactor returns false since hint \u0026lt; bucketCnt. B := uint8(0) for overLoadFactor(hint, B) { B++ } h.B = B // allocate initial hash table // if B == 0, the buckets field is allocated lazily later (in mapassign) // If hint is large zeroing this memory could take a while. if h.B != 0 { var nextOverflow *bmap // åˆ›å»ºmapçš„å­˜å‚¨æ•°æ®ï¼Œè¿”å›çš„æ¡¶çš„æ•°æ®çš„åœ°å€ï¼Œä¸‹ä¸€ä¸ªæº¢å‡ºæ¡¶çš„åœ°å€ h.buckets, nextOverflow = makeBucketArray(t, h.B, nil) if nextOverflow != nil { h.extra = new(mapextra) h.extra.nextOverflow = nextOverflow } } return h }   mapçš„å®Œæ•´ç»“æ„å¦‚å›¾ï¼š \r\nmapæ‰©å®¹ æ‰©å®¹æ¡ä»¶     å½“è´Ÿè½½å› å­(loadFactorNum*(bucketShift(B)/loadFactorDen\u0026gt;6.5 -\u0026gt; ç¿»å€æ‰©å®¹\n  å½“è´Ÿè½½å› å­å°äº6.5ï¼Œä½†æ˜¯æº¢å‡ºæ¡¶çš„æ•°é‡å¤§äº2çš„15æ¬¡æ–¹ -\u0026gt; ç­‰é‡æ‰©å®¹\n  æºä»£ç å¦‚ä¸‹ï¼š\n    // overLoadFactor reports whether count items placed in 1\u0026lt;\u0026lt;B buckets is over loadFactor. // è´Ÿè½½å› å­å¤§äº6.5 func overLoadFactor(count int, B uint8) bool { return count \u0026gt; bucketCnt \u0026amp;\u0026amp; uintptr(count) \u0026gt; loadFactorNum*(bucketShift(B)/loadFactorDen) } // æº¢å‡ºæ¡¶è¿‡å¤šæ—¶ func tooManyOverflowBuckets(noverflow uint16, B uint8) bool { // If the threshold is too low, we do extraneous work. // If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory. // \u0026quot;too many\u0026quot; means (approximately) as many overflow buckets as regular buckets. // See incrnoverflow for more details. if B \u0026gt; 15 { B = 15 } // The compiler doesn't see here that B \u0026lt; 16; mask B to generate shorter shift code. return noverflow \u0026gt;= uint16(1)\u0026lt;\u0026lt;(B\u0026amp;15) } // æ‰©å®¹æºç  func hashGrow(t *maptype, h *hmap) { // If we've hit the load factor, get bigger. // Otherwise, there are too many overflow buckets, // so keep the same number of buckets and \u0026quot;grow\u0026quot; laterally. bigger := uint8(1) if !overLoadFactor(h.count+1, h.B) { //ç­‰é‡æ‰©å®¹ bigger = 0 h.flags |= sameSizeGrow } oldbuckets := h.buckets newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)// ä»æ–°åˆ†é…æ•°æ®åœ°å€ flags := h.flags \u0026amp;^ (iterator | oldIterator) if h.flags\u0026amp;iterator != 0 { // è¿­ä»£çš„æ—¶å€™æ¬è¿æ—§æ¡¶ flags |= oldIterator } // commit the grow (atomic wrt gc) h.B += bigger // æ¡¶çš„ä¸ªæ•° h.flags = flags h.oldbuckets = oldbuckets h.buckets = newbuckets h.nevacuate = 0 h.noverflow = 0 // æº¢å‡ºæ¡¶é’»ä¾¿ä¸ºæ—§æº¢å‡ºæ¡¶ if h.extra != nil \u0026amp;\u0026amp; h.extra.overflow != nil { // Promote current overflow buckets to the old generation. if h.extra.oldoverflow != nil { throw(\u0026quot;oldoverflow is not nil\u0026quot;) } h.extra.oldoverflow = h.extra.overflow h.extra.overflow = nil } if nextOverflow != nil { if h.extra == nil { h.extra = new(mapextra) } h.extra.nextOverflow = nextOverflow } // the actual copying of the hash table data is done incrementally // by growWork() and evacuate(). } å‚è€ƒæ–‡çŒ® 1.https://www.zhihu.com/people/kylin-lab\n","date":"2021-09-20T22:00:38+08:00","image":"https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_hu50c7ad8b87ebb1655f26b2166388bb8a_150234_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","title":"go mapçš„æ·±å…¥ç†è§£"},{"content":"æœåŠ¡å™¨é…ç½®(æœåŠ¡å™¨å¹³å°ï¼šx86) Rsyslogç®€ä»‹  Rsyslogæ˜¯ä¸€ä¸ª syslogd çš„å¤šçº¿ç¨‹å¢å¼ºç‰ˆï¼Œåœ¨syslogçš„åŸºç¡€ä¸Šæ‰©å±•äº†å¾ˆå¤šå…¶ä»–åŠŸèƒ½ï¼Œå¦‚æ•°æ®åº“æ”¯æŒ(MySQL, PostgreSQLã€Oracleç­‰)ã€æ—¥å¿—å†…å®¹ç­›é€‰ã€å®šä¹‰æ—¥å¿—æ ¼å¼æ¨¡æ¿ç­‰ã€‚é™¤äº†é»˜è®¤çš„udpåè®®å¤–ï¼Œrsyslogè¿˜æ”¯æŒtcpåè®®æ¥æ¥æ”¶æ—¥å¿—ã€‚ ç›®å‰çš„linuxçš„å‘è¡Œç‰ˆéƒ½åˆ‡æ¢ä¸ºrsyslog  å®‰è£…Rsyslog  Linuxçš„å‘è¡Œç‰ˆä¸­é¢„å…ˆå®‰è£…äº†Rsyslog,æ— éœ€å®‰è£…ï¼Œrsyslogd â€“v æŸ¥çœ‹ç‰ˆæœ¬ è‹¥æœªå®‰è£…ï¼Œä»¥ä¸‹æ˜¯å®‰è£…æ­¥éª¤ï¼š 1.ubuntuï¼šsudo apt install rsyslog 2.CentOSï¼šyum install rsyslog  Rsyslog.confé…ç½®æ–‡ä»¶è¯¦è§£ é…ç½®æ–‡ä»¶ä½ç½®ï¼š/etc/rsyslog.conf #### MODULES #### #å®šä¹‰æ—¥å¿—çš„æ¨¡å—ã€‚ $ModLoad imuxsock #imuxsockä¸ºæ¨¡å—åï¼Œæ”¯æŒæœ¬åœ°ç³»ç»Ÿæ—¥å¿—çš„æ¨¡å—ã€‚ $ModLoad imjournal #imjournalä¸ºæ¨¡å—åï¼Œæ”¯æŒå¯¹ç³»ç»Ÿæ—¥å¿—çš„è®¿é—®ã€‚ #$ModLoad imklog #imklogä¸ºæ¨¡å—åï¼Œæ”¯æŒå†…æ ¸æ—¥å¿—çš„æ¨¡å—ã€‚ #$ModLoad immark #immarkä¸ºæ¨¡å—åï¼Œæ”¯æŒæ—¥å¿—æ ‡è®°ã€‚ # Provides UDP syslog reception #æä¾›udp syslogçš„æ¥æ”¶ã€‚ #$ModLoad imudp #imudpä¸ºæ¨¡å—åï¼Œæ”¯æŒudpåè®®ã€‚ #$UDPServerRun 514 #å…è®¸514ç«¯å£æ¥æ”¶ä½¿ç”¨udpå’Œtcpè½¬å‘æ¥çš„æ—¥å¿—ã€‚ # Provides TCP syslog reception #æä¾›tcp syslogçš„æ¥æ”¶ã€‚ #$ModLoad imtcp #imtcpä¸ºæ¨¡å—åï¼Œæ”¯æŒtcpåè®®ã€‚ #$InputTCPServerRun 514 #### GLOBAL DIRECTIVES #### #å®šä¹‰å…¨å±€æ—¥å¿—æ ¼å¼çš„æŒ‡ä»¤ã€‚ # Where to place auxiliary files $WorkDirectory /var/lib/rsyslog #å·¥ä½œç›®å½•ã€‚ # Use default timestamp format $ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat #å®šä¹‰æ—¥å¿—æ ¼å¼é»˜è®¤æ¨¡æ¿ã€‚ $IncludeConfig /etc/rsyslog.d/*.conf #æ‰€æœ‰é…ç½®æ–‡ä»¶è·¯å¾„ã€‚ $OmitLocalLogging on #çœç•¥æœ¬åœ°ç™»å½•ã€‚ # File to store the position in the journal $IMJournalStateFile imjournal.state #### RULES #### #kern.* /dev/console #è®°å½•æ‰€æœ‰æ—¥å¿—ç±»å‹çš„infoçº§åˆ«ä»¥åŠå¤§äºinfoçº§åˆ«çš„ä¿¡æ¯åˆ°messagesæ–‡ä»¶ï¼Œä½†æ˜¯mailé‚®ä»¶ä¿¡æ¯ï¼ŒauthprivéªŒè¯æ–¹é¢çš„ä¿¡æ¯å’Œcornæ—¶é—´å’Œä»»åŠ¡ç›¸å…³ä¿¡æ¯é™¤å¤–ã€‚ *.info;mail.none;authpriv.none;cron.none /var/log/messages # authprivéªŒè¯ç›¸å…³çš„æ‰€æœ‰ä¿¡æ¯å­˜æ”¾åœ¨/var/log/secureã€‚ authpriv.* /var/log/secure #é‚®ä»¶çš„æ‰€æœ‰ä¿¡æ¯å­˜åœ¨/var/log/maillogï¼›è¿™é‡Œæœ‰ä¸€ä¸ªâ€œ-â€ç¬¦å·è¡¨ç¤ºæ˜¯ä½¿ç”¨å¼‚æ­¥çš„æ–¹å¼è®°å½• mail.* -/var/log/maillog #ä»»åŠ¡è®¡åˆ’æœ‰å…³çš„ä¿¡æ¯å­˜æ”¾åœ¨/var/log/cronã€‚ cron.* /var/log/cron #è®°å½•æ‰€æœ‰çš„â‰¥emergçº§åˆ«ä¿¡æ¯ï¼Œå‘é€ç»™æ¯ä¸ªç™»å½•åˆ°ç³»ç»Ÿçš„æ—¥å¿—ã€‚ *.emerg :omusrmsg:* #è®°å½•uucpï¼Œnews.critç­‰å­˜æ”¾åœ¨/var/log/spooler uucp,news.crit /var/log/spooler #æœ¬åœ°æœåŠ¡å™¨çš„å¯åŠ¨çš„æ‰€æœ‰æ—¥å¿—å­˜æ”¾åœ¨/var/log/boot.log local7.* /var/log/boot.log ä»¥ä¸‹ä¸ºï¼šrsyslog å®¢æœç«¯çš„é…ç½® #å‘é€æ—¥å¿—ï¼Œ@è¡¨ç¤ºä¼ è¾“åè®®ï¼ˆ@è¡¨ç¤ºudpï¼Œ@@è¡¨ç¤ºtcpï¼‰ï¼Œåé¢æ˜¯ipå’Œç«¯å£ã€‚ #*.* @@remote-host:514 é…ç½®æœåŠ¡å™¨  ä½¿ç”¨sudo vi /etc/rsyslog.conf æ‰“å¼€é…ç½®æ–‡ä»¶  é€‰æ‹©ä¼ è¾“çš„åè®® 1.ä½¿ç”¨udpä¼ è¾“æ—¥å¿—ï¼Œé…ç½®æ—¶å°†å‰é¢çš„#å»æ‰å³å¯\n$ModLoad imudp\n$UDPServerRun 514\n2.ä½¿ç”¨tcpä¼ è¾“åè®®, å°†#å»ç‚¹å³å¯\n$ModLoad imtcp\n$InputTCPServerRun 514\né…ç½®å¦‚å›¾ï¼š\r\n æ³¨æ˜ï¼š\n514/5014ç«¯å£å·å¯ä»¥è‡ªå·±é…ç½®ï¼Œé»˜è®¤ä¸º514.\nrsyslogåå°è¿›ç¨‹æ˜¯å¯ä»¥åŒæ—¶ç›‘å¬TCP/UDPè¿æ¥çš„  é…ç½®æ¥æ”¶æ—¥å¿—æ¨¡æ¿  åœ¨GLOBAL DIRECTIVESå†…å®¹å—çš„å‰é¢å¢åŠ æ¥æ”¶æ—¥å¿—æ¨¡æ¿ æ¨¡æ¿å¦‚ä¸‹ï¼š\n$template RemoteLogs,\u0026quot;/var/log/%HOSTNAME%/%PROGRAMNAME%.log\u0026quot;\n*.* ?RemoteLogs\n\u0026amp; ~ æ³¨æ˜ï¼š\n1ã€$template RemoteLogsæŒ‡ä»¤ï¼ˆâ€œRemoteLogsâ€ å¯ä»¥ä¸ºå…¶å®ƒçš„æè¿°çš„åå­—ï¼‰è¿«ä½¿rsyslogåå°è¿›ç¨‹éš”å¼€æœ¬åœ°/var/log/ä¸‹æ–‡ä»¶å»å†™æ—¥å¿—ä¿¡æ¯ã€‚è€Œæ—¥å¿—æ–‡ä»¶ååˆ™ä¾æ®å‘é€è¿œç¨‹æ—¥å¿—çš„æœºå™¨ååŠåº”ç”¨ç¨‹åºåæ¥å®šä¹‰ã€‚\n2ã€*.* ?RemoteLogsï¼‰æš—å«è¿è¡Œç”¨æ¨¡æ¿RemoteLogsäºæ‰€æœ‰çš„æ¥æ”¶æ—¥å¿—ã€‚\n3ã€\u0026amp; ~åˆ™å‘Šè¯‰rsyslogåå°è¿›ç¨‹åœæ­¢è¿›ä¸€æ­¥çš„å»å¤„ç†æ—¥å¿—ä¿¡æ¯,å³ä¸å¯¹å®ƒä»¬è¿›è¡Œæœ¬åœ°åŒ–å†™å…¥ï¼Œå®ƒæ˜¯ä»£è¡¨ä¸€ä¸ªé‡å®šå‘è§„åˆ™ã€‚å¦‚æœæ²¡æœ‰è¿™ä¸€è¡Œï¼Œåˆ™æ„å‘³ç€æ¥æ”¶åˆ°çš„æ—¥å¿—ä¼šå†™å…¥ä¸¤æ¬¡ï¼Œä¸€æ¬¡å¦‚å‰ä¸¤è¡Œå†™çš„æ–¹å¼å†™ï¼Œç¬¬äºŒæ¬¡åˆ™ä»¥æœ¬åœ°æ—¥å¿—è®°å½•çš„æ–¹å¼å†™å…¥ã€‚è¿è¡Œè¿™ä¸ªè§„åˆ™çš„å¦ä¸€ä¸ªç»“è®ºåˆ™æ˜¯æ—¥å¿—æœåŠ¡å™¨è‡ªå·±çš„æ—¥å¿—ä¿¡æ¯åªä¼šå†™å…¥åˆ°ä¾ç…§æœºå™¨ä¸»æœºåå‘½åçš„æ–‡ä»¶ä¸­ã€‚ \r è®¾ç½®åï¼Œä¼šæŒ‰ç…§æ¨¡æ¿æ ¼å¼ä¿å­˜æ—¥å¿— \r  è®¾ç½®å®Œæˆï¼Œä¿å­˜ æ£€æŸ¥Rsyslogé…ç½®  ä½¿ç”¨å‘½ä»¤ï¼šrsyslogd -f /etc/rsyslog.conf -N1 é…ç½®ä¿¡æ¯æ­£ç¡®æœ‰å¦‚ä¸‹æç¤º: \r è‹¥é…ç½®ä¿¡æ¯æœ‰è¯¯ï¼Œåˆ™éœ€è¦åœ¨æ›´æ”¹é…ç½®æ–‡ä»¶  é‡å¯RSyslogæœåŠ¡  Debian,Ubuntuæˆ–CentOS/RHEL 6ä½¿ç”¨:sudo service rsyslog restart Fedora æˆ– CentOS/RHEL 7ä½¿ç”¨ï¼šsudo systemctl restart rsyslog ä½¿ç”¨ï¼šsudo lsof -i :[ç«¯å£å·]ï¼ŒæŸ¥çœ‹æœåŠ¡æ˜¯å¦å¼€å¯å’Œtcp/udpè¿æ¥æƒ…å†µ \r æˆ–ä½¿ç”¨sudo netstat -pantu | grep rsyslog \r  æŸ¥çœ‹æ—¥å¿—  å¯åŠ¨å®¢æˆ·ç«¯ï¼Œè¿›å…¥é…ç½®æ–‡ä»¶æ¨¡æ¿ä¸­æ—¥å¿—ä¿å­˜çš„ä½ç½®ï¼š\n\r\n\r è‹¥æ²¡æœ‰ç”Ÿæˆæ—¥å¿—æ–‡ä»¶ï¼Œéœ€è¦ä½¿ç”¨ï¼šsudo tcpdump host å®¢æˆ·ç«¯ip æŸ¥çœ‹æ˜¯å¦è½¬å‘æ—¥å¿—ï¼Œæœ‰åˆ™æ˜¯ä¿å­˜æ¨¡æ¿å‡ºé—®é¢˜ï¼Œæ²¡æœ‰å¯èƒ½çš„æœåŠ¡ç«¯é…ç½®æˆ–è€…å®¢æˆ·ç«¯é…ç½®å‡ºé—®é¢˜\n\r  å®¢æˆ·ç«¯é…ç½® å¹³å°ï¼šx86  å¹³å°æ˜¯ä½¿ç”¨çš„rsyslog ä½¿ç”¨sudo vi /etc/rsyslog.conf æ‰“å¼€é…ç½®æ–‡ä»¶ é…ç½®ï¼š\nå‘é€æ—¥å¿—ï¼Œ@è¡¨ç¤ºä¼ è¾“åè®®ï¼ˆ@è¡¨ç¤ºudpï¼Œ@@è¡¨ç¤ºtcpï¼‰ï¼Œåé¢æ˜¯ipå’Œç«¯å£ã€‚\n*.* @@remote-host:514  \r\n æ£€æŸ¥ä¸é‡å¯æœåŠ¡å’Œx86æœåŠ¡å™¨å¹³å°ä¸€æ ·  å¹³å°å¼€å‘æ¿  æ¿å­æ˜¯ä½¿ç”¨çš„syslog ä½¿ç”¨å‘½ä»¤ï¼špsè¿›è¡ŒæŸ¥çœ‹è¿›ç¨‹\n\r æ‰¾åˆ°syslogdæœåŠ¡ï¼Œè‹¥æœªæ‰¾åˆ°ï¼Œå¯èƒ½ä¸æ”¯æŒsyslogæœåŠ¡ ä½¿ç”¨å‘½ä»¤ï¼šsyslogd â€“h æŸ¥çœ‹syslogdæ”¯æŒçš„æœåŠ¡\n\r  é…ç½®å®¢æˆ·ç«¯ 1.ç»“æŸä¹‹å‰çš„syslogdæœåŠ¡ï¼Œé€šè¿‡ä½¿ç”¨kill è¿›ç¨‹å· ç»“æŸè¿›ç¨‹\n\r 2.é€šè¿‡syslogdæä¾›çš„æœåŠ¡æ˜¯é€šè¿‡ -L â€“R æœåŠ¡å™¨çš„ip:port\næ³¨æ˜ï¼šé»˜è®¤ç«¯å£ä¸ºï¼š514,ç«¯å£å·åº”è¯¥ä¸æœåŠ¡å™¨é…ç½®çš„ç«¯å£å·ä¸€è‡´\n3.å¯åŠ¨syslogdæœåŠ¡ï¼š/sbin/syslogd -f /etc/syslog.conf -L -R 172.16.193.204:514 4.é€šè¿‡tcpdump host 172.16.193.204 æŸ¥çœ‹æ—¥å¿—æ˜¯å¦è¢«è½¬å‘åˆ°æœåŠ¡å™¨\n\r\n æ³¨æ˜ï¼šå¼€å‘æ¿çš„syslogæ”¯æŒUDPä¼ è¾“ï¼Œéœ€è¦å¼€å‘æ¿çš„æ—¥å¿—æ–‡ä»¶éœ€è¦åœ¨æœåŠ¡å™¨æ‰“å¼€UDP  ","date":"2021-09-20T22:00:38+08:00","image":"https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/8_hu442c80cfdca83249146ebd0d5822289f_88346_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/","title":"syslogæ—¥å¿—è½¬å‘é…ç½®"},{"content":"åˆ‡ç‰‡çš„å†…éƒ¨ç»“æ„  åˆ‡ç‰‡çš„ç»“æ„å¯åˆ†ä¸ºï¼šæ•°ç»„ï¼Œæ•°æ®ï¼ˆå…ƒç´ ï¼‰çš„åœ°å€\u0026amp;dataã€ä¹Ÿå­˜å…ƒç´ ä¸ªæ•°lenã€å¯ä»¥å­˜å‚¨å¤šå°‘å…ƒç´ cap æºç å¦‚ä¸‹    å®šä¹‰åˆ‡ç‰‡çš„ç»“æ„ï¼š type slice struct { array unsafe.Pointer len int cap int }  å¦‚å›¾æ‰€ç¤º  \ravatar\r\n var data [] int å£°æ˜ä¸€ä¸ªåˆ‡ç‰‡ï¼Œç›¸å½“äºç”Ÿæˆåˆ‡ç‰‡çš„ç»“æ„ï¼Œdataåœ°å€æŒ‡é’ˆä¸ºnil, lenå’Œcapéƒ½ä¸º0ã€‚è¿™å°±å¾ˆæ¸…æ¥šä¸ºä»€ä¹ˆï¼Œnilåˆ‡ç‰‡ä¸å¯ä»¥ç›´æ¥ä½¿ç”¨äº†ğŸ˜„ ç»“æ„å¦‚å›¾  \ravatar\r\n ä½¿ç”¨åˆ‡ç‰‡æ—¶éœ€è¦make([]type,len,cap)æˆ–è€…åˆå§‹åŒ–[]type{}æ‰èƒ½ä½¿ç”¨ï¼Œè¿™æ˜¯å› ä¸ºåœ¨åœ¨ç”Ÿæˆåˆ‡ç‰‡çš„ç»“æ„æ—¶ï¼ŒåŒæ—¶ä¹Ÿå¼€è¾Ÿäº†ä¸€æ®µæ–°çš„å†…å­˜ï¼Œç±»å‹ä¸ºtype, ç»“æ„é•¿åº¦ä¸ºcap,åŒæ—¶å€¼è¿›è¡Œåˆå§‹åŒ–ã€‚ make æºç å¦‚ä¸‹ï¼š    func makeslice(et *_type, len, cap int) unsafe.Pointer { mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // åˆ¤æ–­æ˜¯å¦è¶Šç•Œ if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 || len \u0026gt; cap { // NOTE: Produce a 'len out of range' error instead of a // 'cap out of range' error when someone does make([]T, bignumber). // 'cap out of range' is true too, but since the cap is only being // supplied implicitly, saying len is clearer. // See golang.org/issue/4085. mem, overflow := math.MulUintptr(et.size, uintptr(len)) if overflow || mem \u0026gt; maxAlloc || len \u0026lt; 0 { panicmakeslicelen() // è¶Šç•Œç›´æ¥ panic } panicmakeslicecap() // è¶Šç•Œç›´æ¥ panic } return mallocgc(mem, et, true) //å¼€è¾Ÿå†…å­˜ }  \ravatar\r\n   ä¹Ÿå¯ä»¥é€šè¿‡åº•å±‚æ•°ç»„åˆå§‹åŒ–ï¼Œåˆ‡ç‰‡çš„dataæŒ‡é’ˆæŒ‡å‘å°±æ˜¯ç›¸åŒç±»å‹çš„åº•å±‚æ•°ç»„ï¼›é€šè¿‡slince := array[n:m],è¡¨ç¤ºå®šä¹‰äº†ä¸€ä¸ªç±»å‹å’Œarrayç›¸åŒï¼Œlenä¸ºm-n,capé»˜è®¤ä¸ºarrayçš„é•¿åº¦çš„åˆ‡ç‰‡ã€‚åˆ‡ç‰‡å’Œæ•°ç»„éƒ½æŒ‡å‘äº†ç›¸åŒçš„åœ°å€ã€‚å¤šä¸ªåˆ‡ç‰‡å¯ä»¥å…±ç”¨åŒä¸€ä¸ªåº•å±‚æ•°ç»„ã€‚ \ravatar\r\n  é€šè¿‡append å‡½æ•°å‘åˆ‡ç‰‡å¢åŠ åˆ‡ç‰‡çš„å…ƒç´ ï¼Œå¢åŠ äº†len, cap ä¸å˜ã€‚\nåˆ‡ç‰‡æ‰©å®¹   åœ¨èµ„æºå……è£•çš„æ¡ä»¶ä¸‹ï¼Œåˆ‡ç‰‡æ˜¯å¯ä»¥é€šè¿‡appendä¸æ–­å¢åŠ å…ƒç´ ï¼Œå½“lenä¸ªæ•°å¢åŠ åˆ°capä¸€æ ·æ—¶ï¼Œåœ¨å¢åŠ å…ƒç´ æ—¶ï¼Œå°±éœ€è¦å¢åŠ åˆ‡ç‰‡çš„å®¹é‡capï¼Œé‚£é—®é¢˜æ¥äº†ï¼Œåˆ‡ç‰‡æ˜¯æ€ä¹ˆæ‰©å®¹çš„å‘¢ï¼Ÿ\næ‰©å®¹è§„åˆ™ï¼ˆé¢„ä¼°è§„åˆ™ï¼‰     å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§ï¼Œåˆ™æ‰©å®¹ä¸ºéœ€è¦æ‰©å®¹çš„æ•°é‡\n  å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå°äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„2å€\n  å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå¤§äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„1.25å€\n  ä¼ªä»£ç å¦‚ä¸‹\n if oldcap2 \u0026lt; newcap æ—¶ï¼Œ æ‰©å®¹ä¸ºnewcap else{ if oldcap \u0026lt; 1024 newcap = 2oldcap ; else newcap = 1.25*oldcap }\n   æºä»£ç å¦‚ä¸‹ï¼š\n    newcap := old.cap doublecap := newcap + newcap //ä¸¤å€çš„oldcap if cap \u0026gt; doublecap { //å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§ï¼Œåˆ™æ‰©å®¹ä¸ºéœ€è¦æ‰©å®¹çš„æ•°é‡ newcap = cap } else { //å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå°äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„2å€ if old.cap \u0026lt; 1024 { newcap = doublecap } else { // Check 0 \u0026lt; newcap to detect overflow // and prevent an infinite loop. å½“éœ€è¦æ‰©å®¹çš„æ•°é‡æ¯”ä¹‹å‰capçš„ä¸¤å€éƒ½å¤§å°ï¼Œä¹‹å‰çš„capå¤§äº1024 ç›´æ¥æ‰©å¤§ä¹‹å‰çš„1.25å€ for 0 \u0026lt; newcap \u0026amp;\u0026amp; newcap \u0026lt; cap { newcap += newcap / 4 } // Set newcap to the requested cap when // the newcap calculation overflowed. if newcap \u0026lt;= 0 { newcap = cap } } } æ‰©å®¹è°ƒæ•´  åœ¨é¢„ä¼°æ‰©å®¹åï¼Œä¼šæ ¹æ®å†…å­˜å¯¹é½ï¼ˆå‡å°‘å†…å­˜æµªè´¹ï¼‰åœ¨è¿›è¡Œè°ƒæ•´ï¼Œä»£ç ï¼šcapmem := roundupsize(uintptr(newcap) * uintptr(et.size))newcapå°±æ˜¯å‰æ–‡ä¸­è®¡ç®—å‡ºçš„newcapï¼Œet.sizeä»£è¡¨sliceä¸­ä¸€ä¸ªå…ƒç´ çš„å¤§å°ï¼Œcapmemè®¡ç®—å‡ºæ¥çš„å°±æ˜¯æ­¤æ¬¡æ‰©å®¹éœ€è¦ç”³è¯·çš„å†…å­˜å¤§å°ã€‚roundupsizeå‡½æ•°å°±æ˜¯å¤„ç†å†…å­˜å¯¹é½çš„å‡½æ•° æºç å¦‚ä¸‹   var overflow bool var lenmem, newlenmem, capmem uintptr switch { case et.size == 1: //ä¾‹å¦‚byte å¤§å°ä¸º1ï¼Œ æ‰©å®¹çš„å¤§å°ä¸ºå‘ä¸Šå–æ•´çš„æ•°å€¼ lenmem = uintptr(old.len) newlenmem = uintptr(cap) capmem = roundupsize(uintptr(newcap)) overflow = uintptr(newcap) \u0026gt; maxAlloc newcap = int(capmem) case et.size == sys.PtrSize: lenmem = uintptr(old.len) * sys.PtrSize newlenmem = uintptr(cap) * sys.PtrSize capmem = roundupsize(uintptr(newcap) * sys.PtrSize) overflow = uintptr(newcap) \u0026gt; maxAlloc/sys.PtrSize newcap = int(capmem / sys.PtrSize) case isPowerOfTwo(et.size): //å¤„ç†2çš„å€æ•° var shift uintptr if sys.PtrSize == 8 { // Mask shift for better code generation. shift = uintptr(sys.Ctz64(uint64(et.size))) \u0026amp; 63 } else { shift = uintptr(sys.Ctz32(uint32(et.size))) \u0026amp; 31 } lenmem = uintptr(old.len) \u0026lt;\u0026lt; shift newlenmem = uintptr(cap) \u0026lt;\u0026lt; shift capmem = roundupsize(uintptr(newcap) \u0026lt;\u0026lt; shift) overflow = uintptr(newcap) \u0026gt; (maxAlloc \u0026gt;\u0026gt; shift) newcap = int(capmem \u0026gt;\u0026gt; shift) default: lenmem = uintptr(old.len) * et.size newlenmem = uintptr(cap) * et.size capmem, overflow = math.MulUintptr(et.size, uintptr(newcap)) capmem = roundupsize(capmem) newcap = int(capmem / et.size) } // The check of overflow in addition to capmem \u0026gt; maxAlloc is needed // to prevent an overflow which can be used to trigger a segfault // on 32bit architectures with this example program: // // type T [1\u0026lt;\u0026lt;27 + 1]int64 // // var d T // var s []T // // func main() { // s = append(s, d, d, d, d) // print(len(s), \u0026quot;\\n\u0026quot;) // } if overflow || capmem \u0026gt; maxAlloc { panic(errorString(\u0026quot;growslice: cap out of range\u0026quot;)) } ### æ‰©å®¹åå†…å­˜åˆ†é… * åˆ†é… å¤§äºcapçš„å†…å­˜ï¼Œæ²¡æœ‰æ•°æ®æŒ‡é’ˆï¼ŒmemclrNoHeapPointersåˆ›å»º * æºç å¦‚ä¸‹ï¼š \u0026gt; var p unsafe.Pointer if et.ptrdata == 0 { p = mallocgc(capmem, nil, false) // The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length). // Only clear the part that will not be overwritten. memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem) } else { // Note: can't use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory. p = mallocgc(capmem, et, true) //åˆ†é…å†…å­˜åœ°å€ if lenmem \u0026gt; 0 \u0026amp;\u0026amp; writeBarrier.enabled { // Only shade the pointers in old.array since we know the destination slice p // only contains nil pointers because it has been cleared during alloc. bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata) } } memmove(p, old.array, lenmem) //æ•°æ®è¿ç§» return slice{p, old.len, newcap} } ","date":"2021-09-15T22:00:38+08:00","image":"https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s4_hu1fce009c184102799b4a69d72efc8ec2_68940_120x120_fill_box_smart1_3.png","permalink":"https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/","title":"go åˆ‡ç‰‡çš„æ·±å…¥ç†è§£"},{"content":"ä¸ºä»€ä¹ˆå†™åšå®¢  æ€»ç»“å¼€å‘ä¸­é‡åˆ°çš„é—®é¢˜ã€‚å·¥ä½œè¿‡åå‘ç°è‡ªå·±å¹¶ä¸æ“…é•¿å¯¹çŸ¥è¯†ç‚¹çš„æ€»ç»“ï¼Œå¯¼è‡´æ€»æ˜¯é‡åˆ°ç›¸åŒçš„é—®é¢˜ï¼Œè¿‡æ®µæ—¶é—´éœ€è¦é‡æ–°æŸ¥æ‰¾è§£å†³æ–¹æ¡ˆ è®°å½•å­¦ä¹ çš„çŸ¥è¯†ï¼Œä¸æ–­çš„æ¸©ä¹ ã€‚å­¦çš„ä¸œè¥¿è¿‡äºç¢ç‰‡åŒ–ï¼Œå¯¼è‡´çŸ¥è¯†ä¸æˆä½“ç³»ã€‚æ—¶é—´é•¿äº†ï¼Œç¢ç‰‡çš„çŸ¥è¯†ä¹Ÿå¿˜è®°äº† æå‡è‡ªå·±çš„ä¸“ä¸šæŠ€èƒ½ã€‚é€šè¿‡å†™åšå®¢æå‡è‡ªå·±çš„èƒ½åŠ› å½¢æˆè‡ªå·±çš„æŠ€æœ¯æ ˆï¼Œé‡åˆ°çš„å¿—åŒé“åˆçš„æœ‹å‹  ä¸ºä»€ä¹ˆé€‰æ‹©hugoæ¥æ­å»ºè‡ªå·±çš„åšå®¢  Hugoæ˜¯ç”±Goè¯­è¨€å®ç°çš„é™æ€ç½‘ç«™ç”Ÿæˆå™¨ã€‚ç®€å•ã€æ˜“ç”¨ã€é«˜æ•ˆã€æ˜“æ‰©å±•ã€å¿«é€Ÿéƒ¨ç½²ã€‚ æ“ä½œç®€å•ï¼Œä½¿ç”¨Markdownç›´æ¥ç”Ÿæˆé™æ€ç½‘é¡µ å…è´¹ä¸”ä»¥ç»´æŠ¤, åœ¨githubä¸Šå°±å¯ä¾›ä»–äººè®¿é—®ï¼Œæ— éœ€è´­ä¹°æœåŠ¡å™¨ï¼Œç»´æŠ¤ç®€å• å‘è¡¨æ–‡ç« ç›´æ¥pushåˆ°è‡ªå·±ä»“åº“å³å¯  ä¸‹è½½hogoçš„æºç   git clone https://github.com/gohugoio/hugo.git\ngit branch æŸ¥çœ‹å•å‰ä»£ç çš„åˆ†æ”¯\ngit branch -a æŸ¥çœ‹å…¨éƒ¨åˆ†æ”¯\ngit checkout branch åˆ‡æ¢åˆ†æ”¯\ngit branch åˆ†æ”¯å åˆ›å»ºè‡ªå·±çš„æœ¬åœ°åˆ†å­\n ç¼–è¯‘æºç   åœ¨masteråˆ†æ”¯ä¸‹ï¼Œåœ¨main.go çš„ç›®å½•ä¸‹ä½¿ç”¨å‘½ä»¤: go build åœ¨ç›®å½•ä¸‹ç”Ÿæˆhugo.exe åœ¨cmdä¸‹ä½¿ç”¨hugo æŸ¥çœ‹æ˜¯å¦ç¼–è¯‘æˆåŠŸ ç¼–è¯‘æˆåŠŸ ä¼šæ‰“å°hugoçš„ç‰ˆæœ¬ å®‰è£…æˆåŠŸ  ç”Ÿæˆç«™ç‚¹  ä½¿ç”¨å‘½ä»¤ï¼šhugo new site /ç›®å½• cd /ç›®å½• æŸ¥çœ‹åˆ°   â–¸ archetypes/ â–¸ content/ â–¸ layouts/ â–¸ static/ config.toml   åˆ›å»ºç«™ç‚¹æˆåŠŸ  åˆ›å»ºmdæ–‡ç«   ä½¿ç”¨å‘½ä»¤: hugo new æ–‡ç« å.md åœ¨content/ ä¸‹ç”Ÿæˆè¯¥mdæ–‡ä»¶  é€‰æ‹©åšå®¢ä¸»é¢˜æ¨¡æ¿  hugo æä¾›å¾ˆå¤šçš„ä¸»é¢˜åšå®¢æ¨¡æ¿ï¼šhttps://themes.gohugo.io/ åˆ›å»ºthemeæ–‡ä»¶å¤¹ï¼Œå°†ä¸»é¢˜æ¨¡æ¿æ”¾åœ¨é‡Œé¢ ï¼šmkdir themes è¿›å…¥è¯¥æ–‡ä»¶å¤¹ï¼šcd themes ä¸‹è½½ä¸»é¢˜ï¼Œä½¿ç”¨git clone ä¸»é¢˜æ¨¡æ¿ ï¼šgit clone https://github.com/spf13/hyde.git  é…ç½®config.tomlæ–‡ä»¶  config.toul æ–‡ä»¶hugo çš„é…ç½®æ–‡ä»¶ï¼Œå¯ä»¥é…ç½®ä¸»é¢˜æ¨¡æ¿ï¼Œä¸ªäººä¿¡æ¯ç­‰(ä¸»é¢˜æ¨¡æ¿ä¸­ç›¸åº”çš„é…ç½®æ–‡ä»¶)å¦‚   baseurl = \u0026quot;http://****.com/\u0026quot; //å‘å¸ƒçš„ç½‘ç«™ languageCode = \u0026quot;ja\u0026quot; //ä½¿ç”¨çš„è¯­è¨€ title = \u0026quot;xxxx.COM\u0026quot; //ç½‘ç«™åç§°ç­‰ [Params] subtitle = \u0026quot;I would like to be a layer 3 switch.\u0026quot; facebook = \u0026quot;https://facebook.com/foobar\u0026quot; twitter = \u0026quot;https://twitter.com/foobar\u0026quot; github = \u0026quot;https://github.com/foobar\u0026quot; profile = \u0026quot;/images/profile.png\u0026quot; copyright = \u0026quot;Written by Asuka Suzuki\u0026quot; analytics = \u0026quot;UA-XXXXXXXX-X\u0026quot;    è¿è¡Œ æœ¬åœ°è¿è¡Œ  ä½¿ç”¨å‘½ä»¤ï¼šhugo server \u0026ndash;buildDrafts é…ç½®æ­£ç¡®åˆ™ä¼šå‡ºç°ï¼š http://localhost:1313/ (bind address 127.0.0.1) ç‚¹å‡»åœ¨æµè§ˆå™¨ä¸­è¿è¡Œ  æ¨é€åˆ°gitgub  é¦–å…ˆåœ¨GitHubä¸Šåˆ›å»ºä¸€ä¸ªRepositoryï¼Œå‘½åä¸ºï¼šgithubç”¨æˆ·å.github.io ä¿®æ”¹config.toml é…ç½®æ–‡ä»¶ï¼šå°†baseurl = \u0026ldquo;http://githubç”¨æˆ·å.github.io\u0026rdquo; ä½¿ç”¨å‘½ä»¤ï¼šhugo \u0026ndash;buildDrafts åœ¨æœ¬åœ°ç”Ÿæˆpublicçš„æ–‡ä»¶å¤¹ \u0026ndash;buildDrafts å‚æ•°çš„ä¸»ç”¨æ˜¯å°†ä½ çš„æ–‡ç« åœ¨ä¸»é¢˜ä¸­å‡ºç°   cd public è¿›å…¥åˆ°publicæ–‡ä»¶å¤¹ $ git init åˆå§‹åŒ–æœ¬åœ°ä»“åº“ $ git remote add origin https://github.com/githubç”¨æˆ·å/githubç”¨æˆ·å.github.io //æ·»åŠ åŸåˆ›ä»“åº“ æˆ–è€…ç›´æ¥ git clone $ git add -A $ git commit -m \u0026quot;first commit\u0026quot; $ git push -u origin master //æ¨åˆ°è¿œç«¯   ä½¿ç”¨ \u0026ldquo;http://githubç”¨æˆ·å.github.io\u0026quot;å°±å¯è®¿é—®  ","date":"2021-09-04T10:05:40+08:00","permalink":"https://zcj-git520.github.io/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%8D%9A%E5%AE%A2/","title":"æˆ‘çš„ç¬¬ä¸€ä»½åšå®¢"}]