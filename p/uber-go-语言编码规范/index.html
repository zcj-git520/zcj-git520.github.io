<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='uber-go/guide 的中文翻译 English Uber go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 gopher 圈熟知的 zap、jaeger 等。2018 年年末 Uber 将内部的 go 风格规范 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。
目录  uber- go/guide 的中文翻译 English Uber go 语言编码规范 版本 目录 介绍 指导原则  指向 interface 的指针 Interface 合理性验证 接收器 (receiver) 与接口 零值 Mutex 是有效的 在边界处拷贝 Slices 和 Maps  接收 Slices 和 Maps 返回 slices 或 maps   使用 defer 释放资源 Channel 的 size 要么是 1，要么是无缓冲的 枚举从 1 开始 使用 time 处理时间  使用 time.'><title>Uber go 语言编码规范</title>

<link rel='canonical' href='https://zcj-git520.github.io/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Uber go 语言编码规范'>
<meta property='og:description' content='uber-go/guide 的中文翻译 English Uber go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 gopher 圈熟知的 zap、jaeger 等。2018 年年末 Uber 将内部的 go 风格规范 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。
目录  uber- go/guide 的中文翻译 English Uber go 语言编码规范 版本 目录 介绍 指导原则  指向 interface 的指针 Interface 合理性验证 接收器 (receiver) 与接口 零值 Mutex 是有效的 在边界处拷贝 Slices 和 Maps  接收 Slices 和 Maps 返回 slices 或 maps   使用 defer 释放资源 Channel 的 size 要么是 1，要么是无缓冲的 枚举从 1 开始 使用 time 处理时间  使用 time.'>
<meta property='og:url' content='https://zcj-git520.github.io/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/'>
<meta property='og:site_name' content='Chengji Zhao&#39;s blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2021-10-20T22:00:08&#43;08:00'/><meta property='article:modified_time' content='2021-10-20T22:00:08&#43;08:00'/><meta property='og:image' content='https://zcj-git520.github.io/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/1.jpg' />
<meta name="twitter:title" content="Uber go 语言编码规范">
<meta name="twitter:description" content="uber-go/guide 的中文翻译 English Uber go 语言编码规范 Uber 是一家美国硅谷的科技公司，也是 go 语言的早期 adopter。其开源了很多 golang 项目，诸如被 gopher 圈熟知的 zap、jaeger 等。2018 年年末 Uber 将内部的 go 风格规范 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。
目录  uber- go/guide 的中文翻译 English Uber go 语言编码规范 版本 目录 介绍 指导原则  指向 interface 的指针 Interface 合理性验证 接收器 (receiver) 与接口 零值 Mutex 是有效的 在边界处拷贝 Slices 和 Maps  接收 Slices 和 Maps 返回 slices 或 maps   使用 defer 释放资源 Channel 的 size 要么是 1，要么是无缓冲的 枚举从 1 开始 使用 time 处理时间  使用 time."><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://zcj-git520.github.io/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/1.jpg' />
    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>返回</span>
            </a>
        </div>
    
<main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">
                <img src="/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/1_hu7c5d570e6f1bb8cc35e9c2f13acb3eec_11753_800x0_resize_q75_box.jpg"
                        srcset="/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/1_hu7c5d570e6f1bb8cc35e9c2f13acb3eec_11753_800x0_resize_q75_box.jpg 800w, /p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/1_hu7c5d570e6f1bb8cc35e9c2f13acb3eec_11753_1600x0_resize_q75_box.jpg 1600w"
                        width="800" 
                        height="579" 
                        loading="lazy"
                        alt="Featured image of post Uber go 语言编码规范" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/language/" style="background-color: #2a9d8f; color: #fff;">
                语言学习
            </a>
        
            <a href="/categories/golang/" style="background-color: #2a9d8f; color: #fff;">
                Golang
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/">Uber go 语言编码规范</a>
    </h2>

    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Oct 20, 2021</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 23 分钟
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="uber-goguidehttpsgithubcomuber-goguide-的中文翻译"><a class="link" href="https://github.com/uber-go/guide"  target="_blank" rel="noopener"
    >uber-go/guide</a> 的中文翻译</h2>
<h2 id="englishhttpsgithubcomuber-goguideblobmasterstylemd"><a class="link" href="https://github.com/uber-go/guide/blob/master/style.md"  target="_blank" rel="noopener"
    >English</a></h2>
<h2 id="uber-go-语言编码规范">Uber go 语言编码规范</h2>
<p><a class="link" href="https://www.uber.com/"  target="_blank" rel="noopener"
    >Uber</a> 是一家美国硅谷的科技公司，也是 go 语言的早期 adopter。其开源了很多 golang 项目，诸如被
gopher 圈熟知的 <a class="link" href="https://github.com/uber-go/zap"  target="_blank" rel="noopener"
    >zap</a>、<a class="link" href="https://github.com/jaegertracing/jaeger"  target="_blank" rel="noopener"
    >jaeger</a> 等。2018 年年末 Uber 将内部的 <a class="link" href="https://github.com/uber-go/guide"  target="_blank" rel="noopener"
    >go 风格规范</a> 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。</p>
<h2 id="目录">目录</h2>
<ul>
<li><a class="link" href="#uber-goguide-%e7%9a%84%e4%b8%ad%e6%96%87%e7%bf%bb%e8%af%91" >uber-
go/guide 的中文翻译</a></li>
<li><a class="link" href="#english" >English</a></li>
<li><a class="link" href="#uber-go-%e8%af%ad%e8%a8%80%e7%bc%96%e7%a0%81%e8%a7%84%e8%8c%83" >Uber go 语言编码规范</a></li>
<li><a class="link" href="#%e7%89%88%e6%9c%ac" >版本</a></li>
<li><a class="link" href="#%e7%9b%ae%e5%bd%95" >目录</a></li>
<li><a class="link" href="#%e4%bb%8b%e7%bb%8d" >介绍</a></li>
<li><a class="link" href="#%e6%8c%87%e5%af%bc%e5%8e%9f%e5%88%99" >指导原则</a>
<ul>
<li><a class="link" href="#%e6%8c%87%e5%90%91-interface-%e7%9a%84%e6%8c%87%e9%92%88" >指向 interface 的指针</a></li>
<li><a class="link" href="#interface-%e5%90%88%e7%90%86%e6%80%a7%e9%aa%8c%e8%af%81" >Interface 合理性验证</a></li>
<li><a class="link" href="#%e6%8e%a5%e6%94%b6%e5%99%a8-receiver-%e4%b8%8e%e6%8e%a5%e5%8f%a3" >接收器 (receiver) 与接口</a></li>
<li><a class="link" href="#%e9%9b%b6%e5%80%bc-mutex-%e6%98%af%e6%9c%89%e6%95%88%e7%9a%84" >零值 Mutex 是有效的</a></li>
<li><a class="link" href="#%e5%9c%a8%e8%be%b9%e7%95%8c%e5%a4%84%e6%8b%b7%e8%b4%9d-slices-%e5%92%8c-maps" >在边界处拷贝 Slices 和 Maps</a>
<ul>
<li><a class="link" href="#%e6%8e%a5%e6%94%b6-slices-%e5%92%8c-maps" >接收 Slices 和 Maps</a></li>
<li><a class="link" href="#%e8%bf%94%e5%9b%9e-slices-%e6%88%96-maps" >返回 slices 或 maps</a></li>
</ul>
</li>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8-defer-%e9%87%8a%e6%94%be%e8%b5%84%e6%ba%90" >使用 defer 释放资源</a></li>
<li><a class="link" href="#channel-%e7%9a%84-size-%e8%a6%81%e4%b9%88%e6%98%af-1%e8%a6%81%e4%b9%88%e6%98%af%e6%97%a0%e7%bc%93%e5%86%b2%e7%9a%84" >Channel 的 size 要么是 1，要么是无缓冲的</a></li>
<li><a class="link" href="#%e6%9e%9a%e4%b8%be%e4%bb%8e-1-%e5%bc%80%e5%a7%8b" >枚举从 1 开始</a></li>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8-time-%e5%a4%84%e7%90%86%e6%97%b6%e9%97%b4" >使用 time 处理时间</a>
<ul>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8-timetime-%e8%a1%a8%e8%be%be%e7%9e%ac%e6%97%b6%e6%97%b6%e9%97%b4" >使用 <code>time.Time</code> 表达瞬时时间</a></li>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8-timeduration-%e8%a1%a8%e8%be%be%e6%97%b6%e9%97%b4%e6%ae%b5" >使用 <code>time.Duration</code> 表达时间段</a></li>
<li><a class="link" href="#%e5%af%b9%e5%a4%96%e9%83%a8%e7%b3%bb%e7%bb%9f%e4%bd%bf%e7%94%a8-timetime-%e5%92%8c-timeduration" >对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></a></li>
</ul>
</li>
<li><a class="link" href="#%e9%94%99%e8%af%af%e7%b1%bb%e5%9e%8b" >错误类型</a></li>
<li><a class="link" href="#%e9%94%99%e8%af%af%e5%8c%85%e8%a3%85-error-wrapping" >错误包装 (Error Wrapping)</a></li>
<li><a class="link" href="#%e5%a4%84%e7%90%86%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80%e5%a4%b1%e8%b4%a5" >处理类型断言失败</a></li>
<li><a class="link" href="#%e4%b8%8d%e8%a6%81-panic" >不要 panic</a></li>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8-gouberorgatomic" >使用 go.uber.org/atomic</a></li>
<li><a class="link" href="#%e9%81%bf%e5%85%8d%e5%8f%af%e5%8f%98%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f" >避免可变全局变量</a></li>
<li><a class="link" href="#%e9%81%bf%e5%85%8d%e5%9c%a8%e5%85%ac%e5%85%b1%e7%bb%93%e6%9e%84%e4%b8%ad%e5%b5%8c%e5%85%a5%e7%b1%bb%e5%9e%8b" >避免在公共结构中嵌入类型</a></li>
<li><a class="link" href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e5%86%85%e7%bd%ae%e5%90%8d%e7%a7%b0" >避免使用内置名称</a></li>
<li><a class="link" href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8-init" >避免使用 <code>init()</code></a></li>
<li><a class="link" href="#%e8%bf%bd%e5%8a%a0%e6%97%b6%e4%bc%98%e5%85%88%e6%8c%87%e5%ae%9a%e5%88%87%e7%89%87%e5%ae%b9%e9%87%8f" >追加时优先指定切片容量</a></li>
<li><a class="link" href="#%e4%b8%bb%e5%87%bd%e6%95%b0%e9%80%80%e5%87%ba%e6%96%b9%e5%bc%8fexit" >主函数退出方式(Exit)</a>
<ul>
<li><a class="link" href="#%e4%b8%80%e6%ac%a1%e6%80%a7%e9%80%80%e5%87%ba" >一次性退出</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="link" href="#%e6%80%a7%e8%83%bd" >性能</a>
<ul>
<li><a class="link" href="#%e4%bc%98%e5%85%88%e4%bd%bf%e7%94%a8-strconv-%e8%80%8c%e4%b8%8d%e6%98%af-fmt" >优先使用 strconv 而不是 fmt</a></li>
<li><a class="link" href="#%e9%81%bf%e5%85%8d%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%88%b0%e5%ad%97%e8%8a%82%e7%9a%84%e8%bd%ac%e6%8d%a2" >避免字符串到字节的转换</a></li>
<li><a class="link" href="#%e6%8c%87%e5%ae%9a%e5%ae%b9%e5%99%a8%e5%ae%b9%e9%87%8f" >指定容器容量</a>
<ul>
<li><a class="link" href="#%e6%8c%87%e5%ae%9amap%e5%ae%b9%e9%87%8f%e6%8f%90%e7%a4%ba" >指定Map容量提示</a></li>
<li><a class="link" href="#%e6%8c%87%e5%ae%9a%e5%88%87%e7%89%87%e5%ae%b9%e9%87%8f" >指定切片容量</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="link" href="#%e8%a7%84%e8%8c%83" >规范</a>
<ul>
<li><a class="link" href="#%e4%b8%80%e8%87%b4%e6%80%a7" >一致性</a></li>
<li><a class="link" href="#%e7%9b%b8%e4%bc%bc%e7%9a%84%e5%a3%b0%e6%98%8e%e6%94%be%e5%9c%a8%e4%b8%80%e7%bb%84" >相似的声明放在一组</a></li>
<li><a class="link" href="#import-%e5%88%86%e7%bb%84" >import 分组</a></li>
<li><a class="link" href="#%e5%8c%85%e5%90%8d" >包名</a></li>
<li><a class="link" href="#%e5%87%bd%e6%95%b0%e5%90%8d" >函数名</a></li>
<li><a class="link" href="#%e5%af%bc%e5%85%a5%e5%88%ab%e5%90%8d" >导入别名</a></li>
<li><a class="link" href="#%e5%87%bd%e6%95%b0%e5%88%86%e7%bb%84%e4%b8%8e%e9%a1%ba%e5%ba%8f" >函数分组与顺序</a></li>
<li><a class="link" href="#%e5%87%8f%e5%b0%91%e5%b5%8c%e5%a5%97" >减少嵌套</a></li>
<li><a class="link" href="#%e4%b8%8d%e5%bf%85%e8%a6%81%e7%9a%84-else" >不必要的 else</a></li>
<li><a class="link" href="#%e9%a1%b6%e5%b1%82%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e" >顶层变量声明</a></li>
<li><a class="link" href="#%e5%af%b9%e4%ba%8e%e6%9c%aa%e5%af%bc%e5%87%ba%e7%9a%84%e9%a1%b6%e5%b1%82%e5%b8%b8%e9%87%8f%e5%92%8c%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8_%e4%bd%9c%e4%b8%ba%e5%89%8d%e7%bc%80" >对于未导出的顶层常量和变量，使用_作为前缀</a></li>
<li><a class="link" href="#%e7%bb%93%e6%9e%84%e4%bd%93%e4%b8%ad%e7%9a%84%e5%b5%8c%e5%85%a5" >结构体中的嵌入</a></li>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8%e5%ad%97%e6%ae%b5%e5%90%8d%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84%e4%bd%93" >使用字段名初始化结构体</a></li>
<li><a class="link" href="#%e6%9c%ac%e5%9c%b0%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e" >本地变量声明</a></li>
<li><a class="link" href="#nil-%e6%98%af%e4%b8%80%e4%b8%aa%e6%9c%89%e6%95%88%e7%9a%84-slice" >nil 是一个有效的 slice</a></li>
<li><a class="link" href="#%e7%bc%a9%e5%b0%8f%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f" >缩小变量作用域</a></li>
<li><a class="link" href="#%e9%81%bf%e5%85%8d%e5%8f%82%e6%95%b0%e8%af%ad%e4%b9%89%e4%b8%8d%e6%98%8e%e7%a1%aeavoid-naked-parameters" >避免参数语义不明确(Avoid Naked Parameters)</a></li>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8%e5%8e%9f%e5%a7%8b%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%97%e9%9d%a2%e5%80%bc%e9%81%bf%e5%85%8d%e8%bd%ac%e4%b9%89" >使用原始字符串字面值，避免转义</a></li>
<li><a class="link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84%e4%bd%93" >初始化结构体</a>
<ul>
<li><a class="link" href="#%e4%bd%bf%e7%94%a8%e5%ad%97%e6%ae%b5%e5%90%8d%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84" >使用字段名初始化结构</a></li>
<li><a class="link" href="#%e7%9c%81%e7%95%a5%e7%bb%93%e6%9e%84%e4%b8%ad%e7%9a%84%e9%9b%b6%e5%80%bc%e5%ad%97%e6%ae%b5" >省略结构中的零值字段</a></li>
<li><a class="link" href="#%e5%af%b9%e9%9b%b6%e5%80%bc%e7%bb%93%e6%9e%84%e4%bd%bf%e7%94%a8-var" >对零值结构使用 <code>var</code></a></li>
<li><a class="link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96-struct-%e5%bc%95%e7%94%a8" >初始化 Struct 引用</a></li>
</ul>
</li>
<li><a class="link" href="#%e5%88%9d%e5%a7%8b%e5%8c%96-maps" >初始化 Maps</a></li>
<li><a class="link" href="#%e5%ad%97%e7%ac%a6%e4%b8%b2-string-format" >字符串 string format</a></li>
<li><a class="link" href="#%e5%91%bd%e5%90%8d-printf-%e6%a0%b7%e5%bc%8f%e7%9a%84%e5%87%bd%e6%95%b0" >命名 Printf 样式的函数</a></li>
</ul>
</li>
<li><a class="link" href="#%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f" >编程模式</a>
<ul>
<li><a class="link" href="#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95" >表驱动测试</a></li>
<li><a class="link" href="#%e5%8a%9f%e8%83%bd%e9%80%89%e9%a1%b9" >功能选项</a></li>
</ul>
</li>
<li><a class="link" href="#linting" >Linting</a>
<ul>
<li><a class="link" href="#lint-runners" >Lint Runners</a></li>
</ul>
</li>
<li><a class="link" href="#stargazers-over-time" >Stargazers over time</a></li>
</ul>
<h2 id="介绍">介绍</h2>
<p>样式 (style) 是支配我们代码的惯例。术语<code>样式</code>有点用词不当，因为这些约定涵盖的范围不限于由
gofmt 替我们处理的源文件格式。</p>
<p>本指南的目的是通过详细描述在 Uber 编写
go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用
go 语言功能。</p>
<p>该指南最初由 <a class="link" href="https://github.com/prashantv"  target="_blank" rel="noopener"
    >Prashant Varanasi</a> 和 <a class="link" href="https://github.com/nomis52"  target="_blank" rel="noopener"
    >Simon Newton</a> 编写，目的是使一些同事能快速使用
go。多年来，该指南已根据其他人的反馈进行了修改。</p>
<p>本文档记录了我们在 Uber 遵循的
go 代码中的惯用约定。其中许多是
go 的通用准则，而其他扩展准则依赖于下面外部的指南：</p>
<ol>
<li>[Effective
go](https://
golang.org/doc/effective_
go.html)</li>
<li>[
go Common Mistakes](<a class="link" href="https://github.com/"  target="_blank" rel="noopener"
    >https://github.com/</a>
golang/
go/wiki/CommonMistakes)</li>
<li>[
go Code Review Comments](<a class="link" href="https://github.com/"  target="_blank" rel="noopener"
    >https://github.com/</a>
golang/
go/wiki/CodeReviewComments)</li>
</ol>
<p>所有代码都应该通过<code> golint</code>和<code> go vet</code>的检查并无错误。我们建议您将编辑器设置为：</p>
<ul>
<li>保存时运行 <code> goimports</code></li>
<li>运行 <code> golint</code> 和 <code> go vet</code> 检查错误</li>
</ul>
<p>您可以在以下
go 编辑器工具支持页面中找到更为详细的信息：
&lt;https://github.com/
golang/
go/wiki/IDEsAndTextEditorPlugins&gt;</p>
<h2 id="指导原则">指导原则</h2>
<h3 id="指向-interface-的指针">指向 interface 的指针</h3>
<p>您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。</p>
<p>接口实质上在底层用两个字段表示：</p>
<ol>
<li>一个指向某些特定类型信息的指针。您可以将其视为&quot;type&quot;。</li>
<li>数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。</li>
</ol>
<p>如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。</p>
<pre tabindex="0"><code>
go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

// f1.f()无法修改底层数据
// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针
var f1 F = S1{}
var f2 F = &amp;S2{}
</code></pre><h3 id="interface-合理性验证">Interface 合理性验证</h3>
<p>在编译时验证接口的符合性。这包括：</p>
<ul>
<li>将实现特定接口的导出类型作为接口API 的一部分进行检查</li>
<li>实现同一接口的(导出和非导出)类型属于实现类型的集合</li>
<li>任何违反接口合理性检查的场景,都会终止编译,并通知给用户</li>
</ul>
<p>补充:上面3条是编译器对接口的检查机制,
大体意思是错误使用接口会在编译期报错.
所以可以利用这个机制让部分问题在编译期暴露.</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// 如果Handler没有实现http.Handler,会在运行时报错
type Handler struct {
  // ...
}
func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  ...
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>
go
type Handler struct {
  // ...
}
// 用于触发编译期的接口的合理性检查机制
// 如果Handler没有实现http.Handler,会在编译期报错
var _ http.Handler = (*Handler)(nil)
func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
</code></pre><!-- raw HTML omitted -->
<p>如果 <code>*Handler</code> 与 <code>http.Handler</code> 的接口不匹配,
那么语句 <code>var _ http.Handler = (*Handler)(nil)</code> 将无法编译通过.</p>
<p>赋值的右边应该是断言类型的零值。
对于指针类型（如 <code>*Handler</code>）、切片和映射，这是 <code>nil</code>；
对于结构类型，这是空结构。</p>
<pre tabindex="0"><code>go
type LogHandler struct {
  h   http.Handler
  log *zap.Logger
}
var _ http.Handler = LogHandler{}
func (h LogHandler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
</code></pre><h3 id="接收器-receiver-与接口">接收器 (receiver) 与接口</h3>
<p>使用值接收器的方法既可以通过值调用，也可以通过指针调用。</p>
<p>带指针接收器的方法只能通过指针或 <a class="link" href="https://"  target="_blank" rel="noopener"
    >addressable values</a>调用.</p>
<p>golang.org/ref/spec#Method_values</p>
<p>例如，</p>
<pre tabindex="0"><code>go
type S struct {
  data string
}

func (s S) Read() string {
  return s.data
}

func (s *S) Write(str string) {
  s.data = str
}

sVals := map[int]S{1: {&quot;A&quot;}}

// 你只能通过值调用 Read
sVals[1].Read()

// 这不能编译通过：
//  sVals[1].Write(&quot;test&quot;)

sPtrs := map[int]*S{1: {&quot;A&quot;}}

// 通过指针既可以调用 Read，也可以调用 Write 方法
sPtrs[1].Read()
sPtrs[1].Write(&quot;test&quot;)
</code></pre><p>类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.</p>
<pre tabindex="0"><code>go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

s1Val := S1{}
s1Ptr := &amp;S1{}
s2Val := S2{}
s2Ptr := &amp;S2{}

var i F
i = s1Val
i = s1Ptr
i = s2Ptr

//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器
//   i = s2Val
</code></pre><p>[Effective
go](https://
golang.org/doc/effective_
go.html) 中有一段关于 [pointers vs. values](https://
golang.org/doc/effective_
go.html#pointers_vs_values) 的精彩讲解。</p>
<p>补充:</p>
<ul>
<li>一个类型可以有值接收器方法集和指针接收器方法集
<ul>
<li>值接收器方法集是指针接收器方法集的子集,反之不是</li>
</ul>
</li>
<li>规则
<ul>
<li>值对象只可以使用值接收器方法集</li>
<li>指针对象可以使用 值接收器方法集 + 指针接收器方法集</li>
</ul>
</li>
<li>接口的匹配(或者叫实现)
<ul>
<li>类型实现了接口的所有方法,叫匹配</li>
<li>具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口</li>
</ul>
</li>
</ul>
<p>具体的匹配分两种:</p>
<ul>
<li>值方法集和接口匹配
<ul>
<li>给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集</li>
</ul>
</li>
<li>指针方法集和接口匹配
<ul>
<li>只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配</li>
<li>如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)</li>
</ul>
</li>
</ul>
<p>为啥 i = s2Val 会报错,因为值方法集和接口不匹配.</p>
<h3 id="零值-mutex-是有效的">零值 Mutex 是有效的</h3>
<p>零值 <code>sync.Mutex</code> 和 <code>sync.RWMutex</code> 是有效的。所以指向 mutex 的指针基本是不必要的。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
mu := new(sync.Mutex)
mu.Lock()
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var mu sync.Mutex
mu.Lock()
</code></pre><!-- raw HTML omitted -->
<p>如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。
如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type smap struct {
  sync.Mutex // only for unexported types（仅适用于非导出类型）

  data map[string]string
}

func newSMap() *smap {
  return &amp;smap{
    data: make(map[string]string),
  }
}

func (m *smap) Get(k string) string {
  m.Lock()
  defer m.Unlock()

  return m.data[k]
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type SMap struct {
  mu sync.Mutex // 对于导出类型，请使用私有锁

  data map[string]string
}

func NewSMap() *SMap {
  return &amp;SMap{
    data: make(map[string]string),
  }
}

func (m *SMap) Get(k string) string {
  m.mu.Lock()
  defer m.mu.Unlock()

  return m.data[k]
}
</code></pre><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="在边界处拷贝-slices-和-maps">在边界处拷贝 Slices 和 Maps</h3>
<p>slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。</p>
<h4 id="接收-slices-和-maps">接收 Slices 和 Maps</h4>
<p>请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = trips
}

trips := ...
d1.SetTrips(trips)

// 你是要修改 d1.trips 吗？
trips[0] = ...
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = make([]Trip, len(trips))
  copy(d.trips, trips)
}

trips := ...
d1.SetTrips(trips)

// 这里我们修改 trips[0]，但不会影响到 d1.trips
trips[0] = ...
</code></pre><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h4 id="返回-slices-或-maps">返回 slices 或 maps</h4>
<p>同样，请注意用户对暴露内部状态的 map 或 slice 的修改。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Stats struct {
  mu sync.Mutex

  counters map[string]int
}

// Snapshot 返回当前状态。
func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  return s.counters
}

// snapshot 不再受互斥锁保护
// 因此对 snapshot 的任何访问都将受到数据竞争的影响
// 影响 stats.counters
snapshot := stats.Snapshot()
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Stats struct {
  mu sync.Mutex

  counters map[string]int
}

func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  result := make(map[string]int, len(s.counters))
  for k, v := range s.counters {
    result[k] = v
  }
  return result
}

// snapshot 现在是一个拷贝
snapshot := stats.Snapshot()
</code></pre><!-- raw HTML omitted -->
<h3 id="使用-defer-释放资源">使用 defer 释放资源</h3>
<p>使用 defer 释放资源，诸如文件和锁。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
p.Lock()
if p.count &lt; 10 {
  p.Unlock()
  return p.count
}

p.count++
newCount := p.count
p.Unlock()

return newCount

// 当有多个 return 分支时，很容易遗忘 unlock
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
p.Lock()
defer p.Unlock()

if p.count &lt; 10 {
  return p.count
}

p.count++
return p.count

// 更可读
</code></pre><!-- raw HTML omitted -->
<p>Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 <code>defer</code>。</p>
<h3 id="channel-的-size-要么是-1要么是无缓冲的">Channel 的 size 要么是 1，要么是无缓冲的</h3>
<p>channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// 应该足以满足任何情况！
c := make(chan int, 64)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// 大小：1
c := make(chan int, 1) // 或者
// 无缓冲 channel，大小为 0
c := make(chan int)
</code></pre><!-- raw HTML omitted -->
<h3 id="枚举从-1-开始">枚举从 1 开始</h3>
<p>在
go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Operation int

const (
  Add Operation = iota
  Subtract
  Multiply
)

// Add=0, Subtract=1, Multiply=2
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
)

// Add=1, Subtract=2, Multiply=3
</code></pre><!-- raw HTML omitted -->
<p>在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。</p>
<pre tabindex="0"><code>go
type Lo
goutput int

const (
  LogToStdout Lo
goutput = iota
  LogToFile
  LogToRemote
)

// LogToStdout=0, LogToFile=1, LogToRemote=2
</code></pre><h3 id="使用-time-处理时间">使用 time 处理时间</h3>
<p>时间处理很复杂。关于时间的错误假设通常包括以下几点。</p>
<ol>
<li>一天有 24 小时</li>
<li>一小时有 60 分钟</li>
<li>一周有七天</li>
<li>一年 365 天</li>
<li><a class="link" href="https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time"  target="_blank" rel="noopener"
    >还有更多</a></li>
</ol>
<p>例如，<em>1</em> 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。</p>
<p>因此，在处理时间时始终使用 <a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>&quot;time&quot;</code></a> 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。</p>
<p>golang.org/pkg/time/</p>
<h4 id="使用-timetime-表达瞬时时间">使用 <code>time.Time</code> 表达瞬时时间</h4>
<p>在处理时间的瞬间时使用 <a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>time.Time</code></a>，在比较、添加或减去时间时使用 <code>time.Time</code> 中的方法。</p>
<p>golang.org/pkg/time/#Time</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func isActive(now, start, stop int) bool {
  return start &lt;= now &amp;&amp; now &lt; stop
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func isActive(now, start, stop time.Time) bool {
  return (start.Before(now) || start.Equal(now)) &amp;&amp; now.Before(stop)
}
</code></pre><!-- raw HTML omitted -->
<h4 id="使用-timeduration-表达时间段">使用 <code>time.Duration</code> 表达时间段</h4>
<p>在处理时间段时使用 <a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>time.Duration</code></a> .</p>
<p>golang.org/pkg/time/#Duration</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func poll(delay int) {
  for {
    // ...
    time.Sleep(time.Duration(delay) * time.Millisecond)
  }
}
poll(10) // 是几秒钟还是几毫秒?
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func poll(delay time.Duration) {
  for {
    // ...
    time.Sleep(delay)
  }
}
poll(10*time.Second)
</code></pre><!-- raw HTML omitted -->
<p>回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 <a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>Time.AddDate</code></a>。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 [<code>Time.Add</code>]。</p>
<p>golang.org/pkg/time/#Time.AddDate
[<code>Time.Add</code>]: https://
golang.org/pkg/time/#Time.Add</p>
<pre tabindex="0"><code>go
newDay := t.AddDate(0 /* years */, 0 /* months */, 1 /* days */)
maybeNewDay := t.Add(24 * time.Hour)
</code></pre><h4 id="对外部系统使用-timetime-和-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></h4>
<p>尽可能在与外部系统的交互中使用 <code>time.Duration</code> 和 <code>time.Time</code> 例如 :</p>
<ul>
<li>
<p>Command-line 标志: <a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>flag</code></a> 通过 [<code>time.ParseDuration</code>] 支持 <code>time.Duration</code></p>
</li>
<li>
<p>JSON: [<code>encoding/json</code>] 通过其 [<code>UnmarshalJSON</code> method] 方法支持将 <code>time.Time</code> 编码为 [RFC 3339] 字符串</p>
</li>
<li>
<p>SQL: [<code>database/sql</code>] 支持将 <code>DATETIME</code> 或 <code>TIMESTAMP</code> 列转换为 <code>time.Time</code>，如果底层驱动程序支持则返回</p>
</li>
<li>
<p>YAML: [<code> gopkg.in/yaml.v2</code>] 支持将 <code>time.Time</code> 作为 [RFC 3339] 字符串，并通过 [<code>time.ParseDuration</code>] 支持 <code>time.Duration</code>。</p>
<p>golang.org/pkg/flag/
[<code>time.ParseDuration</code>]: https://
golang.org/pkg/time/#ParseDuration
[<code>encoding/json</code>]: https://
golang.org/pkg/encoding/json/
[RFC 3339]: <a class="link" href="https://tools.ietf.org/html/rfc3339"  target="_blank" rel="noopener"
    >https://tools.ietf.org/html/rfc3339</a>
[<code>UnmarshalJSON</code> method]: https://
golang.org/pkg/time/#Time.UnmarshalJSON
[<code>database/sql</code>]: https://
golang.org/pkg/database/sql/
[<code> gopkg.in/yaml.v2</code>]: https://
godoc.org/
gopkg.in/yaml.v2</p>
</li>
</ul>
<p>当不能在这些交互中使用 <code>time.Duration</code> 时，请使用 <code>int</code> 或 <code>float64</code>，并在字段名称中包含单位。</p>
<p>例如，由于 <code>encoding/json</code> 不支持 <code>time.Duration</code>，因此该单位包含在字段的名称中。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// {&quot;interval&quot;: 2}
type Config struct {
  Interval int `json:&quot;interval&quot;`
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// {&quot;intervalMillis&quot;: 2000}
type Config struct {
  IntervalMillis int `json:&quot;intervalMillis&quot;`
}
</code></pre><!-- raw HTML omitted -->
<p>当在这些交互中不能使用 <code>time.Time</code> 时，除非达成一致，否则使用 <code>string</code> 和 [RFC 3339] 中定义的格式时间戳。默认情况下，<a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>Time.UnmarshalText</code></a> 使用此格式，并可通过 [<code>time.RFC3339</code>] 在 <code>Time.Format</code> 和 <code>time.Parse</code> 中使用。</p>
<p>golang.org/pkg/time/#Time.UnmarshalText
[<code>time.RFC3339</code>]: https://
golang.org/pkg/time/#RFC3339</p>
<p>尽管这在实践中并不成问题，但请记住，<code>&quot;time&quot;</code> 包不支持解析闰秒时间戳（<a class="link" href="https://github.com/"  target="_blank" rel="noopener"
    >8728</a>），也不在计算中考虑闰秒（[15190]）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。</p>
<p>golang/
go/issues/8728
[15190]: <a class="link" href="https://github.com/"  target="_blank" rel="noopener"
    >https://github.com/</a>
golang/
go/issues/15190</p>
<!-- raw HTML omitted -->
<h3 id="错误类型">错误类型</h3>
<p>go 中有多种声明错误（Error) 的选项：</p>
<ul>
<li><a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>errors.New</code></a> 对于简单静态字符串的错误</li>
<li>[<code>fmt.Errorf</code>] 用于格式化的错误字符串</li>
<li>实现 <code>Error()</code> 方法的自定义类型</li>
<li>用 [<code>&quot;pkg/errors&quot;.Wrap</code>] 的 Wrapped errors</li>
</ul>
<p>返回错误时，请考虑以下因素以确定最佳选择：</p>
<ul>
<li>
<p>这是一个不需要额外信息的简单错误吗？如果是这样，<a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>errors.New</code></a> 足够了。</p>
</li>
<li>
<p>客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 <code>Error()</code> 方法。</p>
</li>
<li>
<p>您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 <a class="link" href="#%e9%94%99%e8%af%af%e5%8c%85%e8%a3%85"  title="Error-Wrapping"
    >section on error wrapping</a> 部分的内容。</p>
</li>
<li>
<p>否则 [<code>fmt.Errorf</code>] 就可以了。</p>
<p>golang.org/pkg/errors/#New
[<code>fmt.Errorf</code>]: https://
golang.org/pkg/fmt/#Errorf
[<code>&quot;pkg/errors&quot;.Wrap</code>]: https://
godoc.org/github.com/pkg/errors#Wrap</p>
</li>
</ul>
<p>如果客户端需要检测错误，并且您已使用创建了一个简单的错误 <a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>errors.New</code></a>，请使用一个错误变量。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// package foo

func Open() error {
  return errors.New(&quot;could not open&quot;)
}

// package bar

func use() {
  if err := foo.Open(); err != nil {
    if err.Error() == &quot;could not open&quot; {
      // handle
    } else {
      panic(&quot;unknown error&quot;)
    }
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// package foo

var ErrCouldNotOpen = errors.New(&quot;could not open&quot;)

func Open() error {
  return ErrCouldNotOpen
}

// package bar

if err := foo.Open(); err != nil {
  if errors.Is(err, foo.ErrCouldNotOpen) {
    // handle
  } else {
    panic(&quot;unknown error&quot;)
  }
}
</code></pre><!-- raw HTML omitted -->
<p>如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func open(file string) error {
  return fmt.Errorf(&quot;file %q not found&quot;, file)
}

func use() {
  if err := open(&quot;testfile.txt&quot;); err != nil {
    if strings.Contains(err.Error(), &quot;not found&quot;) {
      // handle
    } else {
      panic(&quot;unknown error&quot;)
    }
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type errNotFound struct {
  file string
}

func (e errNotFound) Error() string {
  return fmt.Sprintf(&quot;file %q not found&quot;, e.file)
}

func open(file string) error {
  return errNotFound{file: file}
}

func use() {
  if err := open(&quot;testfile.txt&quot;); err != nil {
    if _, ok := err.(errNotFound); ok {
      // handle
    } else {
      panic(&quot;unknown error&quot;)
    }
  }
}
</code></pre><!-- raw HTML omitted -->
<p>直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。</p>
<pre tabindex="0"><code>go
// package foo

type errNotFound struct {
  file string
}

func (e errNotFound) Error() string {
  return fmt.Sprintf(&quot;file %q not found&quot;, e.file)
}

func IsNotFoundError(err error) bool {
  _, ok := err.(errNotFound)
  return ok
}

func Open(file string) error {
  return errNotFound{file: file}
}

// package bar

if err := foo.Open(&quot;foo&quot;); err != nil {
  if foo.IsNotFoundError(err) {
    // handle
  } else {
    panic(&quot;unknown error&quot;)
  }
}
</code></pre><!-- raw HTML omitted -->
<h3 id="错误包装-error-wrapping">错误包装 (Error Wrapping)</h3>
<p>一个（函数/方法）调用失败时，有三种主要的错误传播方式：</p>
<ul>
<li>如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。</li>
<li>添加上下文，使用 [<code>&quot;pkg/errors&quot;.Wrap</code>] 以便错误消息提供更多上下文 ,<a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>&quot;pkg/errors&quot;.Cause</code></a> 可用于提取原始错误。</li>
<li>如果调用者不需要检测或处理的特定错误情况，使用 [<code>fmt.Errorf</code>]。</li>
</ul>
<p>建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。</p>
<p>在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        &quot;failed to create new store: %v&quot;, err)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        &quot;new store: %v&quot;, err)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>failed to x: failed to y: failed to create new store: the error
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>x: y: new store: the error
</code></pre><!-- raw HTML omitted -->
<p>但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用<code>err</code>标记，或在日志中以”Failed”为前缀）。</p>
<p>另请参见 [Don&rsquo;t just check errors, handle them gracefully]. 不要只是检查错误，要优雅地处理错误</p>
<p>godoc.org/github.com/pkg/errors#Cause
[Don&rsquo;t just check errors, handle them gracefully]: <a class="link" href="https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully"  target="_blank" rel="noopener"
    >https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully</a></p>
<h3 id="处理类型断言失败">处理类型断言失败</h3>
<p><a class="link" href="https://"  target="_blank" rel="noopener"
    >type assertion</a> 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。</p>
<p>golang.org/ref/spec#Type_assertions</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
t := i.(string)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
t, ok := i.(string)
if !ok {
  // 优雅地处理错误
}
</code></pre><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="不要-panic">不要 panic</h3>
<p>在生产环境中运行的代码必须避免出现 panic。panic 是 <a class="link" href="https://en.wikipedia.org/wiki/Cascading_failure"  target="_blank" rel="noopener"
    >cascading failures</a> 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func run(args []string) {
  if len(args) == 0 {
    panic(&quot;an argument is required&quot;)
  }
  // ...
}

func main() {
  run(os.Args[1:])
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func run(args []string) error {
  if len(args) == 0 {
    return errors.New(&quot;an argument is required&quot;)
  }
  // ...
  return nil
}

func main() {
  if err := run(os.Args[1:]); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
</code></pre><!-- raw HTML omitted -->
<p>panic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。</p>
<pre tabindex="0"><code>go
var _statusTemplate = template.Must(template.New(&quot;name&quot;).Parse(&quot;_statusHTML&quot;))
</code></pre><p>即使在测试代码中，也优先使用<code>t.Fatal</code>或者<code>t.FailNow</code>而不是 panic 来确保失败被标记。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// func TestFoo(t *testing.T)

f, err := ioutil.TempFile(&quot;&quot;, &quot;test&quot;)
if err != nil {
  panic(&quot;failed to set up test&quot;)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// func TestFoo(t *testing.T)

f, err := ioutil.TempFile(&quot;&quot;, &quot;test&quot;)
if err != nil {
  t.Fatal(&quot;failed to set up test&quot;)
}
</code></pre><!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h3 id="使用">使用</h3>
<p>go.uber.org/atomic</p>
<p>使用 [sync/atomic] 包的原子操作对原始类型 (<code>int32</code>, <code>int64</code>等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。</p>
<p><a class="link" href="https://"  target="_blank" rel="noopener"
    >
go.uber.org/atomic</a> 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的<code>atomic.Bool</code>类型。</p>
<p>godoc.org/
go.uber.org/atomic
[sync/atomic]: https://
golang.org/pkg/sync/atomic/</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type foo struct {
  running int32  // atomic
}

func (f* foo) start() {
  if atomic.SwapInt32(&amp;f.running, 1) == 1 {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running == 1  // race!
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type foo struct {
  running atomic.Bool
}

func (f *foo) start() {
  if f.running.Swap(true) {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running.Load()
}
</code></pre><!-- raw HTML omitted -->
<h3 id="避免可变全局变量">避免可变全局变量</h3>
<p>使用选择依赖注入方式避免改变全局变量。
既适用于函数指针又适用于其他值类型</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// sign.
go
var _timeNow = time.Now
func sign(msg string) string {
  now := _timeNow()
  return signWithTime(msg, now)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// sign.
go
type signer struct {
  now func() time.Time
}
func newSigner() *signer {
  return &amp;signer{
    now: time.Now,
  }
}
func (s *signer) Sign(msg string) string {
  now := s.now()
  return signWithTime(msg, now)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// sign_test.
go
func TestSign(t *testing.T) {
  oldTimeNow := _timeNow
  _timeNow = func() time.Time {
    return someFixedTime
  }
  defer func() { _timeNow = oldTimeNow }()
  assert.Equal(t, want, sign(give))
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// sign_test.
go
func TestSigner(t *testing.T) {
  s := newSigner()
  s.now = func() time.Time {
    return someFixedTime
  }
  assert.Equal(t, want, s.Sign(give))
}
</code></pre><!-- raw HTML omitted -->
<h3 id="避免在公共结构中嵌入类型">避免在公共结构中嵌入类型</h3>
<p>这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。</p>
<p>假设您使用共享的 <code>AbstractList</code> 实现了多种列表类型，请避免在具体的列表实现中嵌入 <code>AbstractList</code>。
相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。</p>
<pre tabindex="0"><code>go
type AbstractList struct {}
// 添加将实体添加到列表中。
func (l *AbstractList) Add(e Entity) {
  // ...
}
// 移除从列表中移除实体。
func (l *AbstractList) Remove(e Entity) {
  // ...
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  *AbstractList
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  list *AbstractList
}
// 添加将实体添加到列表中。
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}
// 移除从列表中移除实体。
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
</code></pre><!-- raw HTML omitted -->
<p>go 允许 <a class="link" href="https://"  target="_blank" rel="noopener"
    >类型嵌入</a> 作为继承和组合之间的折衷。
外部类型获取嵌入类型的方法的隐式副本。
默认情况下，这些方法委托给嵌入实例的同一方法。</p>
<p>golang.org/doc/effective_
go.html#embedding</p>
<p>结构还获得与类型同名的字段。
所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。</p>
<p>很少需要嵌入类型。
这是一种方便，可以帮助您避免编写冗长的委托方法。</p>
<p>即使嵌入兼容的抽象列表 <em>interface</em>，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// AbstractList 是各种实体列表的通用实现。
type AbstractList interface {
  Add(Entity)
  Remove(Entity)
}
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  AbstractList
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  list AbstractList
}
// 添加将实体添加到列表中。
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}
// 移除从列表中移除实体。
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
</code></pre><!-- raw HTML omitted -->
<p>无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.</p>
<ul>
<li>向嵌入式接口添加方法是一个破坏性的改变。</li>
<li>删除嵌入类型是一个破坏性的改变。</li>
<li>即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。</li>
</ul>
<p>尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。</p>
<h3 id="避免使用内置名称">避免使用内置名称</h3>
<p>go语言规范<a class="link" href="https://"  target="_blank" rel="noopener"
    >language specification</a> 概述了几个内置的，
不应在
go项目中使用的名称标识[predeclared identifiers]。</p>
<p>根据上下文的不同，将这些标识符作为名称重复使用，
将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。
在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。</p>
<p>golang.org/ref/spec
[predeclared identifiers]: https://
golang.org/ref/spec#Predeclared_identifiers</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var error string
// `error` 作用域隐式覆盖

// or

func handleErrorMessage(error string) {
    // `error` 作用域隐式覆盖
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var errorMessage string
// `error` 指向内置的非覆盖

// or

func handleErrorMessage(msg string) {
    // `error` 指向内置的非覆盖
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Foo struct {
    // 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。
    error  error
    string string
}

func (f Foo) Error() error {
    // `error` 和 `f.error` 在视觉上是相似的
    return f.error
}

func (f Foo) String() string {
    // `string` and `f.string` 在视觉上是相似的
    return f.string
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Foo struct {
    // `error` and `string` 现在是明确的。
    err error
    str string
}

func (f Foo) Error() error {
    return f.err
}

func (f Foo) String() string {
    return f.str
}
</code></pre><!-- raw HTML omitted -->
<p>注意，编译器在使用预先分隔的标识符时不会生成错误，
但是诸如<code> go vet</code>之类的工具会正确地指出这些和其他情况下的隐式问题。</p>
<h3 id="避免使用-init">避免使用 <code>init()</code></h3>
<p>尽可能避免使用<code>init()</code>。当<code>init()</code>是不可避免或可取的，代码应先尝试：</p>
<ol>
<li>无论程序环境或调用如何，都要完全确定。</li>
<li>避免依赖于其他<code>init()</code>函数的顺序或副作用。虽然<code>init()</code>顺序是明确的，但代码可以更改，
因此<code>init()</code>函数之间的关系可能会使代码变得脆弱和容易出错。</li>
<li>避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。</li>
<li>避免<code>I/O</code>，包括文件系统、网络和系统调用。</li>
</ol>
<p>不能满足这些要求的代码可能属于要作为<code>main()</code>调用的一部分（或程序生命周期中的其他地方），
或者作为<code>main()</code>本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，
而不是执行“init magic”</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Foo struct {
    // ...
}
var _defaultFoo Foo
func init() {
    _defaultFoo = Foo{
        // ...
    }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var _defaultFoo = Foo{
    // ...
}
// or, 为了更好的可测试性:
var _defaultFoo = defaultFoo()
func defaultFoo() Foo {
    return Foo{
        // ...
    }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Config struct {
    // ...
}
var _config Config
func init() {
    // Bad: 基于当前目录
    cwd, _ := os.Getwd()
    // Bad: I/O
    raw, _ := ioutil.ReadFile(
        path.Join(cwd, &quot;config&quot;, &quot;config.yaml&quot;),
    )
    yaml.Unmarshal(raw, &amp;_config)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Config struct {
    // ...
}
func loadConfig() Config {
    cwd, err := os.Getwd()
    // handle err
    raw, err := ioutil.ReadFile(
        path.Join(cwd, &quot;config&quot;, &quot;config.yaml&quot;),
    )
    // handle err
    var config Config
    yaml.Unmarshal(raw, &amp;config)
    return config
}
</code></pre><!-- raw HTML omitted -->
<p>考虑到上述情况，在某些情况下，<code>init()</code>可能更可取或是必要的，可能包括：</p>
<ul>
<li>
<p>不能表示为单个赋值的复杂表达式。</p>
</li>
<li>
<p>可插入的钩子，如<code>database/sql</code>、编码类型注册表等。</p>
</li>
<li>
<p>对<a class="link" href="https://cloud."  target="_blank" rel="noopener"
    >
google Cloud Functions</a>和其他形式的确定性预计算的优化。</p>
<p>google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations</p>
</li>
</ul>
<h3 id="追加时优先指定切片容量">追加时优先指定切片容量</h3>
<p>追加时优先指定切片容量</p>
<p>在尽可能的情况下，在初始化要追加的切片时为<code>make()</code>提供一个容量值。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for n := 0; n &lt; b.N; n++ {
  data := make([]int, 0)
  for k := 0; k &lt; size; k++{
    data = append(data, k)
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for n := 0; n &lt; b.N; n++ {
  data := make([]int, 0, size)
  for k := 0; k &lt; size; k++{
    data = append(data, k)
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>BenchmarkBad-4    100000000    2.48s
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>Benchmark
good-4   100000000    0.21s
</code></pre><!-- raw HTML omitted -->
<h3 id="主函数退出方式exit">主函数退出方式(Exit)</h3>
<p>go程序使用<a class="link" href="https://"  target="_blank" rel="noopener"
    ><code>os.Exit</code></a> 或者 [<code>log.Fatal*</code>] 立即退出 (使用<code>panic</code>不是退出程序的好方法，请 <a class="link" href="#%e4%b8%8d%e8%a6%81-panic" >don&rsquo;t panic</a>.)</p>
<p>golang.org/pkg/os/#Exit
[<code>log.Fatal*</code>]: https://
golang.org/pkg/log/#Fatal</p>
<p>**仅在<code>main（）</code>**中调用其中一个 <code>os.Exit</code> 或者 <code>log.Fatal*</code>。所有其他函数应将错误返回到信号失败中。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func main() {
  body := readFile(path)
  fmt.Println(body)
}
func readFile(path string) string {
  f, err := os.Open(path)
  if err != nil {
    log.Fatal(err)
  }
  b, err := ioutil.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }
  return string(b)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func main() {
  body, err := readFile(path)
  if err != nil {
    log.Fatal(err)
  }
  fmt.Println(body)
}
func readFile(path string) (string, error) {
  f, err := os.Open(path)
  if err != nil {
    return &quot;&quot;, err
  }
  b, err := ioutil.ReadAll(f)
  if err != nil {
    return &quot;&quot;, err
  }
  return string(b), nil
}
</code></pre><!-- raw HTML omitted -->
<p>原则上：退出的具有多种功能的程序存在一些问题：</p>
<ul>
<li>不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。</li>
<li>难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 <code> go test</code> 尚未运行的其他测试的风险。</li>
<li>跳过清理：当函数退出程序时，会跳过已经进入<code>defer</code>队列里的函数调用。这增加了跳过重要清理任务的风险。</li>
</ul>
<h4 id="一次性退出">一次性退出</h4>
<p>如果可能的话，你的<code>main（）</code>函数中<strong>最多一次</strong> 调用 <code>os.Exit</code>或者<code>log.Fatal</code>。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。
这会缩短 <code>main()</code>函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
package main
func main() {
  args := os.Args[1:]
  if len(args) != 1 {
    log.Fatal(&quot;missing file&quot;)
  }
  name := args[0]
  f, err := os.Open(name)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()
  // 如果我们调用log.Fatal 在这条线之后
  // f.Close 将会被执行.
  b, err := ioutil.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }
  // ...
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
package main
func main() {
  if err := run(); err != nil {
    log.Fatal(err)
  }
}
func run() error {
  args := os.Args[1:]
  if len(args) != 1 {
    return errors.New(&quot;missing file&quot;)
  }
  name := args[0]
  f, err := os.Open(name)
  if err != nil {
    return err
  }
  defer f.Close()
  b, err := ioutil.ReadAll(f)
  if err != nil {
    return err
  }
  // ...
}
</code></pre><!-- raw HTML omitted -->
<h2 id="性能">性能</h2>
<p>性能方面的特定准则只适用于高频场景。</p>
<h3 id="优先使用-strconv-而不是-fmt">优先使用 strconv 而不是 fmt</h3>
<p>将原语转换为字符串或从字符串转换时，<code>strconv</code>速度比<code>fmt</code>快。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for i := 0; i &lt; b.N; i++ {
  s := fmt.Sprint(rand.Int())
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for i := 0; i &lt; b.N; i++ {
  s := strconv.Itoa(rand.Int())
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>BenchmarkFmtSprint-4    143 ns/op    2 allocs/op
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
</code></pre><!-- raw HTML omitted -->
<h3 id="避免字符串到字节的转换">避免字符串到字节的转换</h3>
<p>不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for i := 0; i &lt; b.N; i++ {
  w.Write([]byte(&quot;Hello world&quot;))
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
data := []byte(&quot;Hello world&quot;)
for i := 0; i &lt; b.N; i++ {
  w.Write(data)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>BenchmarkBad-4   50000000   22.2 ns/op
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>Benchmark
good-4  500000000   3.25 ns/op
</code></pre><!-- raw HTML omitted -->
<h3 id="指定容器容量">指定容器容量</h3>
<p>尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。</p>
<h4 id="指定map容量提示">指定Map容量提示</h4>
<p>在尽可能的情况下，在使用 <code>make()</code> 初始化的时候提供容量信息</p>
<pre tabindex="0"><code>go
make(map[T1]T2, hint)
</code></pre><p>向<code>make()</code>提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。</p>
<p>注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。
因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
m := make(map[string]os.FileInfo)

files, _ := ioutil.ReadDir(&quot;./files&quot;)
for _, f := range files {
    m[f.Name()] = f
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go

files, _ := ioutil.ReadDir(&quot;./files&quot;)

m := make(map[string]os.FileInfo, len(files))
for _, f := range files {
    m[f.Name()] = f
}
</code></pre><!-- raw HTML omitted -->
<p><code>m</code> 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。</p>
<!-- raw HTML omitted -->
<p><code>m</code> 是有大小提示创建的；在运行时可能会有更少的分配。</p>
<!-- raw HTML omitted -->
<h4 id="指定切片容量">指定切片容量</h4>
<p>在尽可能的情况下，在使用<code>make()</code>初始化切片时提供容量信息，特别是在追加切片时。</p>
<pre tabindex="0"><code>go
make([]T, length, capacity)
</code></pre><p>与maps不同，slice capacity不是一个提示：编译器将为提供给<code>make()</code>的slice的容量分配足够的内存，
这意味着后续的append()`操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for n := 0; n &lt; b.N; n++ {
  data := make([]int, 0)
  for k := 0; k &lt; size; k++{
    data = append(data, k)
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for n := 0; n &lt; b.N; n++ {
  data := make([]int, 0, size)
  for k := 0; k &lt; size; k++{
    data = append(data, k)
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>BenchmarkBad-4    100000000    2.48s
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>Benchmark
good-4   100000000    0.21s
</code></pre><!-- raw HTML omitted -->
<h2 id="规范">规范</h2>
<h3 id="一致性">一致性</h3>
<p>本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；</p>
<p>但是最重要的是，<strong>保持一致</strong>.</p>
<p>一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug</p>
<p>相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。</p>
<p>将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。</p>
<h3 id="相似的声明放在一组">相似的声明放在一组</h3>
<p>go 语言支持将相似的声明放在一个组内。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
import &quot;a&quot;
import &quot;b&quot;
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
import (
  &quot;a&quot;
  &quot;b&quot;
)
</code></pre><!-- raw HTML omitted -->
<p>这同样适用于常量、变量和类型声明：</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go

const a = 1
const b = 2

var a = 1
var b = 2

type Area float64
type Volume float64
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
const (
  a = 1
  b = 2
)

var (
  a = 1
  b = 2
)

type (
  Area float64
  Volume float64
)
</code></pre><!-- raw HTML omitted -->
<p>仅将相关的声明放在一组。不要将不相关的声明放在一组。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
  EnvVar = &quot;MY_ENV&quot;
)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
)

const EnvVar = &quot;MY_ENV&quot;
</code></pre><!-- raw HTML omitted -->
<p>分组使用的位置没有限制，例如：你可以在函数内部使用它们：</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func f() string {
  var red = color.New(0xff0000)
  var green = color.New(0x00ff00)
  var blue = color.New(0x0000ff)

  ...
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func f() string {
  var (
    red   = color.New(0xff0000)
    green = color.New(0x00ff00)
    blue  = color.New(0x0000ff)
  )

  ...
}
</code></pre><!-- raw HTML omitted -->
<h3 id="import-分组">import 分组</h3>
<p>导入应该分为两组：</p>
<ul>
<li>标准库</li>
<li>其他库</li>
</ul>
<p>默认情况下，这是
goimports 应用的分组。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;
go.uber.org/atomic&quot;
  &quot;
golang.org/x/sync/errgroup&quot;
)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
import (
  &quot;fmt&quot;
  &quot;os&quot;

  &quot;
go.uber.org/atomic&quot;
  &quot;
golang.org/x/sync/errgroup&quot;
)
</code></pre><!-- raw HTML omitted -->
<h3 id="包名">包名</h3>
<p>当命名包时，请按下面规则选择一个名称：</p>
<ul>
<li>全部小写。没有大写或下划线。</li>
<li>大多数使用命名导入的情况下，不需要重命名。</li>
<li>简短而简洁。请记住，在每个使用的地方都完整标识了该名称。</li>
<li>不用复数。例如<code>net/url</code>，而不是<code>net/urls</code>。</li>
<li>不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。</li>
</ul>
<p>另请参阅 <a class="link" href="https://blog."  target="_blank" rel="noopener"
    >Package Names</a> 和 [
go 包样式指南].</p>
<p>golang.org/package-names
[
go 包样式指南]: <a class="link" href="https://rakyll.org/style-packages/"  target="_blank" rel="noopener"
    >https://rakyll.org/style-packages/</a></p>
<h3 id="函数名">函数名</h3>
<p>我们遵循
go 社区关于使用 <a class="link" href="https://"  target="_blank" rel="noopener"
    >MixedCaps 作为函数名</a> 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：<code>TestMyFunction_WhatIsBeingTested</code>.</p>
<p>golang.org/doc/effective_
go.html#mixed-caps</p>
<h3 id="导入别名">导入别名</h3>
<p>如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。</p>
<pre tabindex="0"><code>go
import (
  &quot;net/http&quot;

  client &quot;example.com/client-
go&quot;
  trace &quot;example.com/trace/v2&quot;
)
</code></pre><p>在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
import (
  &quot;fmt&quot;
  &quot;os&quot;

  nettrace &quot;
golang.net/x/trace&quot;
)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
import (
  &quot;fmt&quot;
  &quot;os&quot;
  &quot;runtime/trace&quot;

  nettrace &quot;
golang.net/x/trace&quot;
)
</code></pre><!-- raw HTML omitted -->
<h3 id="函数分组与顺序">函数分组与顺序</h3>
<ul>
<li>函数应按粗略的调用顺序排序。</li>
<li>同一文件中的函数应按接收者分组。</li>
</ul>
<p>因此，导出的函数应先出现在文件中，放在<code>struct</code>, <code>const</code>, <code>var</code>定义的后面。</p>
<p>在定义类型之后，但在接收者的其余方法之前，可能会出现一个 <code>newXYZ()</code>/<code>NewXYZ()</code></p>
<p>由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func (s *something) Cost() {
  return calcCost(s.weights)
}

type something struct{ ... }

func calcCost(n []int) int {...}

func (s *something) Stop() {...}

func newSomething() *something {
    return &amp;something{}
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type something struct{ ... }

func newSomething() *something {
    return &amp;something{}
}

func (s *something) Cost() {
  return calcCost(s.weights)
}

func (s *something) Stop() {...}

func calcCost(n []int) int {...}
</code></pre><!-- raw HTML omitted -->
<h3 id="减少嵌套">减少嵌套</h3>
<p>代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for _, v := range data {
  if v.F1 == 1 {
    v = process(v)
    if err := v.Call(); err == nil {
      v.Send()
    } else {
      return err
    }
  } else {
    log.Printf(&quot;Invalid v: %v&quot;, v)
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
for _, v := range data {
  if v.F1 != 1 {
    log.Printf(&quot;Invalid v: %v&quot;, v)
    continue
  }

  v = process(v)
  if err := v.Call(); err != nil {
    return err
  }
  v.Send()
}
</code></pre><!-- raw HTML omitted -->
<h3 id="不必要的-else">不必要的 else</h3>
<p>如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var a int
if b {
  a = 100
} else {
  a = 10
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
a := 10
if b {
  a = 100
}
</code></pre><!-- raw HTML omitted -->
<h3 id="顶层变量声明">顶层变量声明</h3>
<p>在顶层，使用标准<code>var</code>关键字。请勿指定类型，除非它与表达式的类型不同。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var _s string = F()

func F() string { return &quot;A&quot; }
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var _s = F()
// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型
// 还是那种类型

func F() string { return &quot;A&quot; }
</code></pre><!-- raw HTML omitted -->
<p>如果表达式的类型与所需的类型不完全匹配，请指定类型。</p>
<pre tabindex="0"><code>go
type myError struct{}

func (myError) Error() string { return &quot;error&quot; }

func F() myError { return myError{} }

var _e error = F()
// F 返回一个 myError 类型的实例，但是我们要 error 类型
</code></pre><h3 id="对于未导出的顶层常量和变量使用_作为前缀">对于未导出的顶层常量和变量，使用_作为前缀</h3>
<p>在未导出的顶级<code>vars</code>和<code>consts</code>， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。</p>
<p>例外：未导出的错误值，应以<code>err</code>开头。</p>
<p>基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// foo.
go

const (
  defaultPort = 8080
  defaultUser = &quot;user&quot;
)

// bar.
go

func Bar() {
  defaultPort := 9090
  ...
  fmt.Println(&quot;Default port&quot;, defaultPort)

  // We will not see a compile error if the first line of
  // Bar() is deleted.
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// foo.
go

const (
  _defaultPort = 8080
  _defaultUser = &quot;user&quot;
)
</code></pre><!-- raw HTML omitted -->
<h3 id="结构体中的嵌入">结构体中的嵌入</h3>
<p>嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Client struct {
  version int
  http.Client
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Client struct {
  http.Client

  version int
}
</code></pre><!-- raw HTML omitted -->
<p>内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。
它应该在对用户不利影响的情况下完成这项工作（另请参见：<code>避免在公共结构中嵌入类型</code><a class="link" href="#avoid-embedding-types-in-public-structs" >Avoid Embedding Types in Public Structs</a>）。</p>
<p>嵌入 <strong>不应该</strong>:</p>
<ul>
<li>纯粹是为了美观或方便。</li>
<li>使外部类型更难构造或使用。</li>
<li>影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。</li>
<li>作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。</li>
<li>公开未导出的类型。</li>
<li>影响外部类型的复制形式。</li>
<li>更改外部类型的API或类型语义。</li>
<li>嵌入内部类型的非规范形式。</li>
<li>公开外部类型的实现详细信息。</li>
<li>允许用户观察或控制类型内部。</li>
<li>通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。</li>
</ul>
<p>简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，
&ldquo;是否所有这些导出的内部方法/字段都将直接添加到外部类型&rdquo;
如果答案是<code>some</code>或<code>no</code>，不要嵌入内部类型-而是使用字段。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type A struct {
    // Bad: A.Lock() and A.Unlock() 现在可用
    // 不提供任何功能性好处，并允许用户控制有关A的内部细节。
    sync.Mutex
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type countingWriteCloser struct {
    // 
good: Write() 在外层提供用于特定目的，
    // 并且委托工作到内部类型的Write()中。
    io.WriteCloser
    count int
}
func (w *countingWriteCloser) Write(bs []byte) (int, error) {
    w.count += len(bs)
    return w.WriteCloser.Write(bs)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Book struct {
    // Bad: 指针更改零值的有用性
    io.ReadWriter
    // other fields
}
// later
var b Book
b.Read(...)  // panic: nil pointer
b.String()   // panic: nil pointer
b.Write(...) // panic: nil pointer
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Book struct {
    // 
good: 有用的零值
    bytes.Buffer
    // other fields
}
// later
var b Book
b.Read(...)  // ok
b.String()   // ok
b.Write(...) // ok
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Client struct {
    sync.Mutex
    sync.WaitGroup
    bytes.Buffer
    url.URL
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
type Client struct {
    mtx sync.Mutex
    wg  sync.WaitGroup
    buf bytes.Buffer
    url url.URL
}
</code></pre><!-- raw HTML omitted -->
<h3 id="使用字段名初始化结构体">使用字段名初始化结构体</h3>
<p>初始化结构体时，应该指定字段名称。现在由 <a class="link" href="https://"  target="_blank" rel="noopener"
    ><code> go vet</code></a> 强制执行。</p>
<p>golang.org/cmd/vet/</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
k := User{&quot;John&quot;, &quot;Doe&quot;, true}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
k := User{
    FirstName: &quot;John&quot;,
    LastName: &quot;Doe&quot;,
    Admin: true,
}
</code></pre><!-- raw HTML omitted -->
<p>例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。</p>
<pre tabindex="0"><code>go
tests := []struct{
  op Operation
  want string
}{
  {Add, &quot;add&quot;},
  {Subtract, &quot;subtract&quot;},
}
</code></pre><h3 id="本地变量声明">本地变量声明</h3>
<p>如果将变量明确设置为某个值，则应使用短变量声明形式 (<code>:=</code>)。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var s = &quot;foo&quot;
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
s := &quot;foo&quot;
</code></pre><!-- raw HTML omitted -->
<p>但是，在某些情况下，<code>var</code> 使用关键字时默认值会更清晰。例如，声明空切片。</p>
<p>golang/
go/wiki/CodeReviewComments#declaring-empty-slices</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func f(list []int) {
  filtered := []int{}
  for _, v := range list {
    if v &gt; 10 {
      filtered = append(filtered, v)
    }
  }
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func f(list []int) {
  var filtered []int
  for _, v := range list {
    if v &gt; 10 {
      filtered = append(filtered, v)
    }
  }
}
</code></pre><!-- raw HTML omitted -->
<h3 id="nil-是一个有效的-slice">nil 是一个有效的 slice</h3>
<p><code>nil</code> 是一个有效的长度为 0 的 slice，这意味着，</p>
<ul>
<li>
<p>您不应明确返回长度为零的切片。应该返回<code>nil</code> 来代替。</p>
<!-- raw HTML omitted -->
</li>
</ul>
<p>good<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
if x == &quot;&quot; {
  return []int{}
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
if x == &quot;&quot; {
  return nil
}
</code></pre><!-- raw HTML omitted -->
<ul>
<li>
<p>要检查切片是否为空，请始终使用<code>len(s) == 0</code>。而非 <code>nil</code>。</p>
<!-- raw HTML omitted -->
</li>
</ul>
<p>good<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func isEmpty(s []string) bool {
  return s == nil
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
func isEmpty(s []string) bool {
  return len(s) == 0
}
</code></pre><!-- raw HTML omitted -->
<ul>
<li>
<p>零值切片（用<code>var</code>声明的切片）可立即使用，无需调用<code>make()</code>创建。</p>
<!-- raw HTML omitted -->
</li>
</ul>
<p>good<!-- raw HTML omitted --><!-- raw HTML omitted --><!-- raw HTML omitted --></p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
nums := []int{}
// or, nums := make([]int)

if add1 {
  nums = append(nums, 1)
}

if add2 {
  nums = append(nums, 2)
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var nums []int

if add1 {
  nums = append(nums, 1)
}

if add2 {
  nums = append(nums, 2)
}
</code></pre><!-- raw HTML omitted -->
<p>记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。</p>
<h3 id="缩小变量作用域">缩小变量作用域</h3>
<p>如果有可能，尽量缩小变量作用范围。除非它与 <a class="link" href="#%e5%87%8f%e5%b0%91%e5%b5%8c%e5%a5%97" >减少嵌套</a>的规则冲突。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
err := ioutil.WriteFile(name, data, 0644)
if err != nil {
 return err
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
if err := ioutil.WriteFile(name, data, 0644); err != nil {
 return err
}
</code></pre><!-- raw HTML omitted -->
<p>如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
if data, err := ioutil.ReadFile(name); err == nil {
  err = cfg.Decode(data)
  if err != nil {
    return err
  }

  fmt.Println(cfg)
  return nil
} else {
  return err
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
data, err := ioutil.ReadFile(name)
if err != nil {
   return err
}

if err := cfg.Decode(data); err != nil {
  return err
}

fmt.Println(cfg)
return nil
</code></pre><!-- raw HTML omitted -->
<h3 id="避免参数语义不明确avoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)</h3>
<p>函数调用中的<code>意义不明确的参数</code>可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (<code>/* ... */</code>)</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// func printInfo(name string, isLocal, done bool)

printInfo(&quot;foo&quot;, true, true)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// func printInfo(name string, isLocal, done bool)

printInfo(&quot;foo&quot;, true /* isLocal */, true /* done */)
</code></pre><!-- raw HTML omitted -->
<p>对于上面的示例代码，还有一种更好的处理方式是将上面的 <code>bool</code> 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。</p>
<pre tabindex="0"><code>go
type Region int

const (
  UnknownRegion Region = iota
  Local
)

type Status int

const (
  StatusReady Status= iota + 1
  StatusDone
  // Maybe we will have a StatusInProgress in the future.
)

func printInfo(name string, region Region, status Status)
</code></pre><h3 id="使用原始字符串字面值避免转义">使用原始字符串字面值，避免转义</h3>
<p>go 支持使用 [原始字符串字面值](https://
golang.org/ref/spec#raw_string_lit)，也就是 &quot; ` &quot; 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。</p>
<p>可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
wantError := &quot;unknown name:\&quot;test\&quot;&quot;
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
wantError := `unknown error:&quot;test&quot;`
</code></pre><!-- raw HTML omitted -->
<h3 id="初始化结构体">初始化结构体</h3>
<h4 id="使用字段名初始化结构">使用字段名初始化结构</h4>
<p>初始化结构时，几乎应该始终指定字段名。目前由<a class="link" href="https://"  target="_blank" rel="noopener"
    ><code> go vet</code></a>强制执行。</p>
<p>golang.org/cmd/vet/</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
k := User{&quot;John&quot;, &quot;Doe&quot;, true}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
k := User{
    FirstName: &quot;John&quot;,
    LastName: &quot;Doe&quot;,
    Admin: true,
}
</code></pre><!-- raw HTML omitted -->
<p>例外：当有3个或更少的字段时，测试表中的字段名<em>may</em>可以省略。</p>
<pre tabindex="0"><code>go
tests := []struct{
  op Operation
  want string
}{
  {Add, &quot;add&quot;},
  {Subtract, &quot;subtract&quot;},
}
</code></pre><h4 id="省略结构中的零值字段">省略结构中的零值字段</h4>
<p>初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零的字段。
也就是，让我们自动将这些设置为零值</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
user := User{
  FirstName: &quot;John&quot;,
  LastName: &quot;Doe&quot;,
  MiddleName: &quot;&quot;,
  Admin: false,
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
user := User{
  FirstName: &quot;John&quot;,
  LastName: &quot;Doe&quot;,
}
</code></pre><!-- raw HTML omitted -->
<p>这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。</p>
<p>在字段名提供有意义上下文的地方包含零值。例如，<a class="link" href="#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95" >表驱动测试</a> 中的测试用例可以受益于字段的名称，即使它们是零值的。</p>
<pre tabindex="0"><code>go
tests := []struct{
  give string
  want int
}{
  {give: &quot;0&quot;, want: 0},
  // ...
}
</code></pre><h4 id="对零值结构使用-var">对零值结构使用 <code>var</code></h4>
<p>如果在声明中省略了结构的所有字段，请使用 <code>var</code> 声明结构。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
user := User{}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var user User
</code></pre><!-- raw HTML omitted -->
<p>这将零值结构与那些具有类似于为[初始化 Maps]创建的,区别于非零值字段的结构区分开来，
并与我们更喜欢的<a class="link" href="https://github.com/"  target="_blank" rel="noopener"
    >declare empty slices</a>方式相匹配。</p>
<h4 id="初始化-struct-引用">初始化 Struct 引用</h4>
<p>在初始化结构引用时，请使用<code>&amp;T{}</code>代替<code>new(T)</code>，以使其与结构体初始化一致。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
sval := T{Name: &quot;foo&quot;}

// inconsistent
sptr := new(T)
sptr.Name = &quot;bar&quot;
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
sval := T{Name: &quot;foo&quot;}

sptr := &amp;T{Name: &quot;bar&quot;}
</code></pre><!-- raw HTML omitted -->
<h3 id="初始化-maps">初始化 Maps</h3>
<p>对于空 map 请使用 <code>make(..)</code> 初始化， 并且 map 是通过编程方式填充的。
这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var (
  // m1 读写安全;
  // m2 在写入时会 panic
  m1 = map[T1]T2{}
  m2 map[T1]T2
)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
var (
  // m1 读写安全;
  // m2 在写入时会 panic
  m1 = make(map[T1]T2)
  m2 map[T1]T2
)
</code></pre><!-- raw HTML omitted -->
<p>声明和初始化看起来非常相似的。</p>
<!-- raw HTML omitted -->
<p>声明和初始化看起来差别非常大。</p>
<!-- raw HTML omitted -->
<p>在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 <a class="link" href="#%e6%8c%87%e5%ae%9aMap%e5%ae%b9%e9%87%8f%e6%8f%90%e7%a4%ba" >指定Map容量提示</a>。</p>
<p>另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
m := make(map[T1]T2, 3)
m[k1] = v1
m[k2] = v2
m[k3] = v3
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
m := map[T1]T2{
  k1: v1,
  k2: v2,
  k3: v3,
}
</code></pre><!-- raw HTML omitted -->
<p>基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 <code>make</code> (如果可以，请尽量指定 map 容量)。</p>
<h3 id="字符串-string-format">字符串 string format</h3>
<p>如果你在函数外声明<code>Printf</code>-style 函数的格式字符串，请将其设置为<code>const</code>常量。</p>
<p>这有助于<code> go vet</code>对格式字符串执行静态分析。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
msg := &quot;unexpected values %v, %v\n&quot;
fmt.Printf(msg, 1, 2)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
const msg = &quot;unexpected values %v, %v\n&quot;
fmt.Printf(msg, 1, 2)
</code></pre><!-- raw HTML omitted -->
<h3 id="命名-printf-样式的函数">命名 Printf 样式的函数</h3>
<p>声明<code>Printf</code>-style 函数时，请确保<code> go vet</code>可以检测到它并检查格式字符串。</p>
<p>这意味着您应尽可能使用预定义的<code>Printf</code>-style 函数名称。<code> go vet</code>将默认检查这些。有关更多信息，请参见 <a class="link" href="https://"  target="_blank" rel="noopener"
    >Printf 系列</a>。</p>
<p>golang.org/cmd/vet/#hdr-Printf_family</p>
<p>如果不能使用预定义的名称，请以 f 结束选择的名称：<code>Wrapf</code>，而不是<code>Wrap</code>。<code> go vet</code>可以要求检查特定的 Printf 样式名称，但名称必须以<code>f</code>结尾。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell">$ 
go vet -printfuncs<span class="o">=</span>wrapf,statusf
</code></pre></div><p>另请参阅 <a class="link" href="https://kuzminva.wordpress.com/2017/11/07/"  target="_blank" rel="noopener"
    >
go vet: Printf family check</a>.</p>
<p>go-vet-printf-family-check/</p>
<h2 id="编程模式">编程模式</h2>
<h3 id="表驱动测试">表驱动测试</h3>
<p>当测试逻辑是重复的时候，通过  <a class="link" href="https://blog."  target="_blank" rel="noopener"
    >subtests</a> 使用 table 驱动的方式编写 case 代码看上去会更简洁。</p>
<p>golang.org/subtests</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// func TestSplitHostPort(t *testing.T)

host, port, err := net.SplitHostPort(&quot;192.0.2.0:8000&quot;)
require.NoError(t, err)
assert.Equal(t, &quot;192.0.2.0&quot;, host)
assert.Equal(t, &quot;8000&quot;, port)

host, port, err = net.SplitHostPort(&quot;192.0.2.0:http&quot;)
require.NoError(t, err)
assert.Equal(t, &quot;192.0.2.0&quot;, host)
assert.Equal(t, &quot;http&quot;, port)

host, port, err = net.SplitHostPort(&quot;:8000&quot;)
require.NoError(t, err)
assert.Equal(t, &quot;&quot;, host)
assert.Equal(t, &quot;8000&quot;, port)

host, port, err = net.SplitHostPort(&quot;1:8&quot;)
require.NoError(t, err)
assert.Equal(t, &quot;1&quot;, host)
assert.Equal(t, &quot;8&quot;, port)
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// func TestSplitHostPort(t *testing.T)

tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  {
    give:     &quot;192.0.2.0:8000&quot;,
    wantHost: &quot;192.0.2.0&quot;,
    wantPort: &quot;8000&quot;,
  },
  {
    give:     &quot;192.0.2.0:http&quot;,
    wantHost: &quot;192.0.2.0&quot;,
    wantPort: &quot;http&quot;,
  },
  {
    give:     &quot;:8000&quot;,
    wantHost: &quot;&quot;,
    wantPort: &quot;8000&quot;,
  },
  {
    give:     &quot;1:8&quot;,
    wantHost: &quot;1&quot;,
    wantPort: &quot;8&quot;,
  },
}

for _, tt := range tests {
  t.Run(tt.give, func(t *testing.T) {
    host, port, err := net.SplitHostPort(tt.give)
    require.NoError(t, err)
    assert.Equal(t, tt.wantHost, host)
    assert.Equal(t, tt.wantPort, port)
  })
}
</code></pre><!-- raw HTML omitted -->
<p>很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。</p>
<p>我们遵循这样的约定：将结构体切片称为<code>tests</code>。 每个测试用例称为<code>tt</code>。此外，我们鼓励使用<code>give</code>和<code>want</code>前缀说明每个测试用例的输入和输出值。</p>
<pre tabindex="0"><code>go
tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  // ...
}

for _, tt := range tests {
  // ...
}
</code></pre><h3 id="功能选项">功能选项</h3>
<p>功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。</p>
<p>将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。</p>
<!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// package db

func Open(
  addr string,
  cache bool,
  logger *zap.Logger
) (*Connection, error) {
  // ...
}
</code></pre><!-- raw HTML omitted -->
<pre tabindex="0"><code>go
// package db

type Option interface {
  // ...
}

func WithCache(c bool) Option {
  // ...
}

func WithLogger(log *zap.Logger) Option {
  // ...
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  // ...
}
</code></pre><!-- raw HTML omitted -->
<p>必须始终提供缓存和记录器参数，即使用户希望使用默认值。</p>
<pre tabindex="0"><code>go
db.Open(addr, db.DefaultCache, zap.NewNop())
db.Open(addr, db.DefaultCache, log)
db.Open(addr, false /* cache */, zap.NewNop())
db.Open(addr, false /* cache */, log)
</code></pre><!-- raw HTML omitted -->
<p>只有在需要时才提供选项。</p>
<pre tabindex="0"><code>go
db.Open(addr)
db.Open(addr, db.WithLogger(log))
db.Open(addr, db.WithCache(false))
db.Open(
  addr,
  db.WithCache(false),
  db.WithLogger(log),
)
</code></pre><!-- raw HTML omitted -->
<p>Our suggested way of implementing this pattern is with an <code>Option</code> interface
that holds an unexported method, recording options on an unexported <code>options</code>
struct.</p>
<p>我们建议实现此模式的方法是使用一个 <code>Option</code> 接口，该接口保存一个未导出的方法，在一个未导出的 <code>options</code> 结构上记录选项。</p>
<pre tabindex="0"><code>go
type options struct {
  cache  bool
  logger *zap.Logger
}

type Option interface {
  apply(*options)
}

type cacheOption bool

func (c cacheOption) apply(opts *options) {
  opts.cache = bool(c)
}

func WithCache(c bool) Option {
  return cacheOption(c)
}

type loggerOption struct {
  Log *zap.Logger
}

func (l loggerOption) apply(opts *options) {
  opts.logger = l.Log
}

func WithLogger(log *zap.Logger) Option {
  return loggerOption{Log: log}
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  options := options{
    cache:  defaultCache,
    logger: zap.NewNop(),
  }

  for _, o := range opts {
    o.apply(&amp;options)
  }

  // ...
}
</code></pre><p>注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 <code>fmt.Stringer</code>，允许用户读取选项的字符串表示形式。</p>
<p>还可以参考下面资料：</p>
<ul>
<li>
<p><a class="link" href="https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html"  target="_blank" rel="noopener"
    >Self-referential functions and the design of options</a></p>
</li>
<li>
<p><a class="link" href="https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis"  target="_blank" rel="noopener"
    >Functional options for friendly APIs</a></p>
</li>
</ul>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<h2 id="linting">Linting</h2>
<p>比任何 &ldquo;blessed&rdquo; linter 集更重要的是，lint在一个代码库中始终保持一致。</p>
<p>我们建议至少使用以下linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：</p>
<ul>
<li>
<p><a class="link" href="https://github.com/kisielk/errcheck"  target="_blank" rel="noopener"
    >errcheck</a> 以确保错误得到处理</p>
</li>
<li>
<p><a class="link" href="https://"  target="_blank" rel="noopener"
    >
goimports</a> 格式化代码和管理 imports</p>
</li>
<li>
<p>[
golint] 指出常见的文体错误</p>
</li>
<li>
<p>[
govet] 分析代码中的常见错误</p>
</li>
<li>
<p>[staticcheck] 各种静态分析检查</p>
<p>godoc.org/
golang.org/x/tools/cmd/
goimports
[
golint]: <a class="link" href="https://github.com/"  target="_blank" rel="noopener"
    >https://github.com/</a>
golang/lint
[
govet]: https://
golang.org/cmd/vet/
[staticcheck]: <a class="link" href="https://staticcheck.io/"  target="_blank" rel="noopener"
    >https://staticcheck.io/</a></p>
</li>
</ul>
<h3 id="lint-runners">Lint Runners</h3>
<p>我们推荐 <a class="link" href="https://github.com/"  target="_blank" rel="noopener"
    >
golangci-lint</a> 作为
go-to lint的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个repo有一个示例配置文件[.
golangci.yml]和推荐的linter设置。</p>
<p>golangci-lint 有[various-linters]可供使用。建议将上述linters作为基本set，我们鼓励团队添加对他们的项目有意义的任何附加linters。</p>
<p>golangci/
golangci-lint
[.
golangci.yml]: <a class="link" href="https://github.com/uber-"  target="_blank" rel="noopener"
    >https://github.com/uber-</a>
go/guide/blob/master/.
golangci.yml
[various-linters]: https://
golangci-lint.run/usage/linters/</p>
<h2 id="stargazers-over-time">Stargazers over time</h2>
<p>[![Stargazers over time](https://starchart.cc/xxjwxc/uber_
go_guide_cn.svg)](<a class="link" href="https://starchart.cc/xxjwxc/uber_"  target="_blank" rel="noopener"
    >https://starchart.cc/xxjwxc/uber_</a>
go_guide_cn)</p>

</section>


    <footer class="article-footer">
    

    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">相关文章</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-go%E5%AE%9E%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-go%E5%AE%9E%E7%8E%B0/1.ed1f35b2a37347732ac0274cc8b2b8b7_hu627ccad35150ba5c25206c4fe774bc3e_21463_250x150_fill_box_smart1_3.png" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-7R81sqNzR3MqwCdMyLK4tw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">数据结构-AVL tree go实现</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-go%E5%AE%9E%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-go%E5%AE%9E%E7%8E%B0/1.93ea940fc2529072f0e70cb78e43eee7_hu163e0849e6d75821587eb02814146518_65785_250x150_fill_box_smart1.gif" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-k&#43;qUD8JSkHLw5wy3jkPu5w==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">数据结构-Binary search tree go实现</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E5%AE%9E%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E5%AE%9E%E7%8E%B0/1.d90a4e817af655a738f16cd6b901b471_hucc057a99640c389677e7decbd4886594_40524_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-2QpOgXr2Vac48WzWuQG0cQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">数据结构-栈(基于单项链表)&amp;&amp;队列(基于双向链表)go实现</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1.8698f35cbd072100d008bc5611dc9311_huc216cf6486350636a2e6728955e7fc78_62516_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-hpjzXL0HIQDQCLxWEdyTEQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">数据结构-双向链表&amp;&amp;循环双向链表go语言实现</h2>
        </div>
    </a>
</article>
                
                    
<article class="has-image">
    <a href="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/">
        
        
            <div class="article-image">
                <img src="/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1.d4063513636ac24a26f405f7f6147e2d_huda65db0749ea5cfbe7a2aa726c042ca1_14970_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="" 
                        data-hash="md5-1AY1E2Nqwkom9AX39hR&#43;LQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">数据结构-单向链表go语言实现</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2022 Chengji Zhao&#39;s blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.2.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">
            <section class="widget archives">
                <div class="widget-icon">
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



                </div>
                <h2 class="widget-title section-title">目录</h2>
                
                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#uber-goguidehttpsgithubcomuber-goguide-的中文翻译"><a href="https://github.com/uber-go/guide">uber-go/guide</a> 的中文翻译</a></li>
    <li><a href="#englishhttpsgithubcomuber-goguideblobmasterstylemd"><a href="https://github.com/uber-go/guide/blob/master/style.md">English</a></a></li>
    <li><a href="#uber-go-语言编码规范">Uber go 语言编码规范</a></li>
    <li><a href="#目录">目录</a></li>
    <li><a href="#介绍">介绍</a></li>
    <li><a href="#指导原则">指导原则</a>
      <ol>
        <li><a href="#指向-interface-的指针">指向 interface 的指针</a></li>
        <li><a href="#interface-合理性验证">Interface 合理性验证</a></li>
        <li><a href="#接收器-receiver-与接口">接收器 (receiver) 与接口</a></li>
        <li><a href="#零值-mutex-是有效的">零值 Mutex 是有效的</a></li>
        <li><a href="#在边界处拷贝-slices-和-maps">在边界处拷贝 Slices 和 Maps</a>
          <ol>
            <li><a href="#接收-slices-和-maps">接收 Slices 和 Maps</a></li>
            <li><a href="#返回-slices-或-maps">返回 slices 或 maps</a></li>
          </ol>
        </li>
        <li><a href="#使用-defer-释放资源">使用 defer 释放资源</a></li>
        <li><a href="#channel-的-size-要么是-1要么是无缓冲的">Channel 的 size 要么是 1，要么是无缓冲的</a></li>
        <li><a href="#枚举从-1-开始">枚举从 1 开始</a></li>
        <li><a href="#使用-time-处理时间">使用 time 处理时间</a>
          <ol>
            <li><a href="#使用-timetime-表达瞬时时间">使用 <code>time.Time</code> 表达瞬时时间</a></li>
            <li><a href="#使用-timeduration-表达时间段">使用 <code>time.Duration</code> 表达时间段</a></li>
            <li><a href="#对外部系统使用-timetime-和-timeduration">对外部系统使用 <code>time.Time</code> 和 <code>time.Duration</code></a></li>
          </ol>
        </li>
        <li><a href="#错误类型">错误类型</a></li>
        <li><a href="#错误包装-error-wrapping">错误包装 (Error Wrapping)</a></li>
        <li><a href="#处理类型断言失败">处理类型断言失败</a></li>
        <li><a href="#不要-panic">不要 panic</a></li>
        <li><a href="#使用">使用</a></li>
        <li><a href="#避免可变全局变量">避免可变全局变量</a></li>
        <li><a href="#避免在公共结构中嵌入类型">避免在公共结构中嵌入类型</a></li>
        <li><a href="#避免使用内置名称">避免使用内置名称</a></li>
        <li><a href="#避免使用-init">避免使用 <code>init()</code></a></li>
        <li><a href="#追加时优先指定切片容量">追加时优先指定切片容量</a></li>
        <li><a href="#主函数退出方式exit">主函数退出方式(Exit)</a>
          <ol>
            <li><a href="#一次性退出">一次性退出</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#性能">性能</a>
      <ol>
        <li><a href="#优先使用-strconv-而不是-fmt">优先使用 strconv 而不是 fmt</a></li>
        <li><a href="#避免字符串到字节的转换">避免字符串到字节的转换</a></li>
        <li><a href="#指定容器容量">指定容器容量</a>
          <ol>
            <li><a href="#指定map容量提示">指定Map容量提示</a></li>
            <li><a href="#指定切片容量">指定切片容量</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#规范">规范</a>
      <ol>
        <li><a href="#一致性">一致性</a></li>
        <li><a href="#相似的声明放在一组">相似的声明放在一组</a></li>
        <li><a href="#import-分组">import 分组</a></li>
        <li><a href="#包名">包名</a></li>
        <li><a href="#函数名">函数名</a></li>
        <li><a href="#导入别名">导入别名</a></li>
        <li><a href="#函数分组与顺序">函数分组与顺序</a></li>
        <li><a href="#减少嵌套">减少嵌套</a></li>
        <li><a href="#不必要的-else">不必要的 else</a></li>
        <li><a href="#顶层变量声明">顶层变量声明</a></li>
        <li><a href="#对于未导出的顶层常量和变量使用_作为前缀">对于未导出的顶层常量和变量，使用_作为前缀</a></li>
        <li><a href="#结构体中的嵌入">结构体中的嵌入</a></li>
        <li><a href="#使用字段名初始化结构体">使用字段名初始化结构体</a></li>
        <li><a href="#本地变量声明">本地变量声明</a></li>
        <li><a href="#nil-是一个有效的-slice">nil 是一个有效的 slice</a></li>
        <li><a href="#缩小变量作用域">缩小变量作用域</a></li>
        <li><a href="#避免参数语义不明确avoid-naked-parameters">避免参数语义不明确(Avoid Naked Parameters)</a></li>
        <li><a href="#使用原始字符串字面值避免转义">使用原始字符串字面值，避免转义</a></li>
        <li><a href="#初始化结构体">初始化结构体</a>
          <ol>
            <li><a href="#使用字段名初始化结构">使用字段名初始化结构</a></li>
            <li><a href="#省略结构中的零值字段">省略结构中的零值字段</a></li>
            <li><a href="#对零值结构使用-var">对零值结构使用 <code>var</code></a></li>
            <li><a href="#初始化-struct-引用">初始化 Struct 引用</a></li>
          </ol>
        </li>
        <li><a href="#初始化-maps">初始化 Maps</a></li>
        <li><a href="#字符串-string-format">字符串 string format</a></li>
        <li><a href="#命名-printf-样式的函数">命名 Printf 样式的函数</a></li>
      </ol>
    </li>
    <li><a href="#编程模式">编程模式</a>
      <ol>
        <li><a href="#表驱动测试">表驱动测试</a></li>
        <li><a href="#功能选项">功能选项</a></li>
      </ol>
    </li>
    <li><a href="#linting">Linting</a>
      <ol>
        <li><a href="#lint-runners">Lint Runners</a></li>
      </ol>
    </li>
    <li><a href="#stargazers-over-time">Stargazers over time</a></li>
  </ol>
</nav>
                </div>
            </section>
        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
