<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>语言学习 on Chengji Zhao&#39;s blog</title>
    <link>https://zcj-git520.github.io/categories/language/</link>
    <description>Recent content in 语言学习 on Chengji Zhao&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 15 Oct 2021 22:00:38 +0800</lastBuildDate><atom:link href="https://zcj-git520.github.io/categories/language/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go Channel</title>
      <link>https://zcj-git520.github.io/p/go-channel/</link>
      <pubDate>Fri, 15 Oct 2021 22:00:38 +0800</pubDate>
      
      <guid>https://zcj-git520.github.io/p/go-channel/</guid>
      <description>go Channel  （Do not communicate by sharing memory; instead, share memory by communicating）  CSP并发模型  CSP 即通信顺序进程、交谈循序程序，又被译为交换消息的循序程序(communicating sequential processes)，它是一种用来描述并发性系统之间进行交互的模型。 go Channe是一种特殊的类型，是有特定类型的队列。是链接goroutine(协程)的通信机制，通过通信共享内存而不是通过共享内存而实现通信. Channel 收发操作均遵循了先进先出的设计，具体规则如下：  先从 Channel 读取数据的 Goroutine 会先接收到数据； 先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；    
channel 数据结构定义： type hchan struct { // 队列中数据的总数量 qcount uint // total data in the queue //环形队列的大小 dataqsiz uint // size of the circular queue // 存放环形队列的数据 buf unsafe.Pointer // points to an array of dataqsiz elements // 元素的大小 elemsize uint16 // 是否关闭的标识 closed uint32 // 元素的类型 elemtype *_type // element type // 当前发送数据在环形队列的索引 sendx uint // send index // 当前接受数据在环形队列的索引 recvx uint // receive index // 接收者等待队列（&amp;lt;-ch）阻塞在channel的协程队列 recvq waitq // list of recv waiters // 发送者等待队列（ch&amp;lt;- data）阻塞在channel的协程队列 sendq waitq // list of send waiters //锁保护hchan中的所有字段，以及几个 //在这个通道上阻塞sudogs中的字段 //保持这个锁时不要改变另一个G的状态 //(特别是，不要准备一个G)，因为这可能会死锁 //栈收缩。 lock mutex // 保护hchan中的所有字段，保持协程的状态不被更改，避免造成栈收缩引起的死锁，使用互斥锁解决程序中可能存在的线程竞争问题是很常见的 } 发送者/接收者等待队列的结构：一个双向链表 type waitq struct { first *sudog last *sudog } channel sudog结构如下 type sudog struct { // The following fields are protected by the hchan.</description>
    </item>
    
    <item>
      <title>go goroutine与gmp模型</title>
      <link>https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B/</link>
      <pubDate>Wed, 06 Oct 2021 22:00:38 +0800</pubDate>
      
      <guid>https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B/</guid>
      <description>go 协程goroutine  协程是用户级的线程，有用户自己调度，使用协程使得程序调度更加灵活。同时比线程更轻量，占用的栈内存更少。go语言天生支持高并发，go使用协程goroutine的调度器。goroutine 的栈内存最小值为2kb(_StackMin = 2048),它不是固定不变的，可以随需求增大和缩小。goroutine 维护着很大的内存，无需频繁开辟内存，goroutine是使用M:n模型，在用户态切换协程，加上创建协程代价低，使得cpu的利用率大大提升，cup的性能大幅度的被利用。  goroutine 调度器GPM模型 G  G 就是goroutine协程  type g struct { // Stack parameters. // stack describes the actual stack memory: [stack.lo, stack.hi). // stackguard0 is the stack pointer compared in the Go stack growth prologue. // It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption. // stackguard1 is the stack pointer compared in the C stack growth prologue.</description>
    </item>
    
    <item>
      <title>go 基础之map</title>
      <link>https://zcj-git520.github.io/p/go-%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/</link>
      <pubDate>Mon, 20 Sep 2021 22:00:38 +0800</pubDate>
      
      <guid>https://zcj-git520.github.io/p/go-%E5%9F%BA%E7%A1%80%E4%B9%8Bmap/</guid>
      <description>goland 基础之map map的内部结构  go map是使用的哈希表构建的 map的结构可分为：hmap的结构体和bmap(桶)，hmap结构体记录这map的基础信息(包括map存储个数， 桶的个数，hash种子，桶的数据，扩容时旧桶的数据以及迁移个数（map扩容不是一次性迁移完）) 源码如下    定义hmap的结构： type hmap struct { // Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go. // Make sure this stays in sync with the compiler&#39;s definition. // map 存储元素的计数 count int // # live cells == size of map. Must be first (used by len() builtin) flags uint8 // map的状态标识，桶是否在增改，扩容或者缩容 //桶的个数/采用的与运算法计算桶的个数，桶的个数为2的整数次幂 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items) //溢出的桶的数量的近似值 noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details hash0 uint32 // hash seed //指向桶数据的指针 buckets unsafe.</description>
    </item>
    
    <item>
      <title>go 基础之切片</title>
      <link>https://zcj-git520.github.io/p/go-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</link>
      <pubDate>Wed, 15 Sep 2021 22:00:38 +0800</pubDate>
      
      <guid>https://zcj-git520.github.io/p/go-%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%87%E7%89%87/</guid>
      <description>切片的内部结构  切片的结构可分为：数组，数据（元素）的地址&amp;amp;data、也存元素个数len、可以存储多少元素cap 源码如下    定义切片的结构： type slice struct { array unsafe.Pointer len int cap int }  如图所示  avatar
 var data [] int 声明一个切片，相当于生成切片的结构，data地址指针为nil, len和cap都为0。这就很清楚为什么，nil切片不可以直接使用了😄 结构如图  avatar
 使用切片时需要make([]type,len,cap)或者初始化[]type{}才能使用，这是因为在在生成切片的结构时，同时也开辟了一段新的内存，类型为type, 结构长度为cap,同时值进行初始化。 make 源码如下：    func makeslice(et *_type, len, cap int) unsafe.Pointer { mem, overflow := math.MulUintptr(et.size, uintptr(cap)) // 判断是否越界 if overflow || mem &amp;gt; maxAlloc || len &amp;lt; 0 || len &amp;gt; cap { // NOTE: Produce a &#39;len out of range&#39; error instead of a // &#39;cap out of range&#39; error when someone does make([]T, bignumber).</description>
    </item>
    
  </channel>
</rss>
