<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Chengji Zhao&#39;s blog</title>
        <link>https://zcj-git520.github.io/</link>
        <description>Recent content on Chengji Zhao&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>zh-cn</language>
        <lastBuildDate>Tue, 15 Mar 2022 22:00:38 +0800</lastBuildDate><atom:link href="https://zcj-git520.github.io/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>linux 性能优化(二)</title>
        <link>https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/</link>
        <pubDate>Tue, 15 Mar 2022 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/3.png" alt="Featured image of post linux 性能优化(二)" /&gt;&lt;h3 id=&#34;性能&#34;&gt;性能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;高并发和快响应的性能指标是指：吞吐和延时&lt;/li&gt;
&lt;li&gt;性能的本质：系统资源已经到达瓶颈时，处理请求不够快，不足以处理更多的请求。&lt;/li&gt;
&lt;li&gt;性能分析：找到系统或者应用的瓶颈，尽最大的可能避免或者缓解这样的瓶颈。&lt;/li&gt;
&lt;li&gt;常用的性能分析工具：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 142; 
			flex-basis: 342px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/1.png&#34; data-size=&#34;1080x756&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/1.png&#34;
			width=&#34;1080&#34;
			height=&#34;756&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/1_hu928ad0f6362718a555aaab91886e0f15_324052_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/1_hu928ad0f6362718a555aaab91886e0f15_324052_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cup上下文切换&#34;&gt;cup上下文切换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cup上下文切换：将上一个任务cup的上下文保存系统的内核中休眠，然后将新任务的cup上下文进行加载，然后执行这个新任务。
cup的上下文切换可分为：线程上下文切换、进程上下文切换和中断上下文切换。在内核中中断的等级与进程和线程的等级高，所以保证了中断上下文
切换与进程和线程上下文切换不同时发生。&lt;/li&gt;
&lt;li&gt;通过vmstat可以查看系统总体的上下文切换情况
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 356; 
			flex-basis: 855px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/2.png&#34; data-size=&#34;841x236&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/2.png&#34;
			width=&#34;841&#34;
			height=&#34;236&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/2_hufc75824d3fc6ef1d68067ee2fa21a4ce_90835_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%BA%8C/2_hufc75824d3fc6ef1d68067ee2fa21a4ce_90835_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;进程上下切换&#34;&gt;进程上下切换&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;linux进程按照等级权限将进程的运行空间分为内核空间和用户态空间。其中用户态向内核态转换需要进行系统调用。执行一次系统调用
需要进行两次cpu的上下文切换分别为：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;CPU寄存器中用户态的指令位置先保存起来，CPU寄存器更新为内核态指令的位置，跳转到内核态运行内核任务；&lt;br&gt;
系统调用结束后，CPU寄存器恢复原来保存的用户态数据，再切换到用户空间继续运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程是由内核管理和调度的，进程上下文切换只能发生在内核态。因此相比系统调用来说，在保存当前进程的内核状态和CPU寄存器之前，需要先把该进程的虚拟内存，栈保存下来。再加载新进程的内核态后，还要刷新进程的虚拟内存和用户栈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程只有在调度到CPU上运行时才需要切换上下文，有以下几种场景：CPU时间片轮流分配，系统资源不足导致进程挂起，进程通过sleep函数主动挂起，高优先级进程抢占时间片，硬件中断时CPU上的进程被挂起转而执行内核中的中断服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;线程上下文切换&#34;&gt;线程上下文切换&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在同一进程中的线程进行上下文切换，切换时，只需要切换线程的私有数据、寄存器等，消耗资源少。&lt;/li&gt;
&lt;li&gt;在不同进程的中的线程进行上下文切换，切换与进程的上下文切换一致。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;中断上下文切换&#34;&gt;中断上下文切换&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;中断上下文切换只包括内核态中断服务程序执行所需要的状态（CPU寄存器，内核堆栈，硬件中断参数等）（CPU寄存器，内核堆栈，硬件中断参数等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s/6_utyj1kCyC5ZWpveDZQIQ&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;极限好文！Linux 性能优化全景指南&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>linux 性能优化(一)</title>
        <link>https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/</link>
        <pubDate>Sat, 05 Mar 2022 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/3.png" alt="Featured image of post linux 性能优化(一)" /&gt;&lt;h2 id=&#34;linux常用的性能查看命令&#34;&gt;Linux常用的性能查看命令&lt;/h2&gt;
&lt;h3 id=&#34;cpu性能查看&#34;&gt;CPU性能查看&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用ps查看正在运行的进程
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 168; 
			flex-basis: 404px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/1.png&#34; data-size=&#34;1164x690&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/1.png&#34;
			width=&#34;1164&#34;
			height=&#34;690&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/1_hud352ebb526399801a7382ecb45827a96_76217_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/1_hud352ebb526399801a7382ecb45827a96_76217_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 120; 
			flex-basis: 289px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/2.png&#34; data-size=&#34;877x728&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/2.png&#34;
			width=&#34;877&#34;
			height=&#34;728&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/2_hu7711e5e375a95a94c8f76c64de13e2e0_134520_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/2_hu7711e5e375a95a94c8f76c64de13e2e0_134520_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;使用top查看各cup的使用情况、对应内存以及个进程占cpu和使用内存的情况
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 183; 
			flex-basis: 440px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/3.png&#34; data-size=&#34;1361x742&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/3.png&#34;
			width=&#34;1361&#34;
			height=&#34;742&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/3_hu66cf5664c43f449fa744670ec4319b24_173122_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/3_hu66cf5664c43f449fa744670ec4319b24_173122_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;vmstat命令：查看CPU负载
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 805; 
			flex-basis: 1934px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/4.png&#34; data-size=&#34;822x102&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/4.png&#34;
			width=&#34;822&#34;
			height=&#34;102&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/4_hua29ecafa10b7c2e837fc83b1946d2863_18299_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/4_hua29ecafa10b7c2e837fc83b1946d2863_18299_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;内存使用情况查看&#34;&gt;内存使用情况查看&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;除了使用top可以查看内存使用情况外，还可以使用free命令进行查看
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 585; 
			flex-basis: 1404px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/5.png&#34; data-size=&#34;749x128&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/5.png&#34;
			width=&#34;749&#34;
			height=&#34;128&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/5_hue05bab33803ae96086f1fcaba47a50e2_19352_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/5_hue05bab33803ae96086f1fcaba47a50e2_19352_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;磁盘io性能查看&#34;&gt;磁盘I/O性能查看&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;可以使用df 或者 df -h 查看磁盘占用用情况
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 158; 
			flex-basis: 381px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/6.png&#34; data-size=&#34;635x400&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/6.png&#34;
			width=&#34;635&#34;
			height=&#34;400&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/6_huf1d499cd45246d7290abe352fe9ff45a_89541_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/6_huf1d499cd45246d7290abe352fe9ff45a_89541_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;iostat -d 进行查看
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 292; 
			flex-basis: 703px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/7.png&#34; data-size=&#34;999x341&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/7.png&#34;
			width=&#34;999&#34;
			height=&#34;341&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/7_huf00b96b4cff54e7d4a8f4f1c2555ad35_56884_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/7_huf00b96b4cff54e7d4a8f4f1c2555ad35_56884_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;查看网络情况&#34;&gt;查看网络情况&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;使用ifconfig查看或者修改网络
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 221; 
			flex-basis: 532px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/8.png&#34; data-size=&#34;792x357&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/8.png&#34;
			width=&#34;792&#34;
			height=&#34;357&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/8_hu1f4ff6ae1758e7848c32cdaf96a01f88_76473_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/8_hu1f4ff6ae1758e7848c32cdaf96a01f88_76473_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;netstat命令：-i 查看网络接口信息，-r 检测系统路由表信息
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 346; 
			flex-basis: 831px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/9.png&#34; data-size=&#34;825x238&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/9.png&#34;
			width=&#34;825&#34;
			height=&#34;238&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/9_hub74d6223efb06e0a0c47c9dce23fedf6_43319_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/9_hub74d6223efb06e0a0c47c9dce23fedf6_43319_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;动态监控性能&#34;&gt;动态监控性能&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用watch命令：动态监控，默认2秒钟执行一次，执行结果更新在屏幕上
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 239; 
			flex-basis: 574px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/10.png&#34; data-size=&#34;1739x726&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/10.png&#34;
			width=&#34;1739&#34;
			height=&#34;726&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/10_hu0938913199fe6be4e994bcf9de02b974_102418_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/10_hu0938913199fe6be4e994bcf9de02b974_102418_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 1281; 
			flex-basis: 3075px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/11.png&#34; data-size=&#34;1858x145&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/11.png&#34;
			width=&#34;1858&#34;
			height=&#34;145&#34;
			srcset=&#34;https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/11_hu15d41aba72496328c8648425813a5081_22674_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/linux-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%80/11_hu15d41aba72496328c8648425813a5081_22674_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>mysql性能调优-分库分表</title>
        <link>https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</link>
        <pubDate>Tue, 01 Mar 2022 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/3.png" alt="Featured image of post mysql性能调优-分库分表" /&gt;&lt;h2 id=&#34;数据切分&#34;&gt;数据切分&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当数据库中的数据或者单表数据过大时，会影响对数据库查询等操作的效率。此时可以减轻数据库的负担
可以将数据库进行拆分，即分库分表。来提高数据库的效率。&lt;/li&gt;
&lt;li&gt;数据库有两种拆分方式：水平切分和垂直切分&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;垂直切分&#34;&gt;垂直切分&lt;/h2&gt;
&lt;h3 id=&#34;垂直分库&#34;&gt;垂直分库&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;垂直分库：根据业务解耦，以表为单位，将相同业务的表存储在同一数据库中。将大数据库拆分为不同的小数据库。
小数据库的结构和存储的数据不一样。小数据库的并集为大数据库。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 145; 
			flex-basis: 348px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1.png&#34; data-size=&#34;825x568&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1.png&#34;
			width=&#34;825&#34;
			height=&#34;568&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1_huc81ff6a1490027b3cba856c0fa33c5e4_209327_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/1_huc81ff6a1490027b3cba856c0fa33c5e4_209327_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;使用场景高并发时，将数据分类到不同数据库中，提升数据库的查询效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;垂直分表&#34;&gt;垂直分表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;垂直分表：是以字段为单位，将表中的不常用的字段和字段名较长的字段拆分到扩展表中，其余放入到主表中。也可以经热数据放入主表，冷
数据放入拓展表。主表和拓展表的数据结构和存储的数据是不一样。将表中的进行冷热数据的拆分，减少了对磁盘io的操作，提升数据库的效率
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 192; 
			flex-basis: 463px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/2.png&#34; data-size=&#34;826x428&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/2.png&#34;
			width=&#34;826&#34;
			height=&#34;428&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/2_hub0013f0b591b75a5db27099043fb4213_107563_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/2_hub0013f0b591b75a5db27099043fb4213_107563_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;使用场景：表的记录并不多，但是字段多，并且热点数据和非热点数据在一起，单行数据所需的存储空间较大。以至于数据库缓存的数据行减少，查询时会去读磁盘数据产生大量的随机读IO，产生IO瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优缺点&#34;&gt;优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优点：业务解耦合，方便对不同业务进行管理，提升数据库的效率&lt;/li&gt;
&lt;li&gt;缺点：部分表不能join,表中的热数据太多&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;水平切分&#34;&gt;水平切分&lt;/h2&gt;
&lt;h3 id=&#34;水平分库和分表&#34;&gt;水平分库和分表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;都是以字段为单位，通过哈希和随机等策略，将数据分到不同的子库或者子表中。
所有的子库和子表的数据结构一样和数据不一致，即所有子库的数据等于数据库中的数据。形成分布式的效果。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 85; 
			flex-basis: 205px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/3.png&#34; data-size=&#34;602x703&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/3.png&#34;
			width=&#34;602&#34;
			height=&#34;703&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/3_hu5261706da37be2572fd4622db307b63b_273707_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/3_hu5261706da37be2572fd4622db307b63b_273707_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;使用场景：数据量行数巨大，存在单库读写、存储性能瓶颈，数据量太多，影响了SQL效率，加重了CPU负担，以至于成为瓶颈。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优缺点-1&#34;&gt;优缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;优点：提升系统稳定性和负载能力&lt;/li&gt;
&lt;li&gt;缺点：事务一致性难以保证&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据库的瓶颈&#34;&gt;数据库的瓶颈&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数据库的瓶颈可分为：io瓶颈和cpu瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;io瓶颈&#34;&gt;io瓶颈&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;磁盘读写io瓶颈：当热数据过多时，数据库内存(buffer Pool)保存不下时，会产生大量的io。此时就需要进行分库和垂直分表。&lt;/li&gt;
&lt;li&gt;网络io瓶颈：请求的数据太多，网络带宽不够，此时就需要分库。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;cpu瓶颈&#34;&gt;CPU瓶颈&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;sql中使用了大量的cpu运算的操作。此时需要优化sql,如增加索引&lt;/li&gt;
&lt;li&gt;单表数据量大时，且进行全表扫描，查询效率低时，需要水平分表分库。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/104992837&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;数据库分库分表思路&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>mysql事务实现基本原理</title>
        <link>https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
        <pubDate>Fri, 25 Feb 2022 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1.png" alt="Featured image of post mysql事务实现基本原理" /&gt;&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;事务就是一组原子性的SQL语句.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;buffer-pool&#34;&gt;buffer Pool&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;当启动mysql会开启默认为128M的内存空间来保存从磁盘获取的页的数据到这块内存空间。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 103; 
			flex-basis: 247px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png&#34; data-size=&#34;676x656&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4.png&#34;
			width=&#34;676&#34;
			height=&#34;656&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4_huf2f92c82b6d4783456b3162dabdbebb8_71871_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/4_huf2f92c82b6d4783456b3162dabdbebb8_71871_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;InnoDB通过free链表来管理buffer Pool中的空闲页，通过控制块来指向空白页.即从磁盘中的获取的页数据通过
控制块放入到buffer Pool中对应的空闲页中。&lt;/li&gt;
&lt;li&gt;通过flush链表来管理buffer Poll中的脏页(通过事务修改过的页)。通过链表中控制块指向脏页。&lt;/li&gt;
&lt;li&gt;通过lru链表来对Buffer Pool中的页进行淘汰。通过头插法将最新的页插入到链表中的控制块。当buffer Pool中的页满后，删除链表最后的控制块。
也存在当全表扫描时，也造成数据的覆盖，性能下降。因此链表被划分为热数据区域(5/8)和冷数据区域(3/8)。当两次访问页的时间大于1秒时，把页放入到热数据的控制块
，否则就放入冷数据页，避免了全表扫描造成热数据被覆盖。生成redo log后，mysql通过后台进程经将脏页持久化到磁盘。当MySQL挂了之后，
会通过redo log恢复数据。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 209; 
			flex-basis: 503px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/2.png&#34; data-size=&#34;1346x641&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/2.png&#34;
			width=&#34;1346&#34;
			height=&#34;641&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/2_hu56fb40fab0e4369feae4525e597efaf7_183232_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/2_hu56fb40fab0e4369feae4525e597efaf7_183232_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 311; 
			flex-basis: 747px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/3.png&#34; data-size=&#34;1264x406&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/3.png&#34;
			width=&#34;1264&#34;
			height=&#34;406&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/3_hua668fce7a2f5bc44213ed5e50e023fb3_144803_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/3_hua668fce7a2f5bc44213ed5e50e023fb3_144803_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;事务具有的acid的特性&#34;&gt;事务具有的ACID的特性&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;原子性:事务中所有的操作那么全部提交成功，要么全部失败回滚&lt;/li&gt;
&lt;li&gt;一致性：数据库总是从一个一致性状态转换到另一个一致性的状态&lt;/li&gt;
&lt;li&gt;隔离性：一个事务在所做修改在提交前对其他事务是不可见的&lt;/li&gt;
&lt;li&gt;持久性：一旦事务提交，说有的修改都会永久保存在数据库中&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;事务的隔离级别&#34;&gt;事务的隔离级别&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;读未提交：事务中的修改即使未提交也是对其他事务可见，这级别的事务隔离有脏读、重复读、幻读的问题。&lt;/li&gt;
&lt;li&gt;读也提交：事务提交后所做的修改才会被另一个事务所看见，可能产生一个事务中两次查询的结果不同。&lt;/li&gt;
&lt;li&gt;可重复读： 只有当前事务提交才能看见另一个事务的修改结果。解决了一个事务中两次查询的结果不同的问题。&lt;/li&gt;
&lt;li&gt;可串行化：只有一个事务提交之后才会执行另一个事务。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 256; 
			flex-basis: 614px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1.png&#34; data-size=&#34;930x363&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1.png&#34;
			width=&#34;930&#34;
			height=&#34;363&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1_hub1d649ce0ea89887083315ebed128a77_18394_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E4%BA%8B%E5%8A%A1%E5%AE%9E%E7%8E%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1_hub1d649ce0ea89887083315ebed128a77_18394_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;死锁&#34;&gt;死锁&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;死锁：两个或多个事务在同一资源上相互占用并请求锁定对方占用的资源，从而导致恶性循环的现象。MySQL的部分存储引擎能够检测到死锁的循环依赖并产生相应的错误。InnoDB引擎解决死锁的方案是将持有最少排它锁的事务进行回滚&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;mvcc原理&#34;&gt;MVCC原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;mvcc 多版本并发控制：指在读取数据时通过一种类似快照的方式将数据保存下来，这样读锁和写锁不冲突。是 innodb 实现事务并发与回滚的重要功能。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;版本链&#34;&gt;版本链&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;每次更新后，都会将旧值放到一条 undo log 中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被roll_ptr 属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;trx_id：每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。
roll_pointer：每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo日志中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;readview&#34;&gt;ReadView&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB提出了一个ReadView的概念，这个ReadView 中有个 id 列表 trx_ids 来存储系统中当前活跃着的读写事务，也就是 begin 了还未 commit 或 rollback 的事务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.linuxidc.com/Linux/2014-04/99721.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL运行原理与基础架构&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>mysql底层基本原理</title>
        <link>https://zcj-git520.github.io/p/mysql%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</link>
        <pubDate>Sun, 20 Feb 2022 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/mysql%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/mysql%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1.png" alt="Featured image of post mysql底层基本原理" /&gt;&lt;h2 id=&#34;索引&#34;&gt;索引&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;索引是帮助数据库获取有序数据的数据结构，实现快速检索&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库索引的数据结构&#34;&gt;数据库索引的数据结构&lt;/h3&gt;
&lt;h4 id=&#34;哈希表hash&#34;&gt;哈希表(hash)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;通过哈希函数，实现key-value的存储，同时可以使用开放地址法和拉链法解决哈希冲突，对查询单个值的
时间复杂度为O(1)，例如查找id=1：select * from user where id=1
,但对范围查询十分的不友好,例如查找范围id&amp;gt;100的值：select * from user where id &amp;gt;100;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二叉树&#34;&gt;二叉树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;二叉树的数据结构左小右大，可以通过中序遍历直接获取所有升序的数据，二叉树的查询的时间复杂度为
O(lgn),缺点是二叉树容易退化链表，增加数据的查找的时间。在最坏的情况下的时间复杂度为O(n)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;平衡二叉树avl和红黑树&#34;&gt;平衡二叉树(AVL)和红黑树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;通过左旋和右旋以及节点颜色的改变等方式调整树避免退化为链表，使二叉树保持平衡转态，保证树的查找性能
即时间复杂度在O(lgn)。但是二叉树不适合用做数据的底层数据结构原因如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1.数据库的查询的瓶颈在于对磁盘io的操作，当存储大量数据的情况下，要保证树的平衡的时候，树的高度
是在不断的增加，在对每一个节点的操作时，就是对磁盘io的操作，即对磁盘io的操作过于的频繁，增加了对数据库
查询等时间。
2 每个节点的分配的内存是16kb的数据量，对于二叉树的节点保持的数据是下于16KB,当数据过低时，也会造成内存的浪费&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;b树&#34;&gt;B树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;B树是一种平衡多分树，节点最多含有N颗子树(指针)，N-1个关键字(数据存储空间) (N&amp;gt;=2);除了根节点和叶子节点外，其它每个节点至少有M=N/2个子节点，M向上取整，即分裂的时候从中间分开，分成M棵子树；
若根节点不是叶子结点，则至少有两颗子树。B树解决了二叉树的高度问题，即减少了对磁盘io的操作，减少了数据库的时间,查询的时间复杂度为
h*O(lgn),h为树的高度。但是也存在一下问题&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;1.不太适合范围的查询，存在索引的失效
2.稳定性较弱，节点存储的数据较大，占用的内存空间较大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;b树-1&#34;&gt;B+树&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;B+树和B树类似,B+树的非叶子节点不会存储数据，只存储索引值(指针地址)，所有的数据都是存储在叶子节点，其目的是为了增加系统的稳定性。
应为节点存储的索引，叶子节点存储数据，叶子节点用了链表连接起来，这个链表本身就是有序的，在数据范围查找时，更具备效率
，保证了存储空间的使用。高度不高，减少了对磁盘的io的操作，保证了查询的效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h3&gt;
&lt;h4 id=&#34;innodb引擎&#34;&gt;InnoDB引擎&lt;/h4&gt;
&lt;h5 id=&#34;引擎特点&#34;&gt;引擎特点&lt;/h5&gt;
&lt;p&gt;1.将数据存储在表空间中，表空间由一系列的数据文件组成，由InnoDB管理；&lt;/p&gt;
&lt;p&gt;2.支持每个表的数据和索引存放在单独文件中(innodb_file_per_table)；&lt;/p&gt;
&lt;p&gt;3.支持事务，采用MVCC来控制并发，并实现标准的4个事务隔离级别，支持外键；&lt;/p&gt;
&lt;p&gt;4.索引基于聚簇索引建立，对于主键查询有较高性能；&lt;/p&gt;
&lt;p&gt;5.数据文件的平台无关性，支持数据在不同的架构平台移植；&lt;/p&gt;
&lt;p&gt;6.能够通过一些工具支持真正的热备。如XtraBackup等；&lt;/p&gt;
&lt;p&gt;7.内部进行自身优化如采取可预测性预读，能够自动在内存中创建hash索引等。&lt;/p&gt;
&lt;h5 id=&#34;引擎实现&#34;&gt;引擎实现&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;InnoDB是采用的是B+树作为索引的结构，其存储文件分别是.frm表的定义文件和.idb的数据文件。InnoDB是支持行锁和表锁的。InnoDB 支持事务，且支持四种隔离级别（读未提交、读已提交、可重复读、串行化），默认的为可重复读
表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 188; 
			flex-basis: 452px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/mysql%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1.png&#34; data-size=&#34;931x494&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/mysql%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1.png&#34;
			width=&#34;931&#34;
			height=&#34;494&#34;
			srcset=&#34;https://zcj-git520.github.io/p/mysql%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1_huc45b7cee299d4b0bd96f8dd390c7ebfb_163533_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/mysql%E5%BA%95%E5%B1%82%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/1_huc45b7cee299d4b0bd96f8dd390c7ebfb_163533_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;myisam引擎&#34;&gt;MyISAM引擎&lt;/h4&gt;
&lt;h4 id=&#34;引擎特点-1&#34;&gt;引擎特点&lt;/h4&gt;
&lt;p&gt;1.MySQL5.1中默认，不支持事务和行级锁；&lt;/p&gt;
&lt;p&gt;2.提供大量特性如全文索引、空间函数、压缩、延迟更新等；&lt;/p&gt;
&lt;p&gt;3.数据库故障后，安全恢复性差；&lt;/p&gt;
&lt;p&gt;4.对于只读数据可以忍受故障恢复，MyISAM依然非常适用；&lt;/p&gt;
&lt;p&gt;5.日志服务器的场景也比较适用，只需插入和数据读取操作；&lt;/p&gt;
&lt;p&gt;6.不支持单表一个文件，会将所有的数据和索引内容分别存在两个文件中；&lt;/p&gt;
&lt;p&gt;7.MyISAM对整张表加锁而不是对行，所以不适用写操作比较多的场景；&lt;/p&gt;
&lt;p&gt;8.支持索引缓存不支持数据缓存。&lt;/p&gt;
&lt;h4 id=&#34;引擎实现-1&#34;&gt;引擎实现&lt;/h4&gt;
&lt;p&gt;MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。其存储的文件有三个分别是：.frm表的定义文件、.MYD为数据文件和.MYL索引文件。
Myisam 只支持表锁，且不支持事务。Myisam 由于有单独的索引文件，在读取数据方面的性能很高&lt;/p&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.linuxidc.com/Linux/2014-04/99721.htm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL运行原理与基础架构&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>数据结构-AVL tree go实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-go%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Tue, 15 Feb 2022 21:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-go%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-go%E5%AE%9E%E7%8E%B0/1.png" alt="Featured image of post 数据结构-AVL tree go实现" /&gt;&lt;h2 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h2&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 定义树的节点
type AVLTreeNode struct {
	info   int  // 定义存储的内容
	height int  // 树的高度
	right  *AVLTreeNode  // 右节点
	left   *AVLTreeNode  // 左节点
}

// 定义树
type AVLTree struct {
	root *AVLTreeNode  // 定义根节点
}

// 创建节点
func creatNode(data int) *AVLTreeNode{
	return &amp;amp;AVLTreeNode{
		info:   data,
		height: -1,
		right:  nil,
		left:   nil,
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;增删改查&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据的插入&#34;&gt;数据的插入&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 数据的插入
func getHeight(node *AVLTreeNode) int {
	if node == nil{
		return -1
	}
	return node.height
}
// 左子树调整
func (a *AVLTree)leftTreeAdjust(node *AVLTreeNode, data int) *AVLTreeNode {
	// 判断是否需要调整树
	if getHeight(node.left) - getHeight(node.right) &amp;gt; 1{
		// 插入的节点在左边上，进右旋
		if data &amp;lt; node.left.info{
			return a.lR(node)
		}else{
			// 进行左右旋
			return a.rLR(node)
		}
	}
	return  node
}

// 右子树调整
func (a *AVLTree)rightTreeAdjust(node *AVLTreeNode, data int) *AVLTreeNode  {
	// 判断是否需要调整树
	if getHeight(node.right) - getHeight(node.left) &amp;gt; 1{
		// 插入的节点在右边上，进左旋
		if data &amp;gt;= node.right.info{
			return a.rR(node)
		}else{
			// 进行右左旋
			return  a.lRR(node)
		}
	}
	return node
}

func (a *AVLTree)insertNode(node **AVLTreeNode, data int)  {
	if *node == nil{
		*node = creatNode(data)
		(*node).height = maxValue(getHeight((*node).left), getHeight((*node).right)) + 1
		return
	}
	// 插入左子树
	if data &amp;lt; (*node).info{
		a.insertNode(&amp;amp;(*node).left, data)
		// 调整树
		*node = a.leftTreeAdjust(*node, data)

	}else{
		// 插入右子树
		a.insertNode(&amp;amp;(*node).right, data)
		// 调整树
		*node = a.rightTreeAdjust(*node, data)
	}
	// 调整节点的高度
	(*node).height = maxValue(getHeight((*node).left), getHeight((*node).right)) + 1
}

func (a *AVLTree)InsertData(data int )  {
	// 如果树为空
	if a.root == nil{
		a.root = creatNode(data)
		a.root.height = 0
		return
	}
	a.insertNode(&amp;amp;a.root, data)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的删除&#34;&gt;数据的删除&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 清空树
func (a *AVLTree)Clear(){
	a.root = nil
}

// 删除节点
func (a *AVLTree)deleteNode(node **AVLTreeNode, data int)  {
	if *node == nil{
		fmt.Printf(&amp;quot;no find data is %d \n&amp;quot;, data)
		return
	}
	if (*node).info == data{
		// 如果右节点为nil
		if (*node).right == nil{
			*node = (*node).left

		}else if (*node).left == nil{
			*node = (*node).right
		}else{
			// 找出左子树的最大值
			temp := (*node).left
			prev := *node  // 左子树最大值的最前驱节点
			for ; temp.right != nil; temp = temp.right{
				prev = temp
			}
			// 左子树的最大值复制给node
			(*node).info = temp.info
			if prev == *node{ // 如果左子树的最大值为node的node的子节点
				prev.left = temp.left  // 先驱节点的左节点指向左子树最大节点的左节点
			}else{
				prev.right = temp.left  // 先驱节点的右节点指向左子树最大节点的右节点
			}
			a.leftTreeAdjust(*node, data)
		}
		if *node != nil{
			// 调整节点的高度
			(*node).height = maxValue(getHeight((*node).left), getHeight((*node).right)) + 1
		}
		return
	}else if (*node).info &amp;gt; data{
		a.deleteNode(&amp;amp;(*node).left, data)
		a.leftTreeAdjust(*node, data)
	}else {
		a.deleteNode(&amp;amp;(*node).right, data)
		a.rightTreeAdjust(*node,data)
	}
	(*node).height = maxValue(getHeight((*node).left), getHeight((*node).right)) + 1
}

func (a *AVLTree)Remove(data int)  {
	if a.root == nil{
		return
	}
	a.deleteNode(&amp;amp;a.root, data)
}

// 得到最大值
func maxValue(value, value1 int) int {
	if value &amp;gt;= value1{
		return value
	}
	return value1
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的查询&#34;&gt;数据的查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历、中序遍历、后续遍历、值查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 树的遍历
// 前序遍历
func (a *AVLTree)nLR(node *AVLTreeNode){
	// 如果节点为空就返回
	if node == nil{
		return
	}
	fmt.Printf(&amp;quot;%d-&amp;gt;&amp;quot;, node.info)
	// 遍历左子树
	a.nLR(node.left)
	// 遍历右子树
	a.nLR(node.right)
}

// 中序遍历
func (a *AVLTree)lNR(node *AVLTreeNode){
	// 如果节点为空就返回
	if node == nil{
		return
	}
	a.lNR(node.left)
	fmt.Printf(&amp;quot;%d-&amp;gt;&amp;quot;, node.info)
	a.lNR(node.right)
}

// 后序遍历
func (a *AVLTree)lRN(node *AVLTreeNode){
	if node == nil{
		return
	}
	a.lRN(node.left)
	a.lRN(node.right)
	fmt.Printf(&amp;quot;%d-&amp;gt;&amp;quot;, node.info)
}

// 前序显示
func (a *AVLTree)ShowNLR(){
	if a.root == nil{
		fmt.Println(&amp;quot;zhe tree is empty&amp;quot;)
		return
	}
	fmt.Print(&amp;quot;NLR:&amp;quot;)
	node := a.root
	a.nLR(node)
	fmt.Println()
}

// 中序显示
func (a *AVLTree)ShowLNR(){
	if a.root == nil{
		fmt.Println(&amp;quot;zhe tree is empty&amp;quot;)
		return
	}
	fmt.Print(&amp;quot;LNR:&amp;quot;)
	node := a.root
	a.lNR(node)
	fmt.Println()
}

// 后序显示
func (a *AVLTree)ShowLRN(){
	if a.root == nil{
		fmt.Println(&amp;quot;zhe tree is empty&amp;quot;)
		return
	}
	fmt.Print(&amp;quot;LRN:&amp;quot;)
	node := a.root
	a.lRN(node)
	fmt.Println()
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;树的旋转&#34;&gt;树的旋转&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单左旋 单右旋 左右旋 右左旋&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 单右旋
func (a *AVLTree)lR(node *AVLTreeNode) *AVLTreeNode {
	// 临时node 指向节点的左节点
	temp := (*node).left
	// node的左节点指向temp 的右节点
	(*node).left = temp.right
	// temp 的右节点指向node（node 为temp的右节点的）
	temp.right = node
	// 调整高度
	(*node).height = maxValue(getHeight((*node).left), getHeight((*node).right)) + 1
	temp.height = maxValue(getHeight(temp.left), getHeight(temp.right)) + 1
	return  temp
}

// 单左旋
func (a *AVLTree)rR(node *AVLTreeNode) *AVLTreeNode {
	// 临时node 指向节点的右节点
	temp := (*node).right
	// node的右节点指向temp的左节点
	(*node).right = temp.left
	// temp的左节点指向node
	temp.left = node
	// 调整树的高度
	(*node).height = maxValue(getHeight((*node).left), getHeight((*node).right)) + 1
	temp.height = maxValue(getHeight(temp.left), getHeight(temp.right)) + 1
	return temp
}

// 左右旋(先左旋在右旋)
func (a *AVLTree)rLR(node *AVLTreeNode) *AVLTreeNode {
	node.left =  a.rR(node.left)
	return a.lR(node)
}

// 右左旋(先右旋再左旋)
func (a *AVLTree)lRR(node *AVLTreeNode) *AVLTreeNode {
	node.right = a.lR(node.right)
	return a.rR(node)
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
func TestAVRTree_InsertData(t *testing.T) {
	avl := CreatAVLTree()
	avl.InsertData(2)
	avl.InsertData(12)
	avl.InsertData(24)
	avl.InsertData(1)
	avl.InsertData(65)
	avl.InsertData(72)
	avl.InsertData(32)
	avl.InsertData(21)
	avl.ShowNLR()
	avl.ShowLNR()
	avl.ShowLRN()
}

func TestAVLTree_Remove(t *testing.T) {
	avl := CreatAVLTree()
	avl.InsertData(1)
	avl.InsertData(2)
	avl.InsertData(3)
	avl.InsertData(4)
	avl.InsertData(5)
	avl.InsertData(6)
	avl.InsertData(7)
	avl.InsertData(8)
	avl.ShowNLR()
	avl.ShowLNR()
	avl.ShowLRN()
	fmt.Println(&amp;quot;**********************&amp;quot;)
	avl.Remove(4)
	avl.ShowNLR()
	avl.ShowLNR()
	avl.ShowLRN()
}

func TestAVLTree_IsValue(t *testing.T) {
	avl := CreatAVLTree()
	avl.InsertData(1)
	avl.InsertData(2)
	avl.InsertData(3)
	avl.InsertData(4)
	avl.InsertData(5)
	avl.InsertData(6)
	avl.InsertData(7)
	avl.InsertData(8)
	avl.ShowNLR()
	avl.ShowLNR()
	avl.ShowLRN()
	data := 4
	is := avl.IsValue(data)
	if is{
		fmt.Printf(&amp;quot;%d :is exits\n&amp;quot;, data)
	}else{
		fmt.Printf(&amp;quot;%d :is not exits\n&amp;quot;, data)
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/tree/AVL_tree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/tree/AVL_tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-AVL tree c&#43;&#43;实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-c-%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Mon, 10 Jan 2022 21:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-c-%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-avl-tree-c-%E5%AE%9E%E7%8E%B0/1.png" alt="Featured image of post 数据结构-AVL tree c&#43;&#43;实现" /&gt;&lt;h2 id=&#34;平衡二叉树&#34;&gt;平衡二叉树&lt;/h2&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;

// 定义树的节点
template&amp;lt;class T&amp;gt;
class AvrTreeNode
{
public:
    AvrTreeNode(){};
    AvrTreeNode(T data)
    {
        this-&amp;gt;data = data;
        left = 0;
        right = 0;
        hight = -1;
    }
    ~AvrTreeNode(){};
    T data;                 // 存储的数据
    AvrTreeNode *left;      // 左子树
    AvrTreeNode *right;     // 右子树
    int hight;              // 高度 
};

// 定义树
template&amp;lt;class T&amp;gt;
class AvrTree
{
private:
    AvrTreeNode&amp;lt;T&amp;gt; *root;     // 定义根节点
    // 插入节点
    void inseartNode(AvrTreeNode&amp;lt;T&amp;gt;*&amp;amp; node, const T data);
    void deleteNodeAll(AvrTreeNode&amp;lt;T&amp;gt; *node); // 删除所有节点
    // 显示节点
    void DLR(AvrTreeNode&amp;lt;T&amp;gt; *node);
    void LDR(AvrTreeNode&amp;lt;T&amp;gt; *node);
    void LRD(AvrTreeNode&amp;lt;T&amp;gt; *node);
    // 删除*&amp;amp;代表指针引用
    bool deleteNode(AvrTreeNode&amp;lt;T&amp;gt;*&amp;amp; node, const T data);
    // void deleteNodeByMerge(AvrTreeNode&amp;lt;T&amp;gt;*&amp;amp; node); // 合并删除
    // void deleteNodeByCopy(AvrTreeNode&amp;lt;T&amp;gt;*&amp;amp; node);  // 复制删除
    // 单右旋
    void LL(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp;node);
    // 单左旋
    void RR(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp;node);
    // 左右旋
    void RLR(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp;node);
    // 右左旋
    void LRR(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp;node);
    // 求高度的最大值
    int maxHight(int h1, int h2)
    {
        return h1&amp;gt;h2 ? h1:h2;
    }
      // 得到树的高度
    int getTreeHight(AvrTreeNode&amp;lt;T&amp;gt; *node)
    {
        if(!node)
        {
            return -1;
        }
        return node-&amp;gt;hight;
    }
public:
    AvrTree(/* args */)
    {
        root = 0;
    }
    ~AvrTree();
    // 清空树
    void clear();
    // 是否为空树
    bool isEmpty()
    {
        return root == 0;
    }
    // 插入数据
    void inseartData(const T data);
    // 深度优先遍历树
    // 前序遍历(DLR 根-&amp;gt;左-&amp;gt;右)
    void showNodeByDLR();
    // 中序遍历(LDR 左-&amp;gt;根-&amp;gt;右)
    void showNodeByLDR();
    // 后序遍历(LRD 左-&amp;gt;右-&amp;gt;根)
    void showNodeByLRD();
    // 删除节点的数据
    bool remove(const T data);
    // LVR查找树
    bool LVRSearchData(const T data);
};

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;增删改查&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据的插入&#34;&gt;数据的插入&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 数据的插入
template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::inseartNode(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp; node, const T data)
{
    // 如果节点为空
    if(node == 0)
    {
        node = new AvrTreeNode&amp;lt;T&amp;gt;(data);
        return;
    }
    // 插入在左子树
    if(data &amp;lt; node-&amp;gt;data)
    {
        inseartNode(node-&amp;gt;left, data);
        // 树不平衡时
        if(getTreeHight(node-&amp;gt;left) - getTreeHight(node-&amp;gt;right) &amp;gt; 1)
        {
            // 当值比左节点的值小时，则进行单右旋
            if(data &amp;lt; node-&amp;gt;left-&amp;gt;data)
            {
                LL(node);
            }
            // 否则进行左右旋
            else
            {
                RLR(node);
            }
        }  
    }
    // 插入在右子树
    else
        {
            inseartNode(node-&amp;gt;right, data);
            // 树不平衡时
            if(getTreeHight(node-&amp;gt;right) - getTreeHight(node-&amp;gt;left) &amp;gt; 1)
            {
                // 当值比右节点的值大时，则进行单左旋
                if(data &amp;gt;= node-&amp;gt;right-&amp;gt;data)
                {
                    RR(node);
                }
                // 否则进行右左旋
                else
                {
                    LRR(node);
                }
            }

        }
   // 重新计算节点的高度，节点的深度+1
    node-&amp;gt;hight = maxHight(getTreeHight(node-&amp;gt;left), getTreeHight(node-&amp;gt;right)) + 1;
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::inseartData(const T data)
{
    // 如果为空树
    if(isEmpty())
    {
        root = new AvrTreeNode&amp;lt;T&amp;gt;(data);
        root-&amp;gt;hight = 0;
        return;
    }
    inseartNode(root, data);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的删除&#34;&gt;数据的删除&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 数据的删除
template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::deleteNodeAll(AvrTreeNode&amp;lt;T&amp;gt; *node)
{
    if(node == 0)
    {
        return;
    }
    // 删除左节点
    deleteNodeAll(node-&amp;gt;left);
    // 删除右节点
    deleteNodeAll(node-&amp;gt;right);
    // 释放节点
    delete node;

}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::clear()
{
    // 如果为空树，直接返回
    if(root == 0)
    {
        return;
    }
    deleteNodeAll(root);
}

template&amp;lt;class T&amp;gt;
bool AvrTree&amp;lt;T&amp;gt; ::deleteNode(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp; node, const T data)
{
    // 如果节点为空，直接返回，表示未找到数据
    if(!node)
    {
        cout &amp;lt;&amp;lt; &amp;quot;no find:&amp;quot; &amp;lt;&amp;lt; data &amp;lt;&amp;lt; endl;
        return false;
    }
    // 找到数据节点
    if(data == node-&amp;gt;data)
    {
        AvrTreeNode&amp;lt;T&amp;gt; *temp = node;
        // 只有右节点
        if(!node-&amp;gt;left)
        {
            node = node-&amp;gt;right;
        }
        // 只有左节点
        else if(!node-&amp;gt;right)
        {
            node = node-&amp;gt;left;
        }
        else
        {
            // 采用合并的方式进行删除节点
            temp = node-&amp;gt;left;
            // 找到左子树的做大值
            while (temp-&amp;gt;right)
            {
                temp = temp-&amp;gt;right;
            }
            temp-&amp;gt;right = node-&amp;gt;right;
            temp = node;
            node = node-&amp;gt;left;
             // 是否对树进行调整
            if(getTreeHight(node-&amp;gt;left)-getTreeHight(node-&amp;gt;right) &amp;gt; 1)
            {
                // 值比最大值大或者等于，就采用单左旋
                if(data &amp;gt;= node-&amp;gt;right-&amp;gt;data)
                {
                    RR(node);
                }
                //采用先右旋在左旋
                else
                {
                    LRR(node);
                }

            }
        }
        // 删除节点，返回
        delete temp;
        if(node)
        {
            node-&amp;gt;hight = maxHight(getTreeHight(node-&amp;gt;right), getTreeHight(node-&amp;gt;right)) + 1;
        }
        return true;
    }
    // 在左子树查找
    else if(data &amp;lt; node-&amp;gt;data)
    {
        deleteNode(node-&amp;gt;left, data);
        // 是否对树进行调整
        if(getTreeHight(node-&amp;gt;left)-getTreeHight(node-&amp;gt;right) &amp;gt; 1)
        {
            // 如果值比左子树小，就采用单右旋，
            if(data &amp;lt; node-&amp;gt;left-&amp;gt;data)
            {
                LL(node);
            }
            // 采用先左旋在右旋
            else
            {
                RLR(node);
            }
        }
    }
    // 在右子树查找
    else
    {
        deleteNode(node-&amp;gt;right, data);
        // 是否要对树进行调整
        if(getTreeHight(node-&amp;gt;right) - getTreeHight(node-&amp;gt;left) &amp;gt; 1)
        {
            // 值比最大值大或者等于，就采用单左旋
            if(data &amp;gt;= node-&amp;gt;right-&amp;gt;data)
            {
                RR(node);
            }
            // 采用先右旋在左旋
            else
            {
                LRR(node);
            }
        }

    }
    // 对节点的深度进行调整
    node-&amp;gt;hight = maxHight(getTreeHight(node-&amp;gt;right), getTreeHight(node-&amp;gt;right)) + 1;
}

template&amp;lt;class T&amp;gt;
bool AvrTree&amp;lt;T&amp;gt; ::remove(const T data)
{
    // 如果为空树
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;this tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return false;
    }
    return deleteNode(root, data);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的查询&#34;&gt;数据的查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历、中序遍历、后续遍历、值查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 数据的查询
template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::DLR(AvrTreeNode&amp;lt;T&amp;gt; *node)
{
    if(!node)
    { 
        return;
    }
    // 前序遍历(DLR)(根-&amp;gt;左-&amp;gt;右)
    cout &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;-&amp;gt;&amp;quot;;
    DLR(node-&amp;gt;left);
    DLR(node-&amp;gt;right);
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::LDR(AvrTreeNode&amp;lt;T&amp;gt; *node)
{
    if(!node)
    {
        return;
    }
     // 中序遍历(LDR)(左-&amp;gt;根-&amp;gt;右)
    LDR(node-&amp;gt;left);
    cout &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;-&amp;gt;&amp;quot;;
    LDR(node-&amp;gt;right);
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::LRD(AvrTreeNode&amp;lt;T&amp;gt; *node)
{
    if(!node)
    {
        return;
    }
     // 后序遍历(LRD)(左-&amp;gt;右-&amp;gt;根)
    LRD(node-&amp;gt;left);
    LRD(node-&amp;gt;right);
    cout &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;-&amp;gt;&amp;quot;;
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::showNodeByDLR()
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;this tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }
    // 遍历树
    AvrTreeNode&amp;lt;T&amp;gt; *node = root;
    cout &amp;lt;&amp;lt; &amp;quot;DLR: &amp;quot;;
    DLR(node);  
    cout &amp;lt;&amp;lt; endl;
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::showNodeByLDR()
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;this tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }
    // 遍历树
    AvrTreeNode&amp;lt;T&amp;gt; *node = root;
    cout &amp;lt;&amp;lt; &amp;quot;LDR: &amp;quot;;
    LDR(node); 
    cout &amp;lt;&amp;lt; endl; 
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::showNodeByLRD()
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;this tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }
    // 遍历树
    AvrTreeNode&amp;lt;T&amp;gt; *node = root;
    cout &amp;lt;&amp;lt; &amp;quot;LRD: &amp;quot;;
    LRD(node); 
    cout &amp;lt;&amp;lt; endl; 
}

template&amp;lt;class T&amp;gt;
bool AvrTree&amp;lt;T&amp;gt; ::LVRSearchData(const T data)
{
   // 如果树为空就直接返回
   if(isEmpty())
   {
       return false;
   }
   AvrTreeNode&amp;lt;T&amp;gt; *node = root;
   while (node)
   {
       if(data == node-&amp;gt;data)
       {
           return true;
       }
       else if(data &amp;lt; node-&amp;gt;data)
       {
           node = node-&amp;gt;left;
       }
       else
       {
           node = node-&amp;gt;right;
       }
   }
   return false;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;树的旋转&#34;&gt;树的旋转&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;单左旋 单右旋 左右旋 右左旋&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 节点的旋转
template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::LL(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp; node)
{
    // 临时节点为节点的左节点
    AvrTreeNode&amp;lt;T&amp;gt; *temp = node-&amp;gt;left;
    // 节点的左节点指向临时节点的右节点
    node-&amp;gt;left = temp-&amp;gt;right;
    // 临时节点的右节点指向节点(将临时节点的设置为根)
    temp-&amp;gt;right = node;
    // 重新获得树的高度
    temp-&amp;gt;hight = maxHight(getTreeHight(temp-&amp;gt;left), getTreeHight(temp-&amp;gt;right)) + 1;
    node-&amp;gt;hight = maxHight(getTreeHight(node-&amp;gt;left), getTreeHight(node-&amp;gt;right)) + 1;
    // 经node 重新指向temp, 即将temp设置为根节点，防止树的断
    node = temp; 
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::RR(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp; node)
{
    // 临时节点为节点的右节点
    AvrTreeNode&amp;lt;T&amp;gt; *temp = node-&amp;gt;right;
    // 节点的右节点指向临时节点的节点
    node-&amp;gt;right = temp-&amp;gt;left;
    // 临时节点的左节点指向节点
    temp-&amp;gt;left = node;
    // 重新计算树的高度
    temp-&amp;gt;hight = maxHight(getTreeHight(temp-&amp;gt;left), getTreeHight(temp-&amp;gt;right)) + 1;
    node-&amp;gt;hight = maxHight(getTreeHight(node-&amp;gt;left), getTreeHight(node-&amp;gt;right)) + 1;
     // 经node 重新指向temp, 即将temp设置为根节点，防止树的断
    node = temp;
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::RLR(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp; node)
{
    // 先进行左旋
    RR(node-&amp;gt;left);
    // 在进行右旋
    LL(node);
}

template&amp;lt;class T&amp;gt;
void AvrTree&amp;lt;T&amp;gt; ::LRR(AvrTreeNode&amp;lt;T&amp;gt; *&amp;amp; node)
{
    // 先进行右旋
    LL(node-&amp;gt;right);
    // 在进行左旋
    RR(node);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
int main(int argc, char const *argv[])
{
    AvrTree&amp;lt;int&amp;gt; avr;
    avr.inseartData(12);
    avr.inseartData(42);
    avr.inseartData(93);
    avr.inseartData(4);
    avr.inseartData(15);
    avr.inseartData(66);
    avr.inseartData(97);
    avr.showNodeByDLR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLDR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLRD();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    bool ok = avr.remove(42);
    cout &amp;lt;&amp;lt; &amp;quot;remove is:&amp;quot; &amp;lt;&amp;lt; ok &amp;lt;&amp;lt; endl;
    avr.showNodeByDLR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLDR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLRD();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    bool is = avr.remove(12);
    cout &amp;lt;&amp;lt; &amp;quot;remove is:&amp;quot; &amp;lt;&amp;lt; is &amp;lt;&amp;lt; endl;
    avr.showNodeByDLR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLDR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLRD();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    bool is1 = avr.remove(661);
    cout &amp;lt;&amp;lt; &amp;quot;remove1 is:&amp;quot; &amp;lt;&amp;lt; is1 &amp;lt;&amp;lt; endl;
    avr.showNodeByDLR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLDR();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    avr.showNodeByLRD();
    cout &amp;lt;&amp;lt; &amp;quot;***********************************&amp;quot; &amp;lt;&amp;lt; endl;
    bool ok_ = avr.LVRSearchData(66);
    cout &amp;lt;&amp;lt; &amp;quot;SearchData is:&amp;quot; &amp;lt;&amp;lt; ok_ &amp;lt;&amp;lt; endl;
    system(&amp;quot;pause&amp;quot;);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/tree/avr_tree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/tree/avr_tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-Binary search tree go实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-go%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Wed, 05 Jan 2022 21:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-go%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-go%E5%AE%9E%E7%8E%B0/1.gif" alt="Featured image of post 数据结构-Binary search tree go实现" /&gt;&lt;h2 id=&#34;二叉查找树&#34;&gt;二叉查找树&lt;/h2&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;

// 定义树的节点
type binarySearchTreeNode struct {
	info  int    // 定义存储的内容
	left  *binarySearchTreeNode  // 左节点
	right *binarySearchTreeNode  // 右节点
}

// 定义树
type BinarySearchTree struct {
	root   *binarySearchTreeNode   // 定义根节点
	numNodes  int                    // 节点树
}

// 创建节点
func creatNode(data int) *binarySearchTreeNode{
	return &amp;amp;binarySearchTreeNode{
		info:  data,
		left:  nil,
		right: nil,
	}
}

// 节点的数量
func (b *BinarySearchTree)GetNodeNum()int{
	return b.numNodes
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;增删改查&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据的插入&#34;&gt;数据的插入&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 节点的插入
func (b *BinarySearchTree) InsertNode(data int)  {
	newNode := creatNode(data)
	// 如果为空树
	if b.root == nil{
		b.root = newNode
		b.numNodes++
		return
	}
	node := b.root
	for {
		// 当值小于节点的值时，就往左子树插入
		if data &amp;lt; node.info{
			// 左节点为空，直接插入,跳出循环
			if node.left == nil{
				node.left = newNode
				break
			}else{
				// 否则继续往左子树插
				node = node.left
			}
		}else{
			// 当值大于等于节点的值时，就往右子树插入
			// 右节点为空，直接插入,跳出循环
			if node.right == nil{
				node.right = newNode
				break
			}else {
				// 否则继续往右子树插
				node = node.right
			}
		}
	}
	// 节点树+1
	b.numNodes++
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的删除&#34;&gt;数据的删除&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;复制删除法：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;将被删除节点的左子树的最大值或者右子树的最小值复制给被删除的节点的数值，
然后删除左子树的最大值的节点或者右子树的最小值的节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;2.合并删除法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从删除的节点的两棵子树合并未一棵树，然后将这颗树连接到删除节点的父节点
具体操作：左子树的最大值左作为有子树的父节点，左子树的根节点作为这棵树的根节点
或右子树的最小值作为左子树的父节点，右子树的根节点作为这棵树的根节点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
// 清空树
func (b *BinarySearchTree) Clear(){
	b.root = nil
	b.numNodes = 0
}

//合并删除法：
//从删除的节点的两棵子树合并未一棵树，然后将这颗树连接到删除节点的父节点
//具体操作：左子树的最大值左作为有子树的父节点，左子树的根节点作为这棵树的根节点
//或右子树的最小值作为左子树的父节点，右子树的根节点作为这棵树的根节点
//
func (b *BinarySearchTree)deleteByMerge(node **binarySearchTreeNode) {
	// 如果右节点为nil
	if (*node).right == nil{
		*node = (*node).left

	}else if (*node).left == nil{
		*node = (*node).right
	}else{
		// 找出左子树的最大值
		temp := (*node).left
		for ; temp.right != nil; temp = temp.right{}
		// 左子树的最大值的右节点指向右子树
		temp.right = (*node).right
		// node的头指针指向这个树既指向左子树的头节点
		*node = (*node).left
	}


}

// 移除节点，通过合并的方法
func (b *BinarySearchTree)RemoveByMerge(data int) bool{
	// 如果为空树
	if b.root == nil{
		return false
	}
	// 找到值的节点
	node := b.root
	prev := b.root
	for {
		if node == nil{
			return false
		}
		if node.info == data{
			break
		}
		prev = node
		if data &amp;lt; node.info{
			node = node.left
		}else {
			node = node.right
		}
	}
	if node == b.root{
		b.deleteByMerge(&amp;amp;b.root)
	}else if node == prev.left{
		b.deleteByMerge(&amp;amp;prev.left)
	}else{
		b.deleteByMerge(&amp;amp;prev.right)
	}
	// 节点树-1
	b.numNodes--
	return true
}

/*
复制删除法：
将被删除节点的左子树的最大值或者右子树的最小值复制给被删除的节点的数值，
然后删除左子树的最大值的节点或者右子树的最小值的节点
*/
func (b *BinarySearchTree)deleteByCopy(node **binarySearchTreeNode) {
	// 如果右节点为nil
	if (*node).right == nil{
		*node = (*node).left
	}else if (*node).left == nil{
		*node = (*node).right
	}else{
		// 找出左子树的最大值
		temp := (*node).left
		prev := *node  // 左子树最大值的最前驱节点
		for ; temp.right != nil; temp = temp.right{
			prev = temp
		}
		// 左子树的最大值复制给node
		(*node).info = temp.info
		if prev == *node{ // 如果左子树的最大值为node的node的子节点
			prev.left = temp.left  // 先驱节点的左节点指向左子树最大节点的左节点
		}else{
			prev.right = temp.left  // 先驱节点的右节点指向左子树最大节点的右节点
		}

	}


}

// 移除节点，通过复制的方法
func (b *BinarySearchTree)RemoveByCopy(data int) bool{
	// 如果为空树
	if b.root == nil{
		return false
	}
	// 找到值的节点
	node := b.root
	prev := b.root
	for {
		if node == nil{
			return false
		}
		if node.info == data{
			break
		}
		prev = node
		if data &amp;lt; node.info{
			node = node.left
		}else {
			node = node.right
		}
	}
	//b.deleteByCopy(&amp;amp;node)
	if node == b.root{
		b.deleteByCopy(&amp;amp;b.root)
	}else if node == prev.left{
		b.deleteByCopy(&amp;amp;prev.left)
	}else{
		b.deleteByCopy(&amp;amp;prev.right)
	}
	// 节点树-1
	b.numNodes--
	return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的查询&#34;&gt;数据的查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历、中序遍历、后续遍历、值查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 前序遍历
func (b *BinarySearchTree) nLR(node *binarySearchTreeNode){
	if node == nil{
		return
	}
	fmt.Printf(&amp;quot;%d-&amp;gt;&amp;quot;, node.info)
	b.nLR(node.left)
	b.nLR(node.right)
}

// 中序遍历
func (b *BinarySearchTree)lNR(node *binarySearchTreeNode){
	if node == nil{
		return
	}
	b.lNR(node.left)
	fmt.Printf(&amp;quot;%d-&amp;gt;&amp;quot;, node.info)
	b.lNR(node.right)
}

// 后序遍历
func (b *BinarySearchTree)lRN(node *binarySearchTreeNode){
	if node == nil{
		return
	}
	b.lRN(node.left)
	b.lRN(node.right)
	fmt.Printf(&amp;quot;%d-&amp;gt;&amp;quot;, node.info)
}

// 前序显示
func (b *BinarySearchTree)ShowNLR(){
	if b.root == nil{
		fmt.Println(&amp;quot;zhe tree is empty&amp;quot;)
		return
	}
	fmt.Print(&amp;quot;NLR:&amp;quot;)
	node := b.root
	b.nLR(node)
	fmt.Println()
}

// 中序显示
func (b *BinarySearchTree)ShowLNR(){
	if b.root == nil{
		fmt.Println(&amp;quot;zhe tree is empty&amp;quot;)
		return
	}
	fmt.Print(&amp;quot;LNR:&amp;quot;)
	node := b.root
	b.lNR(node)
	fmt.Println()
}

// 后序显示
func (b *BinarySearchTree)ShowLRN(){
	if b.root == nil{
		fmt.Println(&amp;quot;zhe tree is empty&amp;quot;)
		return
	}
	fmt.Print(&amp;quot;LRN:&amp;quot;)
	node := b.root
	b.lRN(node)
	fmt.Println()
}

// 查找值是否存在
func (b *BinarySearchTree)IsValue(data int) bool {
	if b.root == nil{
		return false
	}
	node :=  b.root
	for {
		if node == nil{
			return false
		}
		if node.info == data {
			return  true
		}
		if data &amp;lt; node.info{
			node = node.left
		}else {
			node = node.right
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;树的创建&#34;&gt;树的创建&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func NewBinarySearchTree() *BinarySearchTree {
	return &amp;amp;BinarySearchTree{
		root:     nil,
		numNodes: 0,
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/tree/binary_search_tree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/tree/binary_search_tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-Binary search tree c&#43;&#43;实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-c-%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Sat, 01 Jan 2022 21:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-c-%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-binary-search-tree-c-%E5%AE%9E%E7%8E%B0/1.gif" alt="Featured image of post 数据结构-Binary search tree c&#43;&#43;实现" /&gt;&lt;h2 id=&#34;二叉查找树&#34;&gt;二叉查找树&lt;/h2&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;

// 节点的定义
template&amp;lt;class T&amp;gt;
class BinarySearchTreeNode
{
public:
    BinarySearchTreeNode()
    {
        left = 0;
        right = 0;
    }
    BinarySearchTreeNode(T data)
    {
        this-&amp;gt;data = data;
        left =  0;
        right = 0;
    }
    ~BinarySearchTreeNode(){};
    T data;  // 保存的节点的数据
    BinarySearchTreeNode *left; // 指向左节点
    BinarySearchTreeNode *right; // 指向右节点
};


// 树的定义
template&amp;lt;class T&amp;gt;
class BinarySearchTree
{
private:
    BinarySearchTreeNode&amp;lt;T&amp;gt; *root;  // 定义头节点
    int treeNodeNum;             // 树的节点数
    void deleteNodeAll(BinarySearchTreeNode&amp;lt;T&amp;gt; *node); // 删除所有节点
    // 显示节点
    void DLR(BinarySearchTreeNode&amp;lt;T&amp;gt; *node);
    void LDR(BinarySearchTreeNode&amp;lt;T&amp;gt; *node);
    void LRD(BinarySearchTreeNode&amp;lt;T&amp;gt; *node);
    // 删除*&amp;amp;代表指针引用
    void deleteNodeByMerge(BinarySearchTreeNode&amp;lt;T&amp;gt;*&amp;amp; node); // 合并删除
    void deleteNodeByCopy(BinarySearchTreeNode&amp;lt;T&amp;gt;*&amp;amp; node);  // 复制删除
public:
    BinarySearchTree()
    {
        root = 0;
        treeNodeNum = 0;
    };
    ~BinarySearchTree();
    // 清空树
    void clear();
    // 节点的个数
    int Nodes()
    {
        return treeNodeNum;
    }
    // 是否为空树
    bool isEmpty()
    {
        return root == 0;
    }
    // 插入数据
    void inseartNode(const T data);
    // 深度优先遍历树
    // 前序遍历(DLR 根-&amp;gt;左-&amp;gt;右)
    void showNodeByDLR();
    // 中序遍历(LDR 左-&amp;gt;根-&amp;gt;右)
    void showNodeByLDR();
    // 后序遍历(LRD 左-&amp;gt;右-&amp;gt;根)
    void showNodeByLRD();
    // 删除节点的数据
    // 合并删除
    bool removeNodeMerge(const T data);
    // 复制删除
    bool removeNodeCopy(const T data);
    // 查找数据
    bool SearchData(const T data);
};

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;增删改查&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;数据的插入&#34;&gt;数据的插入&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::inseartNode(const T data)
{
    BinarySearchTreeNode&amp;lt;T&amp;gt; *new_node = new BinarySearchTreeNode&amp;lt;T&amp;gt;(data);
    // 如果为空树
    if(isEmpty())
    {
        root = new_node;  // 新建节点设置为root 节点
        treeNodeNum ++;   // 树的节点数+1
        return;
    }
    BinarySearchTreeNode&amp;lt;T&amp;gt; *node = root;
    // 遍历树， 找到插入的节点的位置
    while (node != 0)
    {
        // 当节点的值大于插入的值时，就插入到左子数
        if(node-&amp;gt;data &amp;gt; data)
        {
            // 左节点为nill, 将新节点赋值给节点的左节点
            if(node-&amp;gt;left == NULL)
            {
                node-&amp;gt;left = new_node;
                break;     // 推出循环
            }
            else
            {
                node = node-&amp;gt;left;
                continue;     // 继续查找下一个节点
            }
        }
        else
        {
            // 如果右节点为nill, 右节点-&amp;gt;新节点
            if(node-&amp;gt;right == NULL)
            {
                node-&amp;gt;right = new_node;
                break;
            }
            else
            {
                node = node-&amp;gt;right;
                continue;
            }

        }    
    }
    treeNodeNum ++; // 数的节点数+1

}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的删除&#34;&gt;数据的删除&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 采用递归的方式删除节点
template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::deleteNodeAll(BinarySearchTreeNode&amp;lt;T&amp;gt; *node)
{
    // 如果的空树就结束递归
    if(node == 0)
    {
        return;
    }
    deleteNodeAll(node-&amp;gt;left);
    deleteNodeAll(node-&amp;gt;right);
    cout &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; endl;

    delete node;   // 释放资源
}
template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::clear()
{
    deleteNodeAll(root);   // 清空所有节点
    treeNodeNum = 0;    // 树的节点数为0
}

/*
合并删除法：
从删除的节点的两棵子树合并未一棵树，然后将这颗树连接到删除节点的父节点
具体操作：左子树的最大值左作为有子树的父节点，左子树的根节点作为这棵树的根节点 
或右子树的最小值作为左子树的父节点，右子树的根节点作为这棵树的根节点
*/
template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::deleteNodeByMerge(BinarySearchTreeNode&amp;lt;T&amp;gt;*&amp;amp; node)
{
    // 左子树作为root作为树的root
    /*
    BinarySearchTreeNode&amp;lt;T&amp;gt; *temp = node;
    if(node != 0)
    {
        // 如果节点的左节点为空
        if(!node-&amp;gt;left)
        {
            node = node-&amp;gt;right;  //直接指向node的右节点
        }
        // 如果右子节点为空
        else if(!node-&amp;gt;right)
        {
            node = node-&amp;gt;left;  // 直接指向node的左节点
        }
        else{
            temp = node-&amp;gt;left; // temp 为node的左节点
            // 找出左节点中的最大值
            while (temp-&amp;gt;right)
            {
                temp = temp-&amp;gt;right;
            }
            temp-&amp;gt;right = node-&amp;gt;right; // 左子树的最大值指向右节点
            temp = node;           
            node = node-&amp;gt;left;         // 左子树作为两颗树的头节点
            
        }
        delete temp;
    } */
    // 右子树的root作为树的root
    BinarySearchTreeNode&amp;lt;T&amp;gt; *temp = node;
    if(node)
    {
        if(!node-&amp;gt;left)
        {
            node = node-&amp;gt;right;
        }
        else if(!node-&amp;gt;right)
        {
            node = node-&amp;gt;left;
        }
        else
        {
            temp = node-&amp;gt;right;
            while (temp-&amp;gt;left)
            {
                temp = temp -&amp;gt;left;
            }
            temp -&amp;gt;left = node-&amp;gt;left;
            temp = node;
            node = node-&amp;gt;right;
        }
        delete temp;
    }
}

/*
复制删除法：
将被删除节点的左子树的最大值或者右子树的最小值复制给被删除的节点的数值，
然后删除左子树的最大值的节点或者右子树的最小值的节点
*/
template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::deleteNodeByCopy(BinarySearchTreeNode&amp;lt;T&amp;gt;*&amp;amp; node)
{
    // 复制右子树的最小值
    /*
    BinarySearchTreeNode&amp;lt;T&amp;gt; *prev = 0;       // 复制节点(右子树最小值被删节点)的前驱节点
    BinarySearchTreeNode&amp;lt;T&amp;gt; *temp = node;
    if(node)
    {
        if(!node-&amp;gt;left)
        {
            node = node-&amp;gt;right;
        }
        else if(!node-&amp;gt;right)
        {
            node = node-&amp;gt;left;
        }
        else
        {
            temp = node-&amp;gt;right;
            // 找到右子树的最小值
            while (temp-&amp;gt;left)
            {
                prev = temp;
                temp = temp-&amp;gt;left;
            }
            node-&amp;gt;data = temp-&amp;gt;data;   // 将右子树的最小值复制给被删节点
            // 当右子树的首节点没有左节点时
            if(prev == node)
            {
                node-&amp;gt;right = temp-&amp;gt;right; // 直接指向被删节点的右节点
            }
            else
            {
                prev-&amp;gt;left = temp-&amp;gt;right; // 先驱节点的左节点指向删除节点的右节点
            }
        }
        delete temp;
    }*/
    // 复制左子树的最大值
    BinarySearchTreeNode&amp;lt;T&amp;gt; *prev = 0;       // 复制节点(右子树最小值被删节点)的前驱节点
    BinarySearchTreeNode&amp;lt;T&amp;gt; *temp = node;
    if(node)
    {
        if(!node-&amp;gt;left)
        {
            node = node-&amp;gt;right;
        }
        else if(!node-&amp;gt;right)
        {
            node = node-&amp;gt;left;
        }
        else
        {
            temp = node-&amp;gt;left;
            // 找到左子树的最大值
            while (temp-&amp;gt;right)
            {
                prev = temp;
                temp = temp-&amp;gt;right;
            }
            node-&amp;gt;data = temp-&amp;gt;data;   // 将左子树的最大值复制给被删节点
            // 当左子树的首节点没有右节点时
            if(prev == node)
            {
                node-&amp;gt;left = temp-&amp;gt;left; // 直接指向被删节点的左节点
            }
            else
            {
                prev-&amp;gt;right = temp-&amp;gt;left; // 先驱节点的右节点指向删除节点的左节点
            }
        }
        delete temp;
    }


}

// 合并删除
template&amp;lt;class T&amp;gt;
bool BinarySearchTree&amp;lt;T&amp;gt; ::removeNodeMerge(const T data)
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;the tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return false;
    }
    BinarySearchTreeNode&amp;lt;T&amp;gt; *prev_node = 0;  // 头节点
    BinarySearchTreeNode&amp;lt;T&amp;gt; *node = root;
    // 找到值的节点
    while (node)
    {
        // 如果node的值等于data
        if(node-&amp;gt;data == data)
        {
            break;
        }
        prev_node = node;  // node的头节点
        // node 的值大于deta 就往左子树找
        if(node-&amp;gt;data &amp;gt; data)
        {
            node = node-&amp;gt;left;
        }
        // node 的值小于 data 就往右子树找
        else{
            node = node-&amp;gt;right;
        }
    }
    // 找到值的节点了
    if(node != 0 &amp;amp;&amp;amp; node-&amp;gt;data == data)
    {
        // 如果是头节点
        if(node == root)
        {
            // deleteNodeByMerge(root);
            deleteNodeByCopy(root);
        }
        // 其他节点的左节点==data
        else if(prev_node-&amp;gt;left == node)
        {
            // deleteNodeByMerge(prev_node-&amp;gt;left);
            deleteNodeByCopy(prev_node-&amp;gt;left);
        }
        else
        {
            // deleteNodeByMerge(prev_node-&amp;gt;right);
            deleteNodeByCopy(prev_node-&amp;gt;right);
        }
        treeNodeNum--; //节点数减一
        return true;
    }
    else
    {
        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; &amp;quot;no exits tree&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return false;
}

// 复制删除
template&amp;lt;class T&amp;gt;
bool BinarySearchTree&amp;lt;T&amp;gt; ::removeNodeCopy(const T data)
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;the tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return false;
    }
    BinarySearchTreeNode&amp;lt;T&amp;gt; *node = root;
    BinarySearchTreeNode&amp;lt;T&amp;gt; *prev = 0;
    // 找到数据的节点
    while (node)
    {
        // 找到值就跳出循环
        if(node-&amp;gt;data == data)
        {
            break;
        }
        // 未找到，父节点给prev
        prev = node;
        // data &amp;gt; value -&amp;gt; 右子树查找
        if(data &amp;gt; node-&amp;gt;data)
        {
            node = node-&amp;gt;right;
        }
        // 左子树查找
        else
        {
            node = node-&amp;gt;left;
        }
    }
    // 找到节点
    if(node &amp;amp;&amp;amp; node-&amp;gt;data == data)
    {
        // 节点为根节点
        if(node == root)
        {
            deleteNodeByCopy(root);
        }
        // 右节点
        else if(prev-&amp;gt;right == node)
        {
            deleteNodeByCopy(prev-&amp;gt;right);
        }
        // 左节点
        else
        {
            deleteNodeByCopy(prev-&amp;gt;left);
        }
        // 节点数-1
        treeNodeNum--;
        return true;
    }
    // 未找到
    else
    {
        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; &amp;quot;no exits in zhe tree&amp;quot; &amp;lt;&amp;lt; endl;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;数据的查询&#34;&gt;数据的查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;前序遍历、中序遍历、后续遍历、值查询&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::DLR(BinarySearchTreeNode&amp;lt;T&amp;gt; *node)
{
    if(!node)
    { 
        return;
    }
    // 前序遍历(DLR)(根-&amp;gt;左-&amp;gt;右)
    cout &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;-&amp;gt;&amp;quot;;
    DLR(node-&amp;gt;left);
    DLR(node-&amp;gt;right);
}
template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::LDR(BinarySearchTreeNode&amp;lt;T&amp;gt; *node)
{
    if(!node)
    {
        return;
    }
     // 中序遍历(LDR)(左-&amp;gt;根-&amp;gt;右)
    LDR(node-&amp;gt;left);
    cout &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;-&amp;gt;&amp;quot;;
    LDR(node-&amp;gt;right);
}
template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::LRD(BinarySearchTreeNode&amp;lt;T&amp;gt; *node)
{
    if(!node)
    {
        return;
    }
     // 后序遍历(LRD)(左-&amp;gt;右-&amp;gt;根)
    LRD(node-&amp;gt;left);
    LRD(node-&amp;gt;right);
    cout &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; &amp;quot;-&amp;gt;&amp;quot;;
}
template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::showNodeByDLR()
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;this tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }
    // 遍历树
    BinarySearchTreeNode&amp;lt;T&amp;gt; *node = root;
    cout &amp;lt;&amp;lt; &amp;quot;DLR: &amp;quot;;
    DLR(node);  
    cout &amp;lt;&amp;lt; endl;
}

template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::showNodeByLDR()
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;this tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }
    // 遍历树
    BinarySearchTreeNode&amp;lt;T&amp;gt; *node = root;
    cout &amp;lt;&amp;lt; &amp;quot;LDR: &amp;quot;;
    LDR(node); 
    cout &amp;lt;&amp;lt; endl; 
}

template&amp;lt;class T&amp;gt;
void BinarySearchTree&amp;lt;T&amp;gt; ::showNodeByLRD()
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;this tree is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }
    // 遍历树
    BinarySearchTreeNode&amp;lt;T&amp;gt; *node = root;
    cout &amp;lt;&amp;lt; &amp;quot;LRD: &amp;quot;;
    LRD(node); 
    cout &amp;lt;&amp;lt; endl; 
}

template&amp;lt;class T&amp;gt;
bool BinarySearchTree&amp;lt;T&amp;gt; ::SearchData(const T data)
{
    if(isEmpty())
    {
        return false;
    }
    BinarySearchTreeNode&amp;lt;T&amp;gt; *node = root;
    while (node)
    {
        if(node-&amp;gt;data == data)
        {
            return true;
        }
        else if(data &amp;gt; node-&amp;gt;data)
        {
            node = node-&amp;gt;right;
        }
        else
        {
            node = node-&amp;gt;left;
        }
    }
    return false
    ;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
int main(int argc, char const *argv[])
{
    BinarySearchTree&amp;lt;int&amp;gt; tree;
    tree.inseartNode(5);
    tree.inseartNode(3);
    tree.inseartNode(2);
    tree.inseartNode(4);
    tree.inseartNode(6);
    tree.inseartNode(5);
    tree.inseartNode(7);
    // 前序遍历
    tree.showNodeByDLR();
    // 中序遍历
    tree.showNodeByLDR();
    // 后序遍历
    tree.showNodeByLRD();
    cout &amp;lt;&amp;lt; &amp;quot;*******************************&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; tree.removeNodeMerge(5)  &amp;lt;&amp;lt;  endl;
    // 前序遍历
    tree.showNodeByDLR();
    // 中序遍历
    tree.showNodeByLDR();
    // 后序遍历5
    tree.showNodeByLRD();
    cout &amp;lt;&amp;lt; &amp;quot;nodes is:&amp;quot; &amp;lt;&amp;lt; tree.Nodes() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;*******************************&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; tree.removeNodeCopy(7)  &amp;lt;&amp;lt;  endl;
    // 前序遍历
    tree.showNodeByDLR();
    // 中序遍历
    tree.showNodeByLDR();
    // 后序遍历
    tree.showNodeByLRD();
    cout &amp;lt;&amp;lt; &amp;quot;nodes is:&amp;quot; &amp;lt;&amp;lt; tree.Nodes() &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; &amp;quot;*******************************&amp;quot; &amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; tree.SearchData(21) &amp;lt;&amp;lt; endl;
    system(&amp;quot;pause&amp;quot;);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/tree/binary_tree&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/tree/binary_tree&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-栈(基于单项链表)&amp;&amp;队列(基于双向链表)go实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Fri, 31 Dec 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E5%AE%9E%E7%8E%B0/1.jpg" alt="Featured image of post 数据结构-栈(基于单项链表)&amp;&amp;队列(基于双向链表)go实现" /&gt;&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;p&gt;基于单向链表实现&lt;/p&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type stackData struct {
	list *Singly_linked_list.LinkedList
}

// 获得栈的长度
func (s *stackData)Len() int{
	return s.list.Len()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 将数据插入栈顶
func (s *stackData)Push(data interface{}) {
	s.list.AddToHead(data)
}

// 将数据从栈顶取出，并删除数据
func (s *stackData)Pop()interface{}{
	data := s.list.QuireIndex(0)
	// 栈不为空, 删除栈顶数据
	if data != nil{
		s.list.DeleteToHead()
	}
	return data
}

// 将数据取出，不删除数据
func (s *stackData)GetTopValue()interface{}{
	return s.list.QuireIndex(0)
}

// 展示栈
func (s *stackData)ShowStack() {
	s.list.QuireAll()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建栈&#34;&gt;创建栈&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func NewStackData()*stackData{
	return  &amp;amp;stackData{list:Singly_linked_list.NewLinkedList()}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于双向链表实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据结构定义-1&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type queueData struct {
	list *double_linked_list.DoubleList
}

// 获得队列的大小
func (q *queueData)Len() int{
	return q.list.Len()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的操作&#34;&gt;数据的操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 将数据队尾
func (q *queueData)EnQueue(data interface{}) {
	q.list.AddToTail(data)
}

// 将数据从队首取出，并删除数据
func (q *queueData)DeQueue()interface{}{
	data := q.list.QuireIndex(0)
	// 栈不为空, 删除栈顶数据
	if data != nil{
		q.list.DeleteToHead()
	}
	return data
}

// 将数据取出，不删除数据
func (q *queueData)GetTopQueueValue()interface{}{
	return q.list.QuireIndex(0)
}

// 展示队列
func (q *queueData)ShowQueue() {
	q.list.QuireAll()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建队列&#34;&gt;创建队列&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func NewQueueData()*queueData{
	return  &amp;amp;queueData{list:double_linked_list.NewDoubleLinkedList()}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/stack_queue/queue&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/stack_queue/queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/stack_queue/stack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/stack_queue/stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-栈(基于单项链表)&amp;&amp;队列(基于双向链表)c&#43;&#43;实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8c-%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Fri, 31 Dec 2021 21:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8c-%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%9F%BA%E4%BA%8E%E5%8D%95%E9%A1%B9%E9%93%BE%E8%A1%A8%E9%98%9F%E5%88%97%E5%9F%BA%E4%BA%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8c-%E5%AE%9E%E7%8E%B0/1.jpg" alt="Featured image of post 数据结构-栈(基于单项链表)&amp;&amp;队列(基于双向链表)c&#43;&#43;实现" /&gt;&lt;h2 id=&#34;栈&#34;&gt;栈&lt;/h2&gt;
&lt;p&gt;基于单向链表实现&lt;/p&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
template&amp;lt;class T&amp;gt;
class Stack
{
private:
    SinglyList&amp;lt;T&amp;gt; list;  // 存储数据的链表
public:
    Stack(/* args */){};
    ~Stack();
    // 获得栈的长度
    int len()
    {
        return list.getlen();
    }
    // 清空栈
    void clear();
    // 判断栈是否为空s
    bool isEmpty();
    // 将数据放入栈顶
    void push(T data);
    // 获取栈顶数据，并删除数据
    bool pop(T *info);
    // 获取栈顶数据但不删除数据
    bool getTopValue(T *info);
    // 显示所有栈的数据
    void showStack();
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据操作&#34;&gt;数据操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
template&amp;lt;class T&amp;gt;
void Stack&amp;lt;T&amp;gt; ::clear()
{
    list.clear();
}

template&amp;lt;class T&amp;gt;
void Stack&amp;lt;T&amp;gt; ::push(T data)
{
    list.inseartToHead(data);
}

template&amp;lt;class T&amp;gt;
bool Stack&amp;lt;T&amp;gt; ::pop(T *info)
{
    // 判断栈顶是否有值
    if(getTopValue(info))
    {
        list.deleteToHead();  // 删除栈顶值
        return true;
    }
    return false;
}

template&amp;lt;class T&amp;gt;
bool Stack&amp;lt;T&amp;gt; ::getTopValue(T *info)
{
     // 判断栈顶是否有值
    if(list.queryIndex(0, info))
    {
        return true;
    }
    return false;
}

template&amp;lt;class T&amp;gt;
void Stack&amp;lt;T&amp;gt; ::showStack()
{
    list.queryAll();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int main()
{
    Stack&amp;lt;int&amp;gt; s;
    s.push(0);
    s.push(1);
    s.push(2);
    s.push(3);
    s.push(4);
    s.showStack();
    cout &amp;lt;&amp;lt; &amp;quot;********************************&amp;quot; &amp;lt;&amp;lt; endl;
    int info = -1;
     if(s.getTopValue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    if(s.getTopValue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    if(s.getTopValue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    cout &amp;lt;&amp;lt; &amp;quot;********************************&amp;quot; &amp;lt;&amp;lt; endl;
    s.showStack();
    cout &amp;lt;&amp;lt; &amp;quot;********************************&amp;quot; &amp;lt;&amp;lt; endl;
    if(s.pop(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    if(s.pop(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    if(s.pop(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    if(s.pop(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    cout &amp;lt;&amp;lt; &amp;quot;********************************&amp;quot; &amp;lt;&amp;lt; endl;
    s.showStack();
    cout &amp;lt;&amp;lt; &amp;quot;********************************&amp;quot; &amp;lt;&amp;lt; endl;
    system(&amp;quot;pause&amp;quot;);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;队列&#34;&gt;队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;基于双向链表实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据结构定义-1&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
template&amp;lt;class T&amp;gt;
class Queue
{
private:
    TwoWayList&amp;lt;T&amp;gt; list;  // 定义的双向链表
public:
    Queue(/* args */){};
    ~Queue();
     // 获得队列的长度
    int len()
    {
        return list.getlen();
    }
    // 清空队列
    void clear();
    // 判断栈是否为空s
    bool isEmpty();
    // 将数据存入队列尾中
    void enQueue(T data);
    // 获取获得队列数据，并删除数据
    bool deQueue(T *info);
    // 获取获得队列数据，但不删除数据
    bool getQueueValue(T *info);
    // 显示所有队列的数据
    void showQueue();
};

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的操作&#34;&gt;数据的操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
template&amp;lt;class T&amp;gt;
void Queue&amp;lt;T&amp;gt; ::clear()
{
    list.clear();
}

template&amp;lt;class T&amp;gt;
bool Queue&amp;lt;T&amp;gt; ::isEmpty()
{
    return list.isEmpty();
}

template&amp;lt;class T&amp;gt;
void Queue&amp;lt;T&amp;gt; ::enQueue(T data)
{
    list.inseartTotail(data);
}

template&amp;lt;class T&amp;gt;
bool Queue&amp;lt;T&amp;gt; ::getQueueValue(T *info)
{
    if(list.queryIndex(0, info))
    {
        return true;
    }
    return false;
}

template&amp;lt;class T&amp;gt;
bool Queue&amp;lt;T&amp;gt; ::deQueue(T *info)
{
    if(list.queryIndex(0, info))
    {
        list.deleteToHead();
        return true;
    }
    return false;
}

template&amp;lt;class T&amp;gt;
void Queue&amp;lt;T&amp;gt; ::showQueue()
{
    list.queryAll();
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试-1&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int main()
{
    Queue&amp;lt;int&amp;gt; q;
    q.enQueue(0);
    q.enQueue(1);
    q.enQueue(2);
    q.enQueue(3);
    q.enQueue(4);
    q.enQueue(5);
    q.showQueue();
    cout &amp;lt;&amp;lt; &amp;quot;**************************************&amp;quot;&amp;lt;&amp;lt; endl;
    int info = -1;
    if(q.getQueueValue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;queue top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    if(q.getQueueValue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;queue top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    if(q.getQueueValue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;queue top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    q.showQueue();
    cout &amp;lt;&amp;lt; &amp;quot;**************************************&amp;quot;&amp;lt;&amp;lt; endl;
    if(q.deQueue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;queue top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    q.showQueue();
    cout &amp;lt;&amp;lt; &amp;quot;**************************************&amp;quot;&amp;lt;&amp;lt; endl;
    if(q.deQueue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;queue top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    q.showQueue();
    cout &amp;lt;&amp;lt; &amp;quot;**************************************&amp;quot;&amp;lt;&amp;lt; endl;
    if(q.deQueue(&amp;amp;info))
    {
        cout &amp;lt;&amp;lt; &amp;quot;queue top value is: &amp;quot; &amp;lt;&amp;lt;info &amp;lt;&amp;lt; endl;
    }
    q.showQueue();
    cout &amp;lt;&amp;lt; &amp;quot;**************************************&amp;quot;&amp;lt;&amp;lt; endl;
    q.clear();
    q.showQueue();
    system(&amp;quot;pause&amp;quot;);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/stack_queue/queue&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https:https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/stack_queue/queue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/stack_queue/stack&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/stack_queue/stackhttps://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/stack_queue/stack&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-双向链表&amp;&amp;循环双向链表go语言实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Thu, 30 Dec 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1.jpg" alt="Featured image of post 数据结构-双向链表&amp;&amp;循环双向链表go语言实现" /&gt;&lt;h2 id=&#34;双向链表&#34;&gt;双向链表&lt;/h2&gt;
&lt;h3 id=&#34;数据结构的定义&#34;&gt;数据结构的定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 双向链表的节点定义
type doubleLinkedNode struct {
	info  interface{}       // 存储的数据
	prev *doubleLinkedNode  // 指向先驱节点
	next *doubleLinkedNode  // 指向后驱几点
}

// 双向链表定义
type DoubleList struct {
	Head *doubleLinkedNode   // 头节点
	Tail *doubleLinkedNode   // 尾节点
	len  int                 // 链表长度
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建节点&#34;&gt;创建节点&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func createNode(data interface{}) *doubleLinkedNode {
	return &amp;amp;doubleLinkedNode{
		info: data,
		prev: nil,
		next: nil,
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;链表的长度&#34;&gt;链表的长度&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 链表的长度
func(d *DoubleList)Len() int{
	return d.len
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的插入&#34;&gt;数据的插入&lt;/h3&gt;
&lt;h4 id=&#34;单个节点的插入&#34;&gt;单个节点的插入&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 链表的尾插法
func (d *DoubleList)AddToTail(info interface{}) *DoubleList {
	newNode := createNode(info)  // 创建新节点
	// 链表为空, 头尾节点都指向该节点
	if d.Head == nil{
		d.Head = newNode
		d.Tail = newNode
	}else{
		d.Tail.next = newNode
		newNode.prev = d.Tail
		d.Tail = d.Tail.next
	}
	// 链表长度+1
	d.len++
	return d
}

// 链表的头插法
func (d *DoubleList)AddToHead(info interface{}) *DoubleList  {
	newNode := createNode(info)  // 创建节点
	// 链表为空
	if d.Head == nil{
		d.Head = newNode
		d.Tail = newNode
	}else{
		newNode.next = d.Head    // 新节点的后驱指向头节点
		d.Head.prev = newNode    // 头节点的前驱指向新节点
		d.Head = newNode         // 将新节点设置尾头节点
	}
	// 链表长度+1
	d.len++
	return  d
}

// 链表的index
// 通过index=&amp;gt;插入链表新的节点
// index为正数 为从左-&amp;gt;右 // 0表示第一个节点
// index为负数 为从右-&amp;gt;左 // -1表示第一个节点
func (d *DoubleList)AddToIndex(index int, info interface{}) *DoubleList {
	// 当链表为空时，采用了尾插入法插入数据
	if d.Head == nil{
		return d.AddToTail(info)
	}
	// 当index大于链表的值时，默认将数据插入到链表的后面
	if int(math.Abs(float64(index))) &amp;gt; d.len-1{
		return d.AddToTail(info)
	}
	// 插入链表的头部
	if index == 0{
		return d.AddToHead(info)
	}
	// 插入到链表的末尾
	if index == -1{
		return d.AddToTail(info)
	}
	// 当index 为负数时，从右到左插入
	if index &amp;lt; 0{
		index += d.len +1
	}
	__index := 1  // 内部的index值
	// 从第二个值开始插入
	for node := d.Head; node != d.Tail; node = node.next{
		if index == __index{
			newNode := createNode(info)
			node.next.prev = newNode   // 节点的后驱节点的先驱指向新节点
			newNode.prev = node        // 新节点的前驱指向节点
			newNode.next = node.next   // 新节点的后驱指向节点的后驱
			node.next = newNode           // 节点的后驱指向新节点
			// 链表的节点数加1
			d.len ++
			return d
		}
		__index ++
	}
	return d
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;链表的合并&#34;&gt;链表的合并&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 将新的链表插入头部
func (d *DoubleList)AddListToHead(list *DoubleList)*DoubleList{
	// 两个链表都为空时
	if d.Head == nil &amp;amp;&amp;amp; list.Head == nil{
		return d
	}
	// 合并表为空
	if d.Head != nil &amp;amp;&amp;amp; list.Head == nil{
		return d
	}
	// 主表为空
	if d.Head == nil &amp;amp;&amp;amp; list.Head != nil{
		return list
	}
	// 合并表的尾指针指向主表的头
	list.Tail.next = d.Head
	d.Head.prev = list.Tail
	list.Tail = d.Tail
	// 表节点数合并
	list.len += d.len
	return list
}

// 将新的链表插入到尾部
func (d *DoubleList)AddListToTail(list *DoubleList)*DoubleList{
	// 两个链表都为空时
	if d.Head == nil &amp;amp;&amp;amp; list.Head == nil{
		return d
	}
	// 合并表为空
	if d.Head != nil &amp;amp;&amp;amp; list.Head == nil{
		return d
	}
	// 主表为空
	if d.Head == nil &amp;amp;&amp;amp; list.Head != nil{
		return list
	}
	// 将新表插入到主表之后
	d.Tail.next = list.Head
	list.Head.prev = d.Tail
	d.Tail = list.Tail
	d.len += list.len
	return d
}

// 经新的表插入到index
func (d *DoubleList)AddListToIndex(index int, list *DoubleList) *DoubleList {
	// 两个链表都为空时
	if d.Head == nil &amp;amp;&amp;amp; list.Head == nil{
		return d
	}
	// 合并表为空
	if d.Head != nil &amp;amp;&amp;amp; list.Head == nil{
		return d
	}
	// 主表为空
	if d.Head == nil &amp;amp;&amp;amp; list.Head != nil{
		return list
	}
	if int(math.Abs(float64(index))) &amp;gt; d.len{
		fmt.Println(&amp;quot;错误的index&amp;quot;)
		return d
	}
	if index == 0{
		return d.AddListToHead(list)
	}
	if  index == -1{
		return d.AddListToTail(list)
	}
	if index &amp;lt; 0{
		index += d.len
	}
	__index := 1
	for node := d.Head; node != d.Tail; node = node.next{
		if index == __index{
			node.next.prev = list.Tail
			list.Tail.next = node.next
			node.next = list.Head
			list.Head.prev = node
			d.len += list.len  // 链表的数值相加
			return d
		}
		__index ++
	}
	return d
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的删除&#34;&gt;数据的删除&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 链表头删除法
func (d *DoubleList)DeleteToHead()*DoubleList{
	// 链表为空
	if d.Head == nil{
		return d
	}
	// 链表中只有一个数
	if d.Head == d.Tail{
		d.Head = nil
		d.Tail = nil
		d.len  = 0
		return d
	}
	d.Head = d.Head.next
	d.Head.prev = nil
	// node数减一
	d.len --
	return d
}

// 链表尾删除法
func (d *DoubleList)DeleteToTail()*DoubleList{
	// 链表为空
	if d.Tail == nil{
		return d
	}
	// 链表中只有一个数
	if d.Head == d.Tail{
		d.Head = nil
		d.Tail = nil
		d.len = 0
		return d
	}
	d.Tail = d.Tail.prev
	d.Tail.next = nil
	// node数减一
	d.len --
	return d
}

// 通过值=&amp;gt;删除链表的节点(第一个)
func (d *DoubleList)DeleteToAValue(value interface{})*DoubleList{
	// 链表为空
	if d.Head == nil{
		fmt.Println(&amp;quot;链表为空&amp;quot;)
		return d
	}
	// value == head.info
	// 就采用头删法
	if value == d.Head.info{
		return  d.DeleteToHead()
	}
	if value == d.Tail.info{
		return  d.DeleteToTail()
	}
	// 中间采用轮询查找value, 从第二个开始轮询到倒数第二个结束
	for node := d.Head.next; node != d.Tail; node = node.next{
		if node.info == value{
			//  删除node
			node.next.prev = node.prev
			node.prev.next = node.next
			d.len --
			return d
		}
	}
	fmt.Println(&amp;quot;链表中：值不存在&amp;quot;)
	return d
}

// 通过值=&amp;gt;删除链表的节点(所有)
func (d *DoubleList)DeleteToValue(value interface{})*DoubleList{
	// 链表为空
	if d.Head == nil{
		fmt.Println(&amp;quot;链表为空&amp;quot;)
		return d
	}
	node := d.Head         // 当前的node
	for {
		// 当下一个节点是尾节点时，就判断首位和末尾是为需要删除的node
		if node == d.Tail {
			if d.Head.info == value{
				d.DeleteToHead()
			}
			if d.Tail.info == value{
				d.DeleteToTail()
			}
			return d
		}
		if node.info == value{
			// 删除node， 非头节点
			if node.prev != nil{
				node.next.prev = node.prev
				node.prev.next = node.next
				d.len --
			}else{
				// 头节点
				d.DeleteToHead()
			}
		}
		node = node.next

	}
}

// 通过index=&amp;gt;删除链表的节点
// index为正数 为从左-&amp;gt;右 // 0表示第一个节点
// index为负数 为从右-&amp;gt;左 // -1表示第一个节点
func (d *DoubleList)DeleteToIndex(index int)*DoubleList{
	// 链表为空
	if d.Head == nil{
		fmt.Println(&amp;quot;链表为空&amp;quot;)
		return d
	}
	// index 超过链表数
	if int(math.Abs(float64(index))) &amp;gt; d.len-1{
		fmt.Println(&amp;quot;错误的index&amp;quot;)
		return d
	}
	// 删除第一个node
	if index == 0{
		return d.DeleteToHead()
	}
	if index &amp;lt; 0{
		index += d.len
	}
	if index == d.len -1{
		return d.DeleteToTail()
	}
	_index := 1
	node := d.Head.next
	for {
		if index == _index{
			node.next.prev = node.prev
			node.prev.next = node.next
			d.len --
			return d
		}
		node = node.next
		_index ++
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的查询&#34;&gt;数据的查询&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 遍历链表
func (d *DoubleList) QuireAll() {
	if d.Head == nil{
		fmt.Println(&amp;quot;链表数据为空&amp;quot;)
		return
	}
	node := d.Head
	for {
		if node == nil{
			return
		}
		fmt.Println(node.info)
		if node == d.Tail{
			return
		}
		node = node.next
	}
}

// 判断valve是否存在
func (d *DoubleList)QuireValue(value interface{}) bool{
	// 表为空
	if d.Head == nil{
		return false
	}
	// 表中只存在一个值
	if d.Head == d.Tail{
		if d.Head.info == value{
			return true
		}
		return false
	}
	// 遍历查值
	for node := d.Head; node != d.Tail.next; node = node.next{
		if node.info == value{
			return true
		}
	}
	return false
}

// 根据索引返回值
func (d *DoubleList)QuireIndex(index int) interface{} {
	// 链表为空
	if d.Head == nil{
		return nil
	}
	if int(math.Abs(float64(index))) &amp;gt; d.len -1 {
		fmt.Println(&amp;quot;索引值错误&amp;quot;)
		return nil
	}
	if index == 0{
		return d.Head.info
	}
	if index == d.len -1 || index == -1{
		return d.Tail.info
	}
	if index &amp;lt; 0{
		index += d.len
	}
	__index := 1
	for node := d.Head.next; node != d.Tail; node = node.next{
		if __index == index{
			return node.info
		}
		__index ++
	}
	//fmt.Println(&amp;quot;未能找到！！！！&amp;quot;)
	return nil
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;结构的入口&#34;&gt;结构的入口&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func NewDoubleLinkedList()*DoubleList{
	// 创建的链表头尾节点都为空
	return &amp;amp;DoubleList{
		Head: nil,
		Tail: nil,
		len: 0,
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;循环双向链表&#34;&gt;循环双向链表&lt;/h2&gt;
&lt;h3 id=&#34;数据结构的定义-1&#34;&gt;数据结构的定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 节点的定义
type circleDoubleNode struct {
	info  interface{}  // 数据结构的定义
	prev  *circleDoubleNode  // 前驱指针
	next  *circleDoubleNode  // 后驱指针
}

// 双向循环链表的定义
type circleDoubleList struct {
	currentNode *circleDoubleNode  // 指向链表的指针
	len  int    // 链表的长度
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建节点-1&#34;&gt;创建节点&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func createNode(data interface{}) *circleDoubleNode{
	return &amp;amp;circleDoubleNode{
		info: data,
		prev: nil,
		next: nil,
	}
}
// 得到链表的长度
func (c *circleDoubleList)GetLen()int{
	return c.len
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;节点的插入&#34;&gt;节点的插入&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (c *circleDoubleList)InsertNode(data interface{}) {
	newNode := createNode(data)
	// 如果链表为空
	if c.currentNode == nil{
		c.currentNode = newNode  // 新创建的节点为当前节点
		// 节点的前驱与后驱都指向自己
		c.currentNode.next = c.currentNode
		c.currentNode.prev = c.currentNode
	}else{
		// 节点的插入
		c.currentNode.next.prev = newNode
		newNode.prev = c.currentNode
		newNode.next = c.currentNode.next
		c.currentNode.next = newNode
		c.currentNode = newNode
	}
	// 链表长度 +1
	c.len ++
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;当前节点的删除&#34;&gt;当前节点的删除&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (c *circleDoubleList)DeleteNode() bool{
	// 链表为空
	if c.currentNode == nil{
		return false
	}
	// 当链表值存在一个元素时
	if c.len == 1{
		c.currentNode = nil
		c.len --
		return true
	}
	// 当链表只存在两个元素时
	if c.len == 2{
		c.currentNode = c.currentNode.next
		c.len --
		return true
	}
	// 当前节点的后驱节点的前驱指针指向当前节点的的前驱节点
	c.currentNode.next.prev = c.currentNode.prev
	// 当前节点的前驱节点的后驱指针指向当前节点的后驱节点
	c.currentNode.prev.next = c.currentNode.next
	// 设置当前节点的后驱节点为当前节点
	c.currentNode = c.currentNode.next
	c.len --
	return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;遍历说有节点&#34;&gt;遍历说有节点&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func (c *circleDoubleList)QuireAll(){
	if c.currentNode == nil{
		fmt.Println(&amp;quot;circle double linked list is empty&amp;quot;)
		return
	}
	//__index := 1
	//for node := c.currentNode.next; node != c.currentNode; node = node.next{
	//	fmt.Printf(&amp;quot;index is %d, node value is %v&amp;quot;, __index, node.info)
	//	__index ++
	//}
	fmt.Printf(&amp;quot;circle double linked list len is %d \n&amp;quot;, c.len)
	node := c.currentNode.next
	for i := 1; i &amp;lt; c.len; i++{
		fmt.Printf(&amp;quot;index is %d, node value is %v \n&amp;quot;, i, node.info)
		node = node.next
	}
	fmt.Printf(&amp;quot;index is %d, node value is %v \n&amp;quot;, c.len, c.currentNode.info)
}

// 判断值是否存在
func (c *circleDoubleList)QuireValue(data interface{}) bool{
	if c.currentNode == nil{
		return false
	}
	node := c.currentNode
	for i := 1; i &amp;lt;= c.len; i++{
		if node.info == data{
			return true
		}
		node = node.next
	}
	return  false
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;链表实例化&#34;&gt;链表实例化&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func NewCircleDoubleList()*circleDoubleList{
	return &amp;amp;circleDoubleList{
		currentNode: nil,
		len:         0,
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/Linked_list/double_linked_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/Linked_list/double_linked_list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/Linked_list/circle_double_linked_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/Linked_list/circle_double_linked_list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-双向链表&amp;&amp;循环双向链表 c&#43;&#43;实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-c-%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Thu, 30 Dec 2021 21:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-c-%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%E5%BE%AA%E7%8E%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-c-%E5%AE%9E%E7%8E%B0/1.jpg" alt="Featured image of post 数据结构-双向链表&amp;&amp;循环双向链表 c&#43;&#43;实现" /&gt;&lt;h2 id=&#34;双向链表&#34;&gt;双向链表&lt;/h2&gt;
&lt;h3 id=&#34;数据结构的定义&#34;&gt;数据结构的定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;template&amp;lt;class T&amp;gt;
class TwoWayLinkedNode
{
public:
    TwoWayLinkedNode(/* args */){}; 
    TwoWayLinkedNode(T data)
    {
        this-&amp;gt;data = data;
        this-&amp;gt;prev = 0;
        this-&amp;gt;next = 0;
    }
    ~TwoWayLinkedNode(){};
    T data;       // 数据
    TwoWayLinkedNode *next;  // 指向后继节点
    TwoWayLinkedNode *prev;   // 指向前驱
};

template&amp;lt;class T&amp;gt;
class TwoWayList
{
private:
    /* data */
    TwoWayLinkedNode&amp;lt;T&amp;gt; *head;   // 头节点
    TwoWayLinkedNode&amp;lt;T&amp;gt; *tail;   // 尾节点
    int  len;                    // 链表长度
public:
    TwoWayList()
    {
        head = 0;
        tail = 0;
        len = 0;
    };
    ~TwoWayList();
     // 链表的长度+1
    void setlen(int len)
    {
        this-&amp;gt;len += len;
    }; 
    // 返回链表的长度
    int getlen()
    {
        return len;
    };
    // 清空链表
    void clear();
    // 链表是否为空
    bool isEmpty()
    {
        return head == 0;
    }
    // 插入到链表的头部
    void inseartToHead(T data);  
    // 插入到链表的尾部
    void inseartTotail(T data); 
    // 插入到链表的index
    void inseartToindex(int index, T data); 
    // 删除链表的头部元素
    void deleteToHead();
    // 删除链表的尾部元素
    void deleteToTail();
    // 删除链表的index元素
    void deleteToIndex(int index);
    // 查询链表的所有值
    void queryAll();
    // 返回index的值
    bool queryIndex(int index, T *data);
    // 判断value是否存在
    bool queryValue(T data);
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的操作&#34;&gt;数据的操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::inseartToHead(T data)
{
   TwoWayLinkedNode&amp;lt;T&amp;gt; *new_Node = new TwoWayLinkedNode&amp;lt;T&amp;gt;(data); 
   // 链表为空
   if (isEmpty())
   {
      head = tail = new_Node;
   }
   else
   {
      new_Node-&amp;gt;next = head;   // 新节点的后驱指向头节点
      head-&amp;gt;prev = new_Node;   // 头节点的前驱指向新节点
      head = new_Node;         // 将新节点设置新的头节点
   }
   setlen(addOne);
}

template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::inseartTotail(T data)
{
   TwoWayLinkedNode&amp;lt;T&amp;gt; *new_Node = new TwoWayLinkedNode&amp;lt;T&amp;gt;(data);
   if(isEmpty())
   {
      head = tail = new_Node;
   }
   else
   {
      tail-&amp;gt;next = new_Node;  // 尾节点的next指向新节点
      new_Node-&amp;gt;prev = tail;  // 新节点的前驱指向尾节点
      tail = new_Node;        // 将新节点设置为新的尾节点
   }
   setlen(addOne);
}

template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::inseartToindex(int index, T data)
{
   int len = getlen();
   if(index == 0)
   {
      inseartToHead(data);
      return;
   }
   // 链表为空，当index 小于0 或者大于等于链表数，采用尾插法
   if (isEmpty() || index &amp;lt; 0 || index &amp;gt;= len)
   {
      inseartTotail(data);
      return;
   }
   TwoWayLinkedNode&amp;lt;T&amp;gt; *node = head;
   int __index = 1;
   while (__index != index)
   {
      node = node-&amp;gt;next;
      __index ++;
   }
   TwoWayLinkedNode&amp;lt;T&amp;gt; *new_node = new TwoWayLinkedNode&amp;lt;T&amp;gt;(data);
   node-&amp;gt;next-&amp;gt;prev = new_node;   // node节点的后继节点的先驱要指向新节点
   new_node-&amp;gt;prev = node;         // 新节点的先驱要指向node
   new_node-&amp;gt;next = node-&amp;gt;next;   // 新节点的后继要指向node的后继
   node-&amp;gt;next = new_node;         // node的后继要指向新节点
   setlen(addOne);
}

template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::clear()
{
   while (!isEmpty())
   {
      TwoWayLinkedNode&amp;lt;T&amp;gt; *node = head-&amp;gt;next;
      delete head;
      head = node;
   }
   
}

template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::deleteToHead()
{
   // 链表为空就返回
   if(isEmpty())
   {
      return;
   }
   // 链表只存在一个节点
   if(head == tail)
   {
      delete head;
      head = tail = 0;
   }
   else{
       head = head-&amp;gt;next;                // 将下一节点设置头节点
      delete head-&amp;gt;prev;                // 释放新的头节点的前驱节点
      head-&amp;gt;prev = 0;                   // 头节点的先驱设置nil
   }
   setlen(ReductOne);
}

template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::deleteToTail()
{
    // 链表为空就返回
   if(isEmpty())
   {
      return;
   }
   // 链表只存在一个节点
   if(head == tail)
   {
      delete head;
      head = tail = 0;
   }
   else{
      tail = tail-&amp;gt;prev;                // 尾节点的先驱节点重新设置为新的尾节点
      delete tail-&amp;gt;next;                // 释放新的尾节点的后驱
      tail-&amp;gt;next = 0;                   // 新的尾节点的后驱指向尾nil
   }
   setlen(ReductOne);
   
}

template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::deleteToIndex(int index)
{
   len = getlen();
   // 链表为空,就返回
   if(isEmpty())
   {
      return;
   }
   // index &amp;gt;= len || index &amp;lt; 0 采用删除末尾值
   if (index &amp;gt;= len || index &amp;lt; 0)
   {
      deleteToTail();
      return;
   }
   if(index == 0)
   {
      deleteToHead();
      return;
   }
   if (index == len - 1)
   {
      deleteToTail();
      return;
   }
   int __index = 1;
   TwoWayLinkedNode&amp;lt;T&amp;gt; *node = head-&amp;gt;next;
   while (__index != index)
   {
      node = node-&amp;gt;next;
      __index ++;
   }
   node-&amp;gt;prev-&amp;gt;next = node-&amp;gt;next;  // node节点的先驱节点的后驱指向node的后驱
   node-&amp;gt;next-&amp;gt;prev = node-&amp;gt;prev;  // node节点的后驱节点的先驱指向node的先驱
   delete node;  // 释放node
   setlen(ReductOne);
}

template&amp;lt;class T&amp;gt;
void TwoWayList&amp;lt;T&amp;gt; ::queryAll()
{
   if (isEmpty())
   {
        cout &amp;lt;&amp;lt; &amp;quot;The list length is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }

   cout &amp;lt;&amp;lt; &amp;quot;The length of the two way list is zero:&amp;quot; &amp;lt;&amp;lt; getlen() &amp;lt;&amp;lt; endl;
   int __index = 1;
   TwoWayLinkedNode&amp;lt;T&amp;gt; *node = head;
   while (node != tail-&amp;gt;next)
   {
      cout &amp;lt;&amp;lt; &amp;quot;node num is:&amp;quot; &amp;lt;&amp;lt; __index &amp;lt;&amp;lt; &amp;quot;  data:&amp;quot; &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; endl;
      node = node-&amp;gt;next;
      __index++; 
   }
   
}

template&amp;lt;class T&amp;gt;
bool TwoWayList&amp;lt;T&amp;gt; ::queryIndex(int index, T *data)
{
   len = getlen();
   // 链表为空,index &amp;gt;= len || index &amp;lt; 0  就返回
   if(isEmpty() || index &amp;gt;= len || index &amp;lt; 0)
   {
      return false;
   }
   int __index = 0;
   for(TwoWayLinkedNode&amp;lt;T&amp;gt; *node = head; node != tail-&amp;gt;next; node = node-&amp;gt;next)
   {
      if (__index == index)
      {
         *data = node-&amp;gt;data;
         return true;
      }
      __index++;

   }
   return false;

}

template&amp;lt;class T&amp;gt;
bool TwoWayList&amp;lt;T&amp;gt; ::queryValue(T data)
{
    if(isEmpty())
   {
      return false;
   }
   for(TwoWayLinkedNode&amp;lt;T&amp;gt; *node = head; node != tail-&amp;gt;next; node = node-&amp;gt;next)
   {
      if (node-&amp;gt;data == data)
      {
         return true;
      }
   }
   return false;
   
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int main()
{
   TwoWayList&amp;lt;int&amp;gt; newList;
   newList.inseartToHead(3);
   newList.inseartToHead(2);
   newList.inseartToHead(1);
   newList.inseartToHead(-11);
   newList.inseartTotail(4);
   newList.inseartTotail(5);
   newList.inseartTotail(6);
   newList.inseartTotail(7);
   newList.inseartTotail(8);
   newList.queryAll();
   cout &amp;lt;&amp;lt; &amp;quot;****************************************************&amp;quot;&amp;lt;&amp;lt; endl;
   newList.inseartToindex(2, 11);
   newList.inseartToindex(0, 2);
   newList.inseartToindex(1, 3);
   newList.queryAll();
   cout &amp;lt;&amp;lt; &amp;quot;****************************************************&amp;quot;&amp;lt;&amp;lt; endl;
   newList.deleteToHead();
   newList.deleteToHead();
   newList.deleteToHead();
   newList.queryAll();
   // newList.clear();
   cout &amp;lt;&amp;lt; &amp;quot;****************************************************&amp;quot;&amp;lt;&amp;lt; endl;
   newList.deleteToTail();
   newList.deleteToTail();
   newList.deleteToTail();
   newList.deleteToTail();
   newList.queryAll();
   cout &amp;lt;&amp;lt; &amp;quot;****************************************************&amp;quot;&amp;lt;&amp;lt; endl;
   newList.deleteToIndex(4);
   newList.queryAll();
   cout &amp;lt;&amp;lt; &amp;quot;****************************************************&amp;quot;&amp;lt;&amp;lt; endl;
   int index = 1;
   int info;
   if(newList.queryIndex(index, &amp;amp;info))
   {
      cout &amp;lt;&amp;lt; &amp;quot;exits index: &amp;quot; &amp;lt;&amp;lt; index &amp;lt;&amp;lt; &amp;quot; =&amp;gt; value is &amp;quot; &amp;lt;&amp;lt; info&amp;lt;&amp;lt;  endl;
   }
   else
   {
      cout &amp;lt;&amp;lt;&amp;quot; no exits index:&amp;quot; &amp;lt;&amp;lt; index &amp;lt;&amp;lt; endl;
   }
   cout &amp;lt;&amp;lt; &amp;quot;****************************************************&amp;quot;&amp;lt;&amp;lt; endl;
   newList.queryAll();
   cout &amp;lt;&amp;lt; newList.queryValue(1)&amp;lt;&amp;lt; endl;
   system(&amp;quot;pause&amp;quot;);
   return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;循环双向链表&#34;&gt;循环双向链表&lt;/h2&gt;
&lt;h3 id=&#34;数据结构的定义-1&#34;&gt;数据结构的定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 循环双向链表节点
template&amp;lt;class T&amp;gt;
class CircularDoubleLinkedNode
{
public:
    CircularDoubleLinkedNode()
    {
        prev = next = 0;
    }
    CircularDoubleLinkedNode(T data)
    {
        info = data;
        prev = next = 0;
    }
    ~CircularDoubleLinkedNode(){};
    T info;     // 数据
    CircularDoubleLinkedNode *prev;   // 先驱节点
    CircularDoubleLinkedNode *next;   // 后继节点
};

template&amp;lt;class T&amp;gt;
class CircularDoubleList
{
private:
    CircularDoubleLinkedNode&amp;lt;T&amp;gt; *current_node;  // 指向当前节点
    int len;    // 链表的长度
public:
    CircularDoubleList()
    {
        current_node = 0;
        len = 0;
    }
    ~CircularDoubleList();
    void addLen()
    {
        len++;
    }
    void reduceLen()
    {
        len--;
    }
    int getLen()
    {
        return len;
    }
    bool isEmpty()
    {
        return current_node == 0;
    }
    void inseartNode(T data);
    bool deleteNode();
    void queryAll();
    // 判断value是否存在
    bool queryValue(T data);
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的操作-1&#34;&gt;数据的操作&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
template&amp;lt;class T&amp;gt;
void CircularDoubleList&amp;lt;T&amp;gt; ::inseartNode(T data)
{
    CircularDoubleLinkedNode&amp;lt;T&amp;gt; *new_node = new CircularDoubleLinkedNode&amp;lt;T&amp;gt;(data);
    // 如果链表为空
    if(isEmpty())
    {
        // 当前节点为新的节点
        current_node = new_node;
        current_node-&amp;gt;next = current_node; // 后驱指向自己
        current_node-&amp;gt;prev = current_node; // 前驱也指向自己
    }
    else
    {
        /*与双向链表中的插入到链表中是一样的*/
       current_node-&amp;gt;next-&amp;gt;prev = new_node;
       new_node-&amp;gt;prev = current_node;
       new_node-&amp;gt;next = current_node-&amp;gt;next;
       current_node-&amp;gt;next = new_node;
       current_node = new_node;
    }
    addLen();
}

template&amp;lt;class T&amp;gt;
bool CircularDoubleList&amp;lt;T&amp;gt; ::deleteNode()
{
    // 链表为空
    if(isEmpty())
    {
        return false;
    }
    int len = getLen();
    // 链表中只有一个元素
    if(len == 1)
    {
        delete current_node;
        current_node = 0;
        reduceLen();
        return true;
    }
    // 链表中只有两个元素
    if (len == 2)
    {
        CircularDoubleLinkedNode&amp;lt;T&amp;gt; *node = current_node;
        current_node = current_node-&amp;gt;next;
        current_node-&amp;gt;next = current_node;
        current_node-&amp;gt;prev = current_node;
        delete node;
        reduceLen();
        return true;
    }
    // 链表元素达到3个及3个以上
    CircularDoubleLinkedNode&amp;lt;T&amp;gt; *node = current_node;
    current_node-&amp;gt;prev-&amp;gt;next = current_node-&amp;gt;next;
    current_node-&amp;gt;next-&amp;gt;prev = current_node-&amp;gt;prev;
    current_node = current_node-&amp;gt;next;
    delete node;
    reduceLen();
    return true;
}

template&amp;lt;class T&amp;gt;
void CircularDoubleList&amp;lt;T&amp;gt; ::queryAll()
{
    if(isEmpty())
    {
        cout &amp;lt;&amp;lt; &amp;quot;circular double list is empty&amp;quot; &amp;lt;&amp;lt;  endl;
        return;
    }

    cout &amp;lt;&amp;lt; &amp;quot;circular double list len is:&amp;quot; &amp;lt;&amp;lt; getLen() &amp;lt;&amp;lt; endl;
    int __index = 1;
    for (CircularDoubleLinkedNode&amp;lt;T&amp;gt; *node = current_node-&amp;gt;next; node != current_node; node = node-&amp;gt;next)
    {
        cout &amp;lt;&amp;lt; &amp;quot;index:&amp;quot; &amp;lt;&amp;lt; __index &amp;lt;&amp;lt; &amp;quot;  data is: &amp;quot; &amp;lt;&amp;lt; node-&amp;gt;info &amp;lt;&amp;lt; endl;
        __index++;
    }
    cout &amp;lt;&amp;lt; &amp;quot;index:&amp;quot; &amp;lt;&amp;lt; __index &amp;lt;&amp;lt; &amp;quot;  data is: &amp;quot; &amp;lt;&amp;lt; current_node-&amp;gt;info &amp;lt;&amp;lt; endl;
}

template&amp;lt;class T&amp;gt;
bool CircularDoubleList&amp;lt;T&amp;gt; ::queryValue(T data)
{
    // 判断链表为空
    if(isEmpty())
    {
        return false;
    }
    // 当前节点的值== data
    if(current_node-&amp;gt;info == data)
    {
        return true;
    }
    // 循环遍历当节点的value== data then retuen ture
    for(CircularDoubleLinkedNode&amp;lt;T&amp;gt; *node = current_node-&amp;gt;next; node != current_node; node = node-&amp;gt;next)
    {
        if(node-&amp;gt;info == data)
        {
            return true;
        }
    }
    return false;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试-1&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int main()
{
    CircularDoubleList&amp;lt;int&amp;gt; cirList;
    cirList.inseartNode(0);
    cirList.inseartNode(1);
    cirList.inseartNode(2);
    cirList.inseartNode(3);
    cirList.queryAll();
    cout &amp;lt;&amp;lt; &amp;quot;*****************************************************&amp;quot; &amp;lt;&amp;lt; endl;
    cirList.deleteNode();
    cirList.deleteNode();
    // cirList.deleteNode();
    // cirList.deleteNode();
    cirList.queryAll();
    cout &amp;lt;&amp;lt; &amp;quot;******************************************************&amp;quot; &amp;lt;&amp;lt;endl;
    int data = 11;
    if(cirList.queryValue(data))
    {
        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; &amp;quot;  is exists&amp;quot; &amp;lt;&amp;lt; endl;
    }
    else
    {
        cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; &amp;quot;  is not exists&amp;quot; &amp;lt;&amp;lt; endl;
    }
   system(&amp;quot;pause&amp;quot;);
   return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/linked_list/two_way_linked_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/linked_list/two_way_linked_list&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/linked_list/circular_double_linked_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/linked_list/circular_double_linked_list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-单向链表c&#43;&#43;语言实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8c-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Mon, 27 Dec 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8c-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8c-%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1.jpg" alt="Featured image of post 数据结构-单向链表c&#43;&#43;语言实现" /&gt;&lt;h2 id=&#34;单向链表&#34;&gt;单向链表&lt;/h2&gt;
&lt;h3 id=&#34;数据结构的定义&#34;&gt;数据结构的定义&lt;/h3&gt;
&lt;h4 id=&#34;数据节点的类的定义&#34;&gt;数据节点的类的定义&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class SinglyLinkedNode
{
public:
   SinglyLinkedNode(){
       next = 0;
   };
    // 创建新的node
   SinglyLinkedNode(int data)
   {
       this-&amp;gt;data = data;
       next = 0;
   };
   ~SinglyLinkedNode(){};
   int data;             // 链表的数据
   SinglyLinkedNode *next;  // 指向下一个节点
};
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;链表的数据结构类的定义&#34;&gt;链表的数据结构(类的定义)&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;class SinglyList
{
private:
    /* data */
    SinglyLinkedNode *head;   // 头节点
    SinglyLinkedNode *tail;   // 尾节点
    int len;                  // 链表长度

public:
    SinglyList(){
        head = 0;
        tail = 0;
        len = 0;
    };
    ~SinglyList();
    // 链表的长度+1
    void setlen(int len)
    {
        this-&amp;gt;len += len;
    }; 
    // 返回链表的长度
    int getlen()
    {
        return len;
    };
    // 链表是否为空
    bool ismpty()
    {
        return head == 0;
    }
    // 插入到链表的头部
    void inseartToHead(int data);  
    // 插入到链表的尾部
    void inseartTotail(int data); 
    // 插入到链表的index
    void inseartToindex(int index, int data); 
    // 删除链表的头部元素
    void deleteToHead();
    // 删除链表的尾部元素
    void deleteToTail();
    // 删除链表的index元素
    void deleteToIndex(int index);
    // 查询链表的所有值
    void queryAll();
    // 返回index的值
    int queryIndex(int index);
    // 判断value是否存在
    bool queryValue(int data);
};
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的插入&#34;&gt;数据的插入&lt;/h3&gt;
&lt;h4 id=&#34;插入到链表的尾部&#34;&gt;插入到链表的尾部&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SinglyList::inseartTotail(int data)
{
    // 定义node
    SinglyLinkedNode *new_node;
    new_node = new SinglyLinkedNode(data);
    // 链表为空
    if (ismpty())
    {
        head = tail = new_node; // 头尾节点都指向新创节点
        setlen(addOne);              // 节点数+1
        return;
    }
    tail-&amp;gt;next = new_node;
    tail = tail-&amp;gt;next;
    setlen(addOne);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;插入到链表的头部&#34;&gt;插入到链表的头部&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SinglyList::inseartToHead(int data)
{
    SinglyLinkedNode *node;
    node = new SinglyLinkedNode(data);
    if (ismpty()){
        head = tail = node;
        setlen(addOne);
        return ;
    }
    node-&amp;gt;next = head;
    head = node;
    setlen(addOne);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;插入到链表的index&#34;&gt;插入到链表的index&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SinglyList::inseartToindex(int index, int data)
{
    int len;
    len = getlen()-1;
     // 如果链表为空, 或者插入到末尾,或者index &amp;lt;0 采用尾插法添加到链表中
    if (ismpty() || index ==len || index &amp;lt; 0)
    {
        inseartTotail(data);
        return;
    }
    if(index == 0){
        inseartToHead(data);
        return;
    }
    SinglyLinkedNode *node;
    node = new SinglyLinkedNode(data);
    int __index = 1;
    for (node = head; node != tail; node = node-&amp;gt;next)
    {
        if (__index == index)
        {
            SinglyLinkedNode *new_node;
            new_node = new SinglyLinkedNode(data);
            new_node -&amp;gt;next = node-&amp;gt;next;
            node-&amp;gt;next = new_node;
            setlen(addOne);
            return;
        }
        __index ++;
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的删除&#34;&gt;数据的删除&lt;/h3&gt;
&lt;h4 id=&#34;删除链表的头部元素&#34;&gt;删除链表的头部元素&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SinglyList::deleteToHead()
{
    // 链表为空
    if(ismpty())
    {
        return;
    }
    SinglyLinkedNode *tmp = head;
    // 链表只存在一个值
    if(head == tail)
    {
        head = tail = 0;
    }
    else
    {
        head = head-&amp;gt;next;
    }
    delete tmp; // 释放资源
    setlen(ReductOne);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;删除链表的尾部元素&#34;&gt;删除链表的尾部元素&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SinglyList::deleteToTail()
{
    // 链表为空
    if(ismpty())
    {
        return;
    }
    // 链表只存在一个值
    if(head == tail)
    {
        delete head;
        setlen(ReductOne);
        head = tail = 0;
        return;
    }
    SinglyLinkedNode *tmp = head;
    while (tmp-&amp;gt;next != tail)
    {
        tmp  = tmp-&amp;gt;next;
    }
    delete tail;
    tail = tmp;
    tail-&amp;gt;next = 0;
    setlen(ReductOne);
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;删除链表的index元素&#34;&gt;删除链表的index元素&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SinglyList::deleteToIndex(int index)
{
    // 链表为空
    if(ismpty())
    {
        return;
    }
    // 链表只存在一个值
    if(head == tail)
    {
        delete head;
        setlen(ReductOne);
        head = tail = 0;
        return;
    }
    int len = getlen();
    if (index &amp;gt;= len-1 || index &amp;lt; 0)
    {
        deleteToTail();
        return;
    }
    if (index == 0)
    {
        deleteToHead();
        return;
    }

    SinglyLinkedNode *node = head;
    SinglyLinkedNode *tmp = head-&amp;gt;next;
    int __index = 1;
    while (__index != index)
    {
        node = node-&amp;gt;next;
        tmp = tmp-&amp;gt;next;
        __index ++;
    }
    node-&amp;gt;next = tmp-&amp;gt;next;
    delete tmp;
    setlen(ReductOne);
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的查询&#34;&gt;数据的查询&lt;/h3&gt;
&lt;h4 id=&#34;查询链表的所有值&#34;&gt;查询链表的所有值&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;void SinglyList::queryAll()
{
    if (ismpty()){
        cout &amp;lt;&amp;lt; &amp;quot;The list length is empty&amp;quot; &amp;lt;&amp;lt; endl;
        return;
    }
    int i = 1;
    cout &amp;lt;&amp;lt; &amp;quot;The length of the list is zero:&amp;quot; &amp;lt;&amp;lt; getlen() &amp;lt;&amp;lt; endl;
    SinglyLinkedNode *node;
    for(node = head; node != tail-&amp;gt;next; node = node-&amp;gt;next){
        cout &amp;lt;&amp;lt; &amp;quot;node num is:&amp;quot; &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &amp;quot;  data:&amp;quot; &amp;lt;&amp;lt; node-&amp;gt;data &amp;lt;&amp;lt; endl;
        i++;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;返回index的值&#34;&gt;返回index的值&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int SinglyList::queryIndex(int index)
{
    int len = getlen();
    // 链表为空, 索引不存在
    if(ismpty() || index &amp;gt; len -1 || index &amp;lt; 0)
    {
        return -1;
    }
   if (index == 0)
   {
       return head -&amp;gt;data;
   }
   if (index == len -1)
   {
       return tail -&amp;gt;data;
   }
   int __index = 1;
   for (SinglyLinkedNode *node = head-&amp;gt;next; node != tail; node = node-&amp;gt;next)
   {
       if (index == __index)
       {
           return node-&amp;gt;data;

       }
        __index ++; 
   }
   return -1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;判断value是否存在&#34;&gt;判断value是否存在&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;bool SinglyList::queryValue(int value)
{
    // 链表为空
    if(ismpty())
    {
        return false;
    }
    // 链表只存在一个值
    if(head == tail)
    {
        if (head-&amp;gt;data == value){
            return true;
        }
        return false;
    }

    for(SinglyLinkedNode *node = head; node != tail-&amp;gt;next; node = node-&amp;gt;next)
    {
        if(node-&amp;gt;data == value)
        {
            return true;
        }
    }
    return false;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;测试&#34;&gt;测试&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;int main()
{
    SinglyList newList;
    newList.inseartTotail(1);
    newList.inseartTotail(2);
    newList.inseartTotail(3);
    newList.inseartToHead(0);
    newList.inseartToHead(-11);
    newList.inseartToHead(-12);
    newList.inseartToHead(-13);
    newList.inseartToindex(6,5);
    newList.inseartToindex(-7,51);
    newList.queryAll();
    cout &amp;lt;&amp;lt; &amp;quot;************************************************&amp;quot;&amp;lt;&amp;lt; endl;
    newList.deleteToHead();
    newList.queryAll();
    cout &amp;lt;&amp;lt; &amp;quot;************************************************&amp;quot;&amp;lt;&amp;lt; endl;
    newList.deleteToTail();
    newList.queryAll();
    cout &amp;lt;&amp;lt; &amp;quot;************************************************&amp;quot;&amp;lt;&amp;lt; endl;
    newList.deleteToTail();
    newList.queryAll();
    cout &amp;lt;&amp;lt; &amp;quot;************************************************&amp;quot;&amp;lt;&amp;lt; endl;
    newList.deleteToIndex(3);
    newList.queryAll();
    cout &amp;lt;&amp;lt; &amp;quot;************************************************&amp;quot;&amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; newList.queryIndex(5) &amp;lt;&amp;lt; endl;
     cout &amp;lt;&amp;lt; &amp;quot;************************************************&amp;quot;&amp;lt;&amp;lt; endl;
    cout &amp;lt;&amp;lt; newList.queryValue(21) &amp;lt;&amp;lt; endl;
    system(&amp;quot;pause&amp;quot;);
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/linked_list/singly_linked_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForC/tree/master/linked_list/singly_linked_list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>数据结构-单向链表go语言实现</title>
        <link>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</link>
        <pubDate>Sat, 25 Dec 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/1.jpg" alt="Featured image of post 数据结构-单向链表go语言实现" /&gt;&lt;h2 id=&#34;单向链表&#34;&gt;单向链表&lt;/h2&gt;
&lt;h3 id=&#34;数据结构的定义&#34;&gt;数据结构的定义&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;单项链表节点的定义
type singlyLinkedNode struct {
	info    interface{}    		// 存储任意数据
	next    *singlyLinkedNode  	// 指向下一节点
}

type linkedList struct {
	len  int                   // 链表长度
	Head *singlyLinkedNode     // 头节点
	Tail *singlyLinkedNode     // 尾节点
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;创建节点&#34;&gt;创建节点&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func createNode(info interface{}) *singlyLinkedNode {
	node := &amp;amp;singlyLinkedNode{
		info: info,
		next: nil,
	}
	return node
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;链表的长度&#34;&gt;链表的长度&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func(l *linkedList)Len() int{
	return l.len
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的插入&#34;&gt;数据的插入&lt;/h3&gt;
&lt;h4 id=&#34;单个节点的插入&#34;&gt;单个节点的插入&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 链表的尾插法
func (l *linkedList)AddToTail(info interface{}) *linkedList {
	newNode := createNode(info)  // 创建新节点
	// 链表为空, 头尾节点都指向该节点
	if l.Tail == nil{
		l.Head = newNode
		l.Tail = newNode
	}
	l.Tail.next = newNode
	l.Tail = l.Tail.next
	// 链表长度+1
	l.len++
	return l
}

// 链表的头插法
func (l *linkedList)AddToHead(info interface{}) *linkedList  {
	newNode := createNode(info)  // 创建节点
	// 链表为空
	if l.Head == nil{
		l.Head = newNode
		l.Tail = newNode
	}
	newNode.next = l.Head
	l.Head = newNode
	// 链表长度+1
	l.len++
	return  l
}

// 链表的index
// 通过index=&amp;gt;插入链表新的节点
// index为正数 为从左-&amp;gt;右 // 0表示第一个节点
// index为负数 为从右-&amp;gt;左 // -1表示第一个节点
func (l *linkedList)AddToIndex(index int, info interface{}) *linkedList {
	// 当链表为空时，采用了尾插入法插入数据
	if l.Head == nil{
		return l.AddToTail(info)
	}
	// 当index大于链表的值时，默认将数据插入到链表的后面
	if int(math.Abs(float64(index))) &amp;gt; l.len-1{
		return l.AddToTail(info)
	}
	// 插入链表的头部
	if index == 0{
		return l.AddToHead(info)
	}
	// 插入到链表的末尾
	if index == -1{
		return l.AddToTail(info)
	}
	// 当index 为负数时，从右到左插入
	if index &amp;lt; 0{
		index += l.len
	}
	__index := 1  // 内部的index值
	// 从第二个值开始插入
	for node := l.Head.next; node != l.Tail; node = node.next{
		if index == __index{
			newNode := createNode(info)
			newNode.next = node.next    // 指向node的后继节点
			node.next = newNode         // node 指向这个新的节点
			// 链表的节点数加1
			l.len ++
			return l
		}
		__index ++
	}
	return l
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;链表的合并&#34;&gt;链表的合并&lt;/h4&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 将新的链表插入头部
func (l *linkedList)AddListToHead(list *linkedList)*linkedList{
	// 两个链表都为空时
	if l.Head == nil &amp;amp;&amp;amp; list.Head == nil{
		return l
	}
	// 合并表为空
	if l.Head != nil &amp;amp;&amp;amp; list.Head == nil{
		return l
	}
	// 主表为空
	if l.Head == nil &amp;amp;&amp;amp; list.Head != nil{
		return list
	}
	// 合并表的尾指针指向主表的头
	list.Tail.next = l.Head
	list.Tail = l.Tail
	// 表节点数合并
	list.len += l.len
	return list
}

// 将新的链表插入到尾部
func (l *linkedList)AddListToTail(list *linkedList)*linkedList{
	// 两个链表都为空时
	if l.Head == nil &amp;amp;&amp;amp; list.Head == nil{
		return l
	}
	// 合并表为空
	if l.Head != nil &amp;amp;&amp;amp; list.Head == nil{
		return l
	}
	// 主表为空
	if l.Head == nil &amp;amp;&amp;amp; list.Head != nil{
		return list
	}
	// 将新表插入到主表之后
	l.Tail.next = list.Head
	l.Tail = list.Tail
	l.len += list.len
	return l
}

// 经新的表插入到index
func (l *linkedList)AddListToIndex(index int, list *linkedList) *linkedList {
	// 两个链表都为空时
	if l.Head == nil &amp;amp;&amp;amp; list.Head == nil{
		return l
	}
	// 合并表为空
	if l.Head != nil &amp;amp;&amp;amp; list.Head == nil{
		return l
	}
	// 主表为空
	if l.Head == nil &amp;amp;&amp;amp; list.Head != nil{
		return list
	}
	if int(math.Abs(float64(index))) &amp;gt; l.len{
		fmt.Println(&amp;quot;错误的index&amp;quot;)
		return l
	}
	if index == 0{
		return l.AddListToHead(list)
	}
	if int(math.Abs(float64(index))) == l.len -1 || index == -1{
		return l.AddListToTail(list)
	}
	if index &amp;lt; 0{
		index += l.len
	}
	__index := 1
	for node := l.Head.next; node != l.Tail; node = node.next{
		if index == __index{
			list.Tail.next = node.next
			node.next = list.Head
			l.len += list.len  // 链表的数值相加
			return l
		}
		__index ++
	}
	return l
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的删除&#34;&gt;数据的删除&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 链表头删除法
func (l *linkedList)DeleteToHead()*linkedList{
	// 链表为空
	if l.Head == nil{
		return l
	}
	// 链表中只有一个数
	if l.Head == l.Tail{
		l.Head = nil
		l.Tail = nil
		l.len  = 0
		return l
	}
	l.Head = l.Head.next
	// node数减一
	l.len --
	return l
}

// 链表尾删除法
func (l *linkedList)DeleteToTail()*linkedList{
	// 链表为空
	if l.Tail == nil{
		return l
	}
	// 链表中只有一个数
	if l.Head == l.Tail{
		l.Head = nil
		l.Tail = nil
		l.len = 0
		return l
	}
	// 找出尾节点的上一节点
	var node  *singlyLinkedNode
	for node = l.Head;  node.next != l.Tail; node = node.next{}
	node.next = nil
	l.Tail = node
	// node数减一
	l.len --
	return l
}

// 通过值=&amp;gt;删除链表的节点(第一个)
func (l *linkedList)DeleteToAValue(value interface{})*linkedList{
	// 链表为空
	if l.Head == nil{
		fmt.Println(&amp;quot;链表为空&amp;quot;)
		return l
	}
	// value == head.info
	// 就采用头删法
	if value == l.Head.info{
		return  l.DeleteToHead()
	}
	// 中间采用轮询查找value, 从第二个开始轮询到倒数第二个结束
	node := l.Head
	for temp := l.Head.next; temp != nil; temp = node.next{
		if temp.info == value{
			//  删除node
			node.next = temp.next
			l.len --
			return l
		}
		node = node.next
	}
	fmt.Println(&amp;quot;链表中：值不存在&amp;quot;)
	return l
}

// 通过值=&amp;gt;删除链表的节点(所有)
func (l *linkedList)DeleteToValue(value interface{})*linkedList{
	// 链表为空
	if l.Head == nil{
		fmt.Println(&amp;quot;链表为空&amp;quot;)
		return l
	}
	node := l.Head         // 当前的node
	temp := l.Head.next    // 下一个node
	for {
		// 当下一个节点是尾节点时，就判断首位和末尾是为需要删除的node
		if temp == l.Tail {
			if l.Head.info == value{
				l.DeleteToHead()
			}
			if l.Tail.info == value{
				l.DeleteToTail()
			}
			return l
		}
		if temp.info == value{
			// 删除node
			node.next = temp.next
			temp = temp.next
			// node数减一
			l.len --
			continue
		}
		node = node.next
		temp = temp.next
		}
}

// 通过index=&amp;gt;删除链表的节点
// index为正数 为从左-&amp;gt;右 // 0表示第一个节点
// index为负数 为从右-&amp;gt;左 // -1表示第一个节点
func (l *linkedList)DeleteToIndex(index int)*linkedList{
	// 链表为空
	if l.Head == nil{
		fmt.Println(&amp;quot;链表为空&amp;quot;)
		return l
	}
	// index 超过链表数
	if int(math.Abs(float64(index))) &amp;gt; l.len-1{
		fmt.Println(&amp;quot;错误的index&amp;quot;)
		return l
	}
	// 删除第一个node
	if index == 0{
		return l.DeleteToHead()
	}
	if index &amp;lt; 0{
		index += l.len
	}
	_index := 1
	node := l.Head
	temp := node.next
	for {
		if index == _index{
			if temp != nil{
				node.next = temp.next
			}
			l.len --
			return l
		}
		node = node.next
		temp = temp.next
		_index ++
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;数据的查询&#34;&gt;数据的查询&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 遍历链表
func (l *linkedList) QuireAll() {
	if l.Head == nil{
		fmt.Println(&amp;quot;链表数据为空&amp;quot;)
		return
	}
	node := l.Head
	for {
		if node == nil{
			return
		}
		fmt.Println(node.info)
		if node == l.Tail{
			return
		}
		node = node.next
	}
}

// 判断valve是否存在
func (l *linkedList)QuireValue(value interface{}) bool{
	// 表为空
	if l.Head == nil{
		return false
	}
	// 表中只存在一个值
	if l.Head == l.Tail{
		if l.Head.info == value{
			return true
		}
		return false
	}
	// 遍历查值
	for node := l.Head; node != l.Tail.next; node = node.next{
		if node.info == value{
			return true
		}
	}
	return false
}

// 根据索引返回值
func (l *linkedList)QuireIndex(index int) interface{} {
	// 链表为空
	if l.Head == nil{
		return nil
	}
	if int(math.Abs(float64(index))) &amp;gt; l.len -1 {
		fmt.Println(&amp;quot;索引值错误&amp;quot;)
		return nil
	}
	if index == 0{
		return l.Head.info
	}
	if index == l.len -1 || index == -1{
		return l.Tail.info
	}
	if index &amp;lt; 0{
		index += l.len
	}
	__index := 1
	for node := l.Head.next; node != l.Tail; node = node.next{
		if __index == index{
			return node.info
		}
		__index ++
	}
	//fmt.Println(&amp;quot;未能找到！！！！&amp;quot;)
	return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;结构的入口&#34;&gt;结构的入口&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func NewLinkerList()*linkedList{
	// 创建的链表头尾节点都为空
	return &amp;amp;linkedList{
		Head: nil,
		Tail: nil,
		len: 0,
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/Linked_list/Singly_linked_list&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/DataStructuresAlgorithmsForGo/tree/master/Linked_list/Singly_linked_list&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>超时重试机制-host_try</title>
        <link>https://zcj-git520.github.io/p/%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-host_try/</link>
        <pubDate>Mon, 20 Dec 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-host_try/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E8%B6%85%E6%97%B6%E9%87%8D%E8%AF%95%E6%9C%BA%E5%88%B6-host_try/1.png" alt="Featured image of post 超时重试机制-host_try" /&gt;&lt;h2 id=&#34;host_try&#34;&gt;host_try&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;host_try：主要是目的是在单个或者多个host的下，连接超时或者连接失败下的重试机制&lt;/li&gt;
&lt;li&gt;host_try: 提供三种退避策略：1. 尝试等待时间指数增长 2. 以相同时间进行尝试 3.随机时间进行尝试 三种尝试策略可一起使用&lt;/li&gt;
&lt;li&gt;host_try: 提供三种重试方式：1. 轮询host进行重连, 重连次数达到后,在将换下一host, 直到重新连接成功或所有的host都重连完成结束
2.每一个host进行重连, 在将换下一host, 所有的host失败了,在进行下一次重连。直到重新连接成功或重连次数达到后结束 3. 重试直到成功&lt;/li&gt;
&lt;li&gt;host_try 只是提供重试连接的接口，具体请求的方法需要自己写&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;host_try的工作原理&#34;&gt;host_try的工作原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存在多个host的请求提供相同的服务如(ntp)，存在连接超时的情况，需要不断的尝试连接，&lt;/li&gt;
&lt;li&gt;只要一个host连接请求成功就返回&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;host_try的配置结构&#34;&gt;host_try的配置结构&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type tryConfig struct {
	attemptNum    uint           	 // 尝试的重连的次数
	nowAttempt    uint               // 现在第几次重连
	hosts         []string        	 // 连接的host组
	successHost   string             // 连接成功的host
	errorHost     map[string]string  // 连接失败的host和错误原因
	attemptType   string          	 // 重连方式
	attemptStatus bool               // 最终重连的状态
	delay         time.Duration    	 // 延时时间
	maxDelay      time.Duration    	 // 最大延时时间
	maxJitter     time.Duration      // 最大随机数时间
	delayType     []uint   	         // 退避策略类型
	contest       context.Context
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;提供三种退避策略&#34;&gt;提供三种退避策略&lt;/h2&gt;
&lt;h3 id=&#34;第一种策略&#34;&gt;第一种策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;延时时间* 因子**重连次数(因子默认为2)
&lt;code&gt;func (t *tryConfig)backOffDelay(n uint) time.Duration&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第二种策略&#34;&gt;第二种策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;以相同的时间进行延时
&lt;code&gt; func (t *tryConfig)fixedDelay() time.Duration&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;第三种策略&#34;&gt;第三种策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;随机延迟时间 
&lt;code&gt; func (t *tryConfig)randomDelay() time.Duration&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重试方式&#34;&gt;重试方式&lt;/h2&gt;
&lt;h3 id=&#34;方式1&#34;&gt;方式1&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;轮询host进行重连, 重连次数达到后,在将换下一host, 直到重新连接成功或所有的host都重连完成结束
&lt;code&gt;func (t *tryConfig) directConnection (retryableFunc RetryableFunc)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方式2&#34;&gt;方式2&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;每一个host进行重连, 在将换下一host, 所有的host失败了,在进行下一次重连。直到重新连接成功或重连次数达到后结束
&lt;code&gt; func (t *tryConfig) staggeredConnection (retryableFunc RetryableFunc)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;方式3&#34;&gt;方式3&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;重试直到成功
&lt;code&gt;func (t *tryConfig) untilConnection (retryableFunc RetryableFunc)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;host := []string{&amp;quot;172.16.21.1&amp;quot;,&amp;quot;ntp.ntsc1.ac.cn&amp;quot;,&amp;quot;cn.ntp1.org.cn&amp;quot;,&amp;quot;cn.pool.ntp1.org&amp;quot;,&amp;quot;time.pool.aliyun1.com&amp;quot;, &amp;quot;172.16.2.1&amp;quot;}
		demo := New(host, AttemptType(&amp;quot;directConnection&amp;quot;))
		demo.DoTry(SetNtpTime)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;重连的入口，当轮询时间为0时，使用方式3，默认为：方式2&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 尝试的重连的次数默认为：5次
// 重连方式默认为：方式2
// 延时时间默认为：10*time.Minute
// 最大延时时间默认为：100*time.Minute
// 最大随机数时间默认为：100*time.Minute
// 退避策略类型默认为：策略1
func New(hots []string, opts ...Option) *tryConfig
func (t *tryConfig) DoTry(retryableFunc RetryableFunc)
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/host_try&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/host_try&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>timerTask 定时任务包</title>
        <link>https://zcj-git520.github.io/p/timertask-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8C%85/</link>
        <pubDate>Wed, 15 Dec 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/timertask-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8C%85/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/timertask-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E5%8C%85/1.png" alt="Featured image of post timerTask 定时任务包" /&gt;&lt;h2 id=&#34;timertask&#34;&gt;timerTask&lt;/h2&gt;
&lt;p&gt;定时任务：可以定时执行单个或者对个任务：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;定时定时任务&lt;/li&gt;
&lt;li&gt;停止定时任务&lt;/li&gt;
&lt;li&gt;重置定时时间，并执行定时任务&lt;/li&gt;
&lt;li&gt;定时开启定时任务&lt;/li&gt;
&lt;li&gt;定时结束定时任务&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;timertask结构&#34;&gt;timerTask结构&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type timerConfig struct {
	timing       time.Duration      // 定时时间
	startTiming  time.Duration      // 定时开启定时任务时间
	stopTiming   time.Duration      // 定时停止定时任务时间
	running   	 bool               // 定时器运行的状态,运作中为true/没有运行为false
	tasks        []func()           // 定时任务
	stopChan     chan struct{}      // 停止定时器日任务
	runningMu    sync.Mutex
	Waiter       sync.WaitGroup
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;定时任务的开始和结束&#34;&gt;定时任务的开始和结束&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数原型：NewTimerTask(d time.Duration, tasks []func(), opts ... Option) *timerConfig
参数为：统一的定时任务时间,定时任务集, 可选参数【定时开启定时任务时间(SetTimerStart(d time.Duration)), 定时停止定时任务时间(SetTimerStop(d time.Duration))】
Start()开始定时任务, Stop()结束定时任务 

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t1 := 1 * time.Second
	tasks := []func(){printTest1, printTest2, printTest3, printTest4, printTest5}
	timer := NewTimerTask(t1, tasks)
	timer.Waiter.Add(2)
	timer.start()
	go func() {
		select {
		case &amp;lt;-time.After(5*time.Second):
			timer.stop()
			timer.Waiter.Done()
			return
		}

	}()
	timer.Waiter.Wait()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;重置定时时间任务&#34;&gt;重置定时时间任务&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数原型：Reset(d time.Duration) // 重置定时的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	t1 := 1 * time.Second
	tasks := []func(){printTest1, printTest2, printTest3, printTest4, printTest5}
	timer := NewTimerTask(t1, tasks)
	timer.Waiter.Add(3)
	timer.start()
	go func() {
		select {
		case &amp;lt;-time.After(10*time.Second):
			timer.stop()
			timer.Waiter.Done()
			return
		}

	}()
	go func() {
		select {
		case &amp;lt;-time.After(5*time.Second):
			timer.Reset(2*time.Second)
			timer.Waiter.Done()
			return
		}

	}()
	timer.Waiter.Wait()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;定时开始定时任务&#34;&gt;定时开始定时任务&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数原型：TimerStart() ,需要在初始化时,设定定时开始定时任务的时间
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;	t1 := 1 * time.Second
	ts := time.Now()
	tasks := []func(){printTest1, printTest2, printTest3, printTest4, printTest5}
	timer := NewTimerTask(t1, tasks, SetTimerStart(3*time.Second))
	timer.TimerStart()
	t.Logf(&amp;quot;定时时间为：%v&amp;quot;, time.Now().Sub(ts))
	timer.Waiter.Add(2)
	timer.start()
	go func() {
		select {
		case &amp;lt;-time.After(5*time.Second):
			timer.stop()
			timer.Waiter.Done()
			return
		}

	}()
	timer.Waiter.Wait()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;定时结束定时任务&#34;&gt;定时结束定时任务&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;函数原型：TimerStop(),设定定时结束定时任务的时间
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;t1 := 1 * time.Second
	tasks := []func(){printTest1, printTest2, printTest3, printTest4, printTest5}
	timer := NewTimerTask(t1, tasks, SetTimerStop(3*time.Second))
	timer.Waiter.Add(1)
	timer.start()
	time.Sleep(1*time.Second)
	ts := time.Now()
	timer.TimerStop()
	t.Logf(&amp;quot;定时时间为：%v&amp;quot;, time.Now().Sub(ts))
	timer.Waiter.Wait()
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;源码&#34;&gt;源码&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/zcj-git520/timerTask&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;我的github:https://github.com/zcj-git520/timerTask&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>io多路复用</title>
        <link>https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</link>
        <pubDate>Sun, 12 Dec 2021 12:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/3.png" alt="Featured image of post io多路复用" /&gt;&lt;h2 id=&#34;常见的io类型&#34;&gt;常见的IO类型&lt;/h2&gt;
&lt;h3 id=&#34;同步阻塞io&#34;&gt;同步阻塞IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户线程通过调用系统命令发起io操作，由用户态复制到内核态空间，内核态一直在等待，
直到获取到数据时，将接收到的数据拷贝到用户态空间，用户线程在获取数据。整个过程用户线程
处于阻塞的状态，直到有数据为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;同步非阻塞io&#34;&gt;同步非阻塞IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在同步阻塞io的基础上，用户线程发起io操作后，就立刻返回。由于是非阻塞的方式，就存在返回时
没有数据，就需要不断的轮询发起io请求，直到接收到数据为止。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;io多路复用&#34;&gt;IO多路复用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;io多路复用是一种同步的io模型。实现在内核态中一个线程监视多个io(文件句柄)，一旦某个io就绪后，
就通知用户线程进行相关的操作。没有io就绪时就阻塞用户线程，将交出cpu。多路是指网络连接，复用是指
用一个线程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;信号驱动io&#34;&gt;信号驱动IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户线程发起一个io操作后，会向内核注册一个信号处理函数，然后返回，当内核中有数据时，就会发送一个
信号给用户线程，用户态的线程在调用io请求，获取到数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异步io&#34;&gt;异步IO&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;用户线程发起io操作后就返回。由内核态的线程处理，当内核线程获取到数据后，主动将数据拷贝到用户态，
并告知用户线程io操作也完成。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 196; 
			flex-basis: 470px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1.png&#34; data-size=&#34;1212x618&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1.png&#34;
			width=&#34;1212&#34;
			height=&#34;618&#34;
			srcset=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1_hu6a7bbc8d92c625220336f60c7a90aa78_163397_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/1_hu6a7bbc8d92c625220336f60c7a90aa78_163397_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;io多路复用的三种实现方式&#34;&gt;io多路复用的三种实现方式&lt;/h2&gt;
&lt;h3 id=&#34;select&#34;&gt;select&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;select是采用数组的存储的结构存储io(fd文件句柄)，默认的最大的fd为32位系统1024，64位系统是2048(可设置),用户线程将fd集合拷贝到
内核态并开始监控，当有fd就绪或者过了设置超时时间，就将fd集合中所有未就绪的fd清空(将bitmap置为0)，将就id集合返回到用户态，
用户态的线程通过轮询返回的fd集合找到就绪的fd,进行相关的io操作获取数据。再一次监控时，需要将之前清空的fd
添加到fd集合中进行新一轮的监控。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;sys/select.h&amp;gt;
#include &amp;lt;sys/time.h&amp;gt;

#define FD_SETSIZE 1024
#define NFDBITS (8 * sizeof(unsigned long))
#define __FDSET_LONGS (FD_SETSIZE/NFDBITS)

// 数据结构 (bitmap)
typedef struct {
    unsigned long fds_bits[__FDSET_LONGS];
} fd_set;

// API
int select(
    int max_fd,               // 最大的文件文件描述符fd 
    fd_set *readset,          // 读文件描述符集合
    fd_set *writeset,         // 写文件描述符集合
    fd_set *exceptset,        // 异常的文件描述符集合
    struct timeval *timeout   // 超时时间
)                              // 返回值就绪描述符的数目
FD_ZERO(int fd, fd_set* fds)   // 清空集合
FD_SET(int fd, fd_set* fds)    // 将给定的描述符加入集合
FD_ISSET(int fd, fd_set* fds)  // 判断指定描述符是否在集合中 
FD_CLR(int fd, fd_set* fds)    // 将给定的描述符从文件中删除 
//select使用示例
int main() {
  /*
   * 这里进行一些初始化的设置，
   * 包括socket建立，地址的设置等,
   */

  fd_set read_fs, write_fs;
  struct timeval timeout;
  int max = 0;  // 用于记录最大的fd，在轮询中时刻更新即可

  // 初始化比特位
  FD_ZERO(&amp;amp;read_fs);
  FD_ZERO(&amp;amp;write_fs);

  int nfds = 0; // 记录就绪的事件，可以减少遍历的次数
  while (1) {
    // 阻塞获取
    // 每次需要把fd从用户态拷贝到内核态
    nfds = select(max + 1, &amp;amp;read_fd, &amp;amp;write_fd, NULL, &amp;amp;timeout);
    // 每次需要遍历所有fd，判断有无读写事件发生
    for (int i = 0; i &amp;lt;= max &amp;amp;&amp;amp; nfds; ++i) {
      if (i == listenfd) {
         --nfds;
         // 这里处理accept事件
         FD_SET(i, &amp;amp;read_fd);//将客户端socket加入到集合中
      }
      if (FD_ISSET(i, &amp;amp;read_fd)) {
        --nfds;
        // 这里处理read事件
      }
      if (FD_ISSET(i, &amp;amp;write_fd)) {
         --nfds;
        // 这里处理write事件
      }
    }
  }
 

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 186; 
			flex-basis: 446px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/2.png&#34; data-size=&#34;847x455&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/2.png&#34;
			width=&#34;847&#34;
			height=&#34;455&#34;
			srcset=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/2_hu01f397a43b9bb4df8736f1e60cb4211e_107852_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/2_hu01f397a43b9bb4df8736f1e60cb4211e_107852_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;select存在的问题&#34;&gt;select存在的问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;监控的文件描述符集合是有上线的，即存储的fd有最大值，默认的最大的fd为32位系统1024，64位系统2048(可设置)&lt;/li&gt;
&lt;li&gt;每一次都是需要将文件描述符集合从用户态拷贝到内核态，且内核态是通过轮询的方式判断fd是否就绪，当文件描述符增多时
会造成整体的性能的下降。&lt;/li&gt;
&lt;li&gt;文件描述符集合返回时，会将没有就绪的fd删除(将bitmap置为0)，当继续监控时，会将删除的fd添加到集合中&lt;/li&gt;
&lt;li&gt;返回到用户态的集合，并未明确就绪的文件描述符，仍然需要轮询判断&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;poll&#34;&gt;poll&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;poll 是采用链表来存储fd,没有了最大连接数的限制。用户未每一个fd定义一个事件结构体，然后将事件结构体的链表拷贝到内核中，
内核线程进行轮询遍历进行判断fd是否就绪。当有fd就绪就将就绪事件放入revents中，然后返回，用户态遍历事件链表对事件结构体的revents
进行判断就绪的fd，进行相关的io操作获取数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;#include &amp;lt;poll.h&amp;gt;
// 数据结构
struct pollfd {
    int fd;                         // 需要监视的文件描述符
    short events;                   // 需要内核监视的事件（读写）
    short revents;                  // 实际发生的事件
};
//
// API
int poll(struct pollfd fds[], nfds_t nfds, int timeout); // fd的集合， 个数，超时时间
// 
// 先宏定义长度
#define MAX_POLLFD_LEN 4096  

int main() {
  /*
   * 在这里进行一些初始化的操作，
   * 比如初始化数据和socket等。
   */

  int nfds = 0;
  pollfd fds[MAX_POLLFD_LEN];
  memset(fds, 0, sizeof(fds));
  fds[0].fd = listenfd;
  fds[0].events = POLLRDNORM;
  int max  = 0;  // 队列的实际长度，是一个随时更新的，也可以自定义其他的
  int timeout = 0;

  int current_size = max;
  while (1) {
    // 阻塞获取
    // 每次需要把fd从用户态拷贝到内核态
    nfds = poll(fds, max+1, timeout);
    if (fds[0].revents &amp;amp; POLLRDNORM) {
        // 这里处理accept事件
        connfd = accept(listenfd);
        //将新的描述符添加到读描述符集合中
    }
    // 每次需要遍历所有fd，判断有无读写事件发生
    for (int i = 1; i &amp;lt; max; ++i) {     
      if (fds[i].revents &amp;amp; POLLRDNORM) { 
         sockfd = fds[i].fd
         if ((n = read(sockfd, buf, MAXLINE)) &amp;lt;= 0) {
            // 这里处理read事件
            if (n == 0) {
                close(sockfd);
                fds[i].fd = -1;
            }
         } else {
             // 这里处理write事件     
         }
         if (--nfds &amp;lt;= 0) {
            break;       
         }   
      }
    }
  }

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;poll存在的问题&#34;&gt;poll存在的问题&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;poll解决了select的最大连接数的问题，但是还是存在：每次调用poll都需要将fd文件描述符集合拷贝到内核态&lt;/li&gt;
&lt;li&gt;对fd是线性扫描，即还是采用了轮询遍历的方法,内核态中监控是否有就绪的fd,用户态中判断就绪的fd&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;epoll&#34;&gt;epoll&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;epoll是采用红黑树存储fd,采用rdlist存储就绪的fd, 通过epoll_creat()方法来创建eventPoll结构体(红黑树+relist)。
通过epoll_ctl()方法将fd存入到红黑树中，若有就绪的fd,就调用ep_poll_callback()回调函数将就绪的fd添加到relist中。
调用event_wait()检查是否有就绪的fd,即检测relist是否为空。若不为空，将将就绪的fd的数量返回。用户态遍历relist+返回的就绪的fd
的数量即可获得数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
#include &amp;lt;sys/epoll.h&amp;gt;

// 数据结构
// 每一个epoll对象都有一个独立的eventpoll结构体
// 用于存放通过epoll_ctl方法向epoll对象中添加进来的事件
// epoll_wait检查是否有事件发生时，只需要检查eventpoll对象中的rdlist双链表中是否有epitem元素即可
struct eventpoll {
    /*红黑树的根节点，这颗树中存储着所有添加到epoll中的需要监控的事件*/
    struct rb_root  rbr;
    /*双链表中则存放着将要通过epoll_wait返回给用户的满足条件的事件*/
    struct list_head rdlist;
};
// 对于每一个事件，都会建立一个epitem结构体
struct epitem{
    struct rb_node  rbn;//红黑树节点
    struct list_head    rdllink;//双向链表节点
    struct epoll_filefd  ffd;  //事件句柄信息
    struct eventpoll *ep;    //指向其所属的eventpoll对象
    struct epoll_event event; //期待发生的事件类型
}

// API
int epoll_create(int size); // 内核中间加一个 ep 对象，把所有需要监听的 socket 都放到 ep 对象中
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); // epoll_ctl 负责把 socket 增加、删除到内核红黑树
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);// epoll_wait 负责检测可读队列，没有可读 socket 则阻塞进程
//epoll使用示例
int main(int argc, char* argv[])
{
   /*
   * 在这里进行一些初始化的操作，
   * 比如初始化数据和socket等。
   */

    // 内核中创建ep对象
    epfd=epoll_create(256);
    // 需要监听的socket放到ep中
    epoll_ctl(epfd,EPOLL_CTL_ADD,listenfd,&amp;amp;ev);
 
    while(1) {
      // 阻塞获取
      nfds = epoll_wait(epfd,events,20,0);
      for(i=0;i&amp;lt;nfds;++i) {
          if(events[i].data.fd==listenfd) {
              // 这里处理accept事件
              connfd = accept(listenfd);
              // 接收新连接写到内核对象中
              epoll_ctl(epfd,EPOLL_CTL_ADD,connfd,&amp;amp;ev);
          } else if (events[i].events&amp;amp;EPOLLIN) {
              // 这里处理read事件
              read(sockfd, BUF, MAXLINE);
              //读完后准备写
              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;amp;ev);
          } else if(events[i].events&amp;amp;EPOLLOUT) {
              // 这里处理write事件
              write(sockfd, BUF, n);
              //写完后准备读
              epoll_ctl(epfd,EPOLL_CTL_MOD,sockfd,&amp;amp;ev);
          }
      }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 262; 
			flex-basis: 630px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/5.png&#34; data-size=&#34;1651x628&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/5.png&#34;
			width=&#34;1651&#34;
			height=&#34;628&#34;
			srcset=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/5_hu2b83fdcd48661756703b6b6463448f49_248190_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/5_hu2b83fdcd48661756703b6b6463448f49_248190_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;epoll-优点&#34;&gt;epoll 优点&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;采用了红黑树进行存储fd, 没有fd的最大连接数限制&lt;/li&gt;
&lt;li&gt;采用了事件回调的方式，即有就绪的fd时，就会将fd通过回调函数添加到relist表中，并不是采用轮询+遍历的方式&lt;/li&gt;
&lt;li&gt;利用mmap()文件映射内存加速与内核态空间的信息传递(用户态与内核态共享内存)，减少了fd集合从用户态拷贝
(用户空间和内核空间的只拷贝一次)到内核态的开销&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;epoll的触发&#34;&gt;epoll的触发&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;水平触发LT:只有要就绪的fd,epoll_wait()就会返回，并提醒用户态进行相关的操作。即只有缓冲区有变化就会触发&lt;/li&gt;
&lt;li&gt;边缘触发ET:当文件描述符关联的缓冲区有空转为非空时，或者是缓冲区由满到不满就会触发。即只有缓冲区有空转为非空或者是由满转为非满的
情况才会触发。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三者总结&#34;&gt;三者总结&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 134; 
			flex-basis: 322px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/3.png&#34; data-size=&#34;673x501&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/3.png&#34;
			width=&#34;673&#34;
			height=&#34;501&#34;
			srcset=&#34;https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/3_hu407313779efa40a3c2449c5134b0af99_194287_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/3_hu407313779efa40a3c2449c5134b0af99_194287_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6882984260672847879#heading-13&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;彻底理解 IO 多路复用实现机制&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>redis进阶</title>
        <link>https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/</link>
        <pubDate>Wed, 08 Dec 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/5.png" alt="Featured image of post redis进阶" /&gt;&lt;h2 id=&#34;redis的网络协议&#34;&gt;redis的网络协议&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;redis是基于tcp/ip协议，即客户端与服务器保持双工连接，通过序列化的协议(resp协议)进行数据的交互，在Redis中，协议数据分为不同的类型，
每种类型的数据均以CRLF（\r\n）结束，通过数据的首字符区分类型
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 142; 
			flex-basis: 343px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/1.png&#34; data-size=&#34;449x314&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/1.png&#34;
			width=&#34;449&#34;
			height=&#34;314&#34;
			srcset=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/1_hu6689e274a0996608cb8ab14cd419ea9e_23725_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/1_hu6689e274a0996608cb8ab14cd419ea9e_23725_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;redis服务器是一个事件驱动系统主要分为：文件事件(io事件)和时间事件&lt;/li&gt;
&lt;li&gt;文件驱动：socket的读取事件(io事件)是由；连接(三次握手)、请求、响应(数据返回)、断开连接(四次挥手)组成，redis是采用单线程
和epoll(io多路复用)的机制处理相关的文件事件。&lt;/li&gt;
&lt;li&gt;时间事件：可分为定时事件(程序在指定时间后执行相关的操作)和周期事件(程序每隔一段时间运行相关的操作)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis客户端与服务器交互模式&#34;&gt;redis客户端与服务器交互模式&lt;/h2&gt;
&lt;h3 id=&#34;串行的请求交互模式&#34;&gt;串行的请求/交互模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;客户端与服务器建立长连接，通过心跳检测(ping-pong)ack应答，即客户端发送请求，服务器在进行响应。&lt;/li&gt;
&lt;li&gt;在单连接下。大部分时间都是处于网络等待上(客户端在发送请求命令，并监听socket返回，通常以阻塞模式等待服务器端的响应)，这种模式下
的性能较低
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 132; 
			flex-basis: 317px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/2.png&#34; data-size=&#34;459x347&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/2.png&#34;
			width=&#34;459&#34;
			height=&#34;347&#34;
			srcset=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/2_hud8100cb78349642cfc277c6a21e59924_8613_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/2_hud8100cb78349642cfc277c6a21e59924_8613_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;管道技术pipeline双工的请求响应模式&#34;&gt;管道技术(pipeline)双工的请求/响应模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将一批命令进行打包，然后发送给服务器，服务器获取数据后按顺序打包返回，即批量请求，批量响应。以次来减少网络等待的延时，提高性能
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 70; 
			flex-basis: 168px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/3.png&#34; data-size=&#34;459x654&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/3.png&#34;
			width=&#34;459&#34;
			height=&#34;654&#34;
			srcset=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/3_hu66e812f3a220eb5db0a394f5a9aa9cc3_20538_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/3_hu66e812f3a220eb5db0a394f5a9aa9cc3_20538_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;原子化的批量请求响应事务模式&#34;&gt;原子化的批量请求/响应(事务)模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;客户端将请求的命令发送发到服务器，服务器经这些请求暂存在服务器的请求队列中，这过程也称为：请求入队列。服务器在从请求队列中
拿去所有的请求执行，然后再将数据返回给客户端，这过程称为执行阶段。&lt;/li&gt;
&lt;li&gt;服务器在执行过程中不会在接收其他客户端发送的请求。所有的操作都是原子操作，即请求都执行或都不执行。&lt;/li&gt;
&lt;li&gt;事务的步骤为：开始事务-&amp;gt;请求入队列-&amp;gt;执行请求
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 132; 
			flex-basis: 317px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/4.png&#34; data-size=&#34;459x347&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/4.png&#34;
			width=&#34;459&#34;
			height=&#34;347&#34;
			srcset=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/4_huf01a29421262a303fde2c9249c01cc9c_12313_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/4_huf01a29421262a303fde2c9249c01cc9c_12313_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;发布订阅pubsub模式&#34;&gt;发布/订阅(pub/sub)模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;发布者(pub)发送消息，订阅者(sub)接收消息，发布者和订阅者通过(通道)channel关联，所有的channel都是由一个map维护，map的key是
channel的名字，value是所有的订阅者的指针链表。客户端可以订阅任意的数量的频道，也可以进行发布。&lt;/li&gt;
&lt;li&gt;发布者和订阅者都是客户端，服务器只是进行数据的中转。即发布者着向服务端发起请求，服务端将请求的数据推送给订阅者。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 139; 
			flex-basis: 334px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/5.png&#34; data-size=&#34;537x385&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/5.png&#34;
			width=&#34;537&#34;
			height=&#34;385&#34;
			srcset=&#34;https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/5_hu55d28ed2616667077617555b48a30f7c_17120_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/redis%E8%BF%9B%E9%98%B6/5_hu55d28ed2616667077617555b48a30f7c_17120_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis的持久化机制&#34;&gt;redis的持久化机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;redis的持久化机制主要是有：RDB(快照)和AOF(日志)两种持久化的方式。持久的化的作用在于：故障恢复和数据恢复&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rdb快照持久化机制&#34;&gt;RDB(快照)持久化机制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;快照是redis默认的持久化方案，在指定时间间隔内生成数据集的时间点，即在指定的时间段内将内存的数据写入磁盘，在磁盘
上生成一个rdb的备份文件。在redis重启时加载rdb文件进行数据的恢复。&lt;/li&gt;
&lt;li&gt;快照的持久化提供自动备份：需要修改配置文件redis.conf。也提供save和bysave(后台子进程)进行主动备份&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rdb快照的工作流程&#34;&gt;RDB(快照)的工作流程：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;主进程会单独创建子进程，将主进程的数据库的数据复制到子进程。&lt;/li&gt;
&lt;li&gt;子进程将数据写入到临时文件中进行持久化，在经临时文件替换之前的rdb文件,子进程退出，释放内存中的数据&lt;/li&gt;
&lt;li&gt;主进程不进行持久化，即不进行任何的io操作，确保redis的极高的性能&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;rdb快照的优缺点&#34;&gt;RDB(快照)的优缺点&lt;/h4&gt;
&lt;h5 id=&#34;优点&#34;&gt;优点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;单一的紧凑文件保存了莫一段时间的数据集，比较适合做数据的备份尤其的冷备份&lt;/li&gt;
&lt;li&gt;在对数据完整性不敏感下，适合大规模的数据的恢复，因直接从磁盘获取数据，恢复数据快&lt;/li&gt;
&lt;li&gt;由子进程进行持久化，主进程不进行持久化，即不进行任何的io操作，确保redis的极高的性能&lt;/li&gt;
&lt;/ol&gt;
&lt;h5 id=&#34;缺点&#34;&gt;缺点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;不能保障数据的完整性，若redis出现宕机，就不会出现最近的数据未持久化，导致数据的丢失。&lt;/li&gt;
&lt;li&gt;当持久化的数据量较大时，会导致持久化的子进程就会很耗时，即使主线程在不参与持久化也可能导致服务器在毫秒级内不能响应
客户端的请求，若数据巨大时且cpu的性能不佳时，会出现秒级不能响应客户端的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;aof日志持久化&#34;&gt;AOF(日志)持久化&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;通过将每个写操作记录到日志中且以追加文件不修改文件的模式，重启时更具根据日志文件从头到未执行一遍即恢复数据。，因AOF采用的是经操作记录以追加模式下写入日志文件中，会导致AOF文件越来越大。AOF引入了重写机制。&lt;/li&gt;
&lt;li&gt;AOF引入了重写机制：当文件AOF是上次重写大小的一倍且文件大于64MB时就创建一个子进程遍历服务器的键值对，转换成一系列 Redis 的操作
指令，序列化到一个新的AOF日志文件中，再替换旧的AOF日志文件。可以修改配置文件设定持久化策略。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;aof-提供了三种持久化策略&#34;&gt;AOF 提供了三种持久化策略：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;no: 无 fsync，由系统保证数据刷新到磁盘，速度最快，但很不安全（通常不使用）；&lt;/li&gt;
&lt;li&gt;always: 每次 fsync，每一个修改内存的 Redis 指令都会执行一次 fsync，速度很慢（通常不使用）；&lt;/li&gt;
&lt;li&gt;everysec: 每秒进行一次 fsync，有可能丢失一秒的 fsync 的数据。通常选择 everysec 策略，兼顾安全性和效率。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;aof日志的优缺点&#34;&gt;AOF(日志)的优缺点&lt;/h4&gt;
&lt;h5 id=&#34;优点-1&#34;&gt;优点&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;可以采用everysec的持久化策略，能确保数据的完整性&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;缺点-1&#34;&gt;缺点&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;AOF的日志文件通常是比rdb文件大&lt;/li&gt;
&lt;li&gt;在数据的恢复时，需要遍历日志文件，将日志文件的数据操作命令在执行一遍，导致数据恢复相对于快照(rdb)较慢，尤其在大数据下。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;redis-缓存中的状况于解决方案&#34;&gt;redis 缓存中的状况于解决方案&lt;/h2&gt;
&lt;h3 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数据未加载到内存或者同一时间发生大规模的key失效，从而导致所有的请求都直接在查数据库。导致数据库和cpu负载过高，甚至宕机&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决方案&#34;&gt;解决方案&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;加锁计数，限制并发的数量，避免出现并发出现大量的请求访问到数据库，降低服务器的吞吐量&lt;/li&gt;
&lt;li&gt;设置热点key永不失效，均匀过期，避免出现大面积的key同时失效&lt;/li&gt;
&lt;li&gt;设置缓存服务器的主备&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指客户端请求的数据在缓存和数据库中均没有，导致客户端在每次请求都需要去数据库查询。若在并发时，也会导致数据库和cpu的负载过高，
导致数据库的宕机&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决方案-1&#34;&gt;解决方案&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;若查询数据库不存在，直接在缓存中保存一个默认的值，并设置较短的过期时间，下次请求直接从缓存中返回。&lt;/li&gt;
&lt;li&gt;使用布隆过滤器，阻挡无效的请求。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存并发&#34;&gt;缓存并发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在并发情况下，一个缓存失效，在高并发下访问数据库，缓存更新，也会导致数据的压力变大。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决方案-2&#34;&gt;解决方案&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对缓存加锁，若key不存在，就加锁，当查询数据库的数据写入缓存在解锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存预热&#34;&gt;缓存预热&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在系统运行前，将数据加载到缓存中&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;解决方案-3&#34;&gt;解决方案&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;数据量不大，直接加载&lt;/li&gt;
&lt;li&gt;数据量大时，设置定时的脚本进行缓存的刷新&lt;/li&gt;
&lt;li&gt;数据量巨大时，优先保障热点数据提前加载到缓存中&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;缓存降级&#34;&gt;缓存降级&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指缓存失效或者缓存服务器宕机时，不去访问数据库，直接返回默认值或访问内存数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分布锁&#34;&gt;分布锁&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用setnx加锁，并设置超时时间，过了超时时间就解锁，并删除锁&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1193256&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Redis 客户端服务端交互1 客户端/服务端协议&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>初识redis(数据结构分析)</title>
        <link>https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</link>
        <pubDate>Sun, 05 Dec 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/2.png" alt="Featured image of post 初识redis(数据结构分析)" /&gt;&lt;h2 id=&#34;redis&#34;&gt;redis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;redis 是一个开源（BSD许可）的，数据结构为key-value的存储系统。它可以用作分布式数据库、缓存
和消息队列（消息中间件）。数据保存在内存中，存取速度快，并发能力强。&lt;/li&gt;
&lt;li&gt;redis 支持多种数据结构，如字符串、map(哈希)、列表、集合、有序集合等数据类型。数据都是原子操作，
数据都缓存在内存中，会定期将数据更新到磁盘或者修改操作写入追加记录。再次基础上实现了主从（master-slave）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis-数据结构&#34;&gt;redis 数据结构&lt;/h2&gt;
&lt;h3 id=&#34;字符串string类型&#34;&gt;字符串(string)类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;字符串类型是redis最基础的数据结构，可以存储简单的字符串也可存储复杂的xml、json、二进制数据（如图像、音频）&lt;/li&gt;
&lt;li&gt;value内部以保存整数的int和保存字符的sds组成的数据存储结构。sds内部结构为：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct sdshdr {
    int len;    // 记录着buf中也使用的字符串数量
    int free;   // 记录着buf中未使用的字符串数量
    char buh[]; // 字符串数组，用于保存字符串
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 246; 
			flex-basis: 592px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/1.png&#34; data-size=&#34;412x167&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/1.png&#34;
			width=&#34;412&#34;
			height=&#34;167&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/1_hu10d85d220e4dbf0a3b0aa571391694a5_13796_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/1_hu10d85d220e4dbf0a3b0aa571391694a5_13796_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;字符串类型特性&#34;&gt;字符串类型特性&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;分配冗余空间：采用预先分配冗余空间的方式来减少内存的频繁分配&lt;/li&gt;
&lt;li&gt;自动扩容： 当字符串所占空间小于1MB时，redis会按照字符串（len + addLen）*2倍数存储空间增加，
当字符串的存储空间超过所占空间的1MB时，每次自会增加1MB的存储空间扩容，最大扩容为512MB的存储空间&lt;/li&gt;
&lt;li&gt;二进制的安全性，兼容c语言函数库中字符串以\0结束。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;字符串常用的场景&#34;&gt;字符串常用的场景&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;缓存功能： 基于redis作为缓存再配合其他的数据库最为存储层，利用redis的数据存储在内存和支持高并发的特点，可以大大加快
系统的读写速度以及降低后端数据库的压力。（单值缓存、对象缓存、分布式锁等）&lt;/li&gt;
&lt;li&gt;计数器： 使用redis作为系统的实时计数器，可以加快计数和查询功能。&lt;/li&gt;
&lt;li&gt;共享用户的session：利用redis将用户的session集中管理，这种模式确保redis的高可用。每次用户的session的更新和获取快速完成&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;列表list&#34;&gt;列表(list)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;list类型的value对象内部采用的quicklist(快速列表)或者ziplist(压缩列表)承载。当list的元素和单个元素较小时采用ziplist实现来减少内存的
占用否则采用quicklist结构进行存储。&lt;/li&gt;
&lt;li&gt;ziplist所有内容都存放在来连续的内存中。zipbytes表示ziplist的总长度， zltail表示指向最末的元素，zllen表示元素个数， entryX表示元素自身内容， zlend是ziplist的定界符
ziplist的内部结构为：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct ziplist{
     /*ziplist分配的内存大小*/
     uint32_t bytes;
     /*达到尾部的偏移量*/
     uint32_t tail_offset;
     /*存储元素实体个数*/
     uint16_t length;
     /*存储内容实体元素*/
     unsigned char* content[];
     /*尾部标识*/
     unsigned char end;
}ziplist;

/*元素实体所有信息, 仅仅是描述使用, 内存中并非如此存储*/
typedef struct zlentry {
     /*前一个元素长度需要空间和前一个元素长度*/
    unsigned int prevrawlensize, prevrawlen;
     /*元素长度需要空间和元素长度*/
    unsigned int lensize, len;
     /*头部长度即prevrawlensize + lensize*/
    unsigned int headersize;
     /*元素内容编码*/
    unsigned char encoding;
     /*元素实际内容*/
    unsigned char *p;
}zlentry;

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 871; 
			flex-basis: 2092px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/3.png&#34; data-size=&#34;898x103&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/3.png&#34;
			width=&#34;898&#34;
			height=&#34;103&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/3_hub4a60118f08cb1a1c39a8da3f9909d0d_17774_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/3_hub4a60118f08cb1a1c39a8da3f9909d0d_17774_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;quicklist是底层是ziplist的双向链表,结构为：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;struct quicklistNode {
    quicklistNode *prev;
    quicklistNode *next;
    ziplist *zl;         // 指向压缩列表
    int32 size;          // ziplist字节总数
    int16 count;         // ziplist中元素数量
    int2 encoding;       // 存储形式，表示原生字节数组还是LZF压缩存储
    ...
} quicklistNode；

// 快速列表
struct quicklist {
    quicklistNode *head;
    quicklistNode *next;
    long count;           // 元素总数
    int nodes;            // ziplist节点个数
    int compressDepth;    // LZF算法压缩深度
}
quicklist;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 319; 
			flex-basis: 765px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/4.png&#34; data-size=&#34;737x231&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/4.png&#34;
			width=&#34;737&#34;
			height=&#34;231&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/4_hua6e8ac52687c658457e0eb02eca5ab50_34064_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/4_hua6e8ac52687c658457e0eb02eca5ab50_34064_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redis的list支持存储2的32次方个元素，可以通过下标获取指定元素和莫个范围的元素集&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;列表常用场景&#34;&gt;列表常用场景&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;消息队列：redis的链表式结构，可以轻松实现阻塞队列，可以使用左进右出的命令完成队列的设计&lt;/li&gt;
&lt;li&gt;文章列表或者数据分页展示的应用&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;map类型hash-散列&#34;&gt;map类型(hash 散列)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;map主要由hashtable和ziplist两种承载方式承载。当存储数据较小时，采用ziplist实现&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;hashtable组成&#34;&gt;hashtable组成&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;dict: 当dictht需要扩容/缩容时，用于管理桶的迁移，结构图下&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct dict{
  // 类型特定函数
  dictType *type;
  // 私有数据
  void *private;
  // 哈希表
  dictht ht[2];
  // rehash 索引，当当前的字典不在 rehash 时，值为-1
  int trehashidx;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;dictht: 维护哈希表的说有桶连,结构如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct dictht{
     //哈希表数组
     dictEntry **table;
     //哈希表大小
     unsigned long size;
     //哈希表大小掩码，用于计算索引值
     //总是等于 size-1
     unsigned long sizemask;
     //该哈希表已有节点的数量
     unsigned long used;
 
}dictht
&lt;/code&gt;&lt;/pre&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;dictEntry:管理一个k-v对，同时保留着一个桶中相邻元素的指针，一次维护哈希桶内部相连，结构如下&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct dictEntry{
     void *key;
     union{
          void *val;
          uint64_tu64;
          int64_ts64;
     }v;
     //下一个
     struct dictEntry *next;
}dictEntry
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 160; 
			flex-basis: 384px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/2.png&#34; data-size=&#34;989x618&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/2.png&#34;
			width=&#34;989&#34;
			height=&#34;618&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/2_hu2e0e0d83f63ca97b7bb5a7ad9fe95b5f_87192_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/2_hu2e0e0d83f63ca97b7bb5a7ad9fe95b5f_87192_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;ziplist&#34;&gt;ziplist&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;map中对应的ziplist的entry的个数一定是2的整数倍。即奇数存放着key,偶数存放着value&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;map类型的特性&#34;&gt;map类型的特性&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;map内部的key和value不能在嵌套map,只能是string，int或着是float&lt;/li&gt;
&lt;li&gt;负载因子 = 哈希表中已有的元素/哈希桶数&lt;/li&gt;
&lt;li&gt;扩容：通过负载因子判断是否需要增加桶数。即当负载因子小于1时，一定不扩容，
当负载因子大于1，且在没有在执行BGSAVE进行或当负载因子大于5时，一顶会进行扩容，
扩容时，新桶的数目是现有桶数目的两倍。&lt;/li&gt;
&lt;li&gt;缩容：当负载因子小于0.1时，就进行缩容。&lt;/li&gt;
&lt;li&gt;扩/缩容都是通过新建哈希表的方式实现，扩容时新建现有桶的2倍的新表，缩容时是新建原表的一半新建哈希表。
将原表的桶逐步迁移到目标表(新建的哈希表)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;map常用场景&#34;&gt;map常用场景&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;利用键值对的特性，用来存储关系性数据库中表的记录&lt;/li&gt;
&lt;li&gt;存储用户信息，优化用户信息的来源，提高系统的性能&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;集合set类型&#34;&gt;集合(set)类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;set是由inset或者hashtable来存储，hashtable的value永远为nil,只有int类型是使用inset进行存储&lt;/li&gt;
&lt;li&gt;inset:其核心是一个字符数组&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;set类型的特性&#34;&gt;set类型的特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;允许重复元素，没有顺序，没有下表，支持集合内的增删改查，并支持多个集合的交、并、差集等操作&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;set常用场景&#34;&gt;set常用场景&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;根据set的特性，适合于聚合分类，如标签、好友共同喜好等场景&lt;/li&gt;
&lt;li&gt;利用set中元素的唯一性，适合于数据的唯一性，如统计网站的独立ip&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;有序集合sorted-set&#34;&gt;有序集合(sorted-set)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;sorter-set是的内部结构是以压缩列表(ziplist)或者跳跃表(skiplist)+hashtable构成&lt;/li&gt;
&lt;li&gt;sorted-set类似于map的键值对(key-value)且有序，value是一个浮点数称之为score，是排序的根据&lt;/li&gt;
&lt;li&gt;跳跃表(skiplist)其核心点主要是包括一个dict对象和一个skiplist对象,结构如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;typedef struct zset{
     //跳跃表
     zskiplist *zsl;
     //字典
     dict *dice;
} zset

/* ZSETs use a specialized version of Skiplists */
/*
 * 跳跃表节点
 */
typedef struct zskiplistNode {

    // 成员对象
    robj *obj;

    // 分值
    double score;

    // 后退指针
    struct zskiplistNode *backward;

    // 层
    struct zskiplistLevel {

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    } level[];

} zskiplistNode;

/*
 * 跳跃表
 */
typedef struct zskiplist {

    // 表头节点和表尾节点
    struct zskiplistNode *header, *tail;

    // 表中节点的数量
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;

} zskiplist;


&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 354; 
			flex-basis: 851px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/5.png&#34; data-size=&#34;954x269&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/5.png&#34;
			width=&#34;954&#34;
			height=&#34;269&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/5_hu22c80974dd2a8a5013611fd6e9753500_113480_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/5_hu22c80974dd2a8a5013611fd6e9753500_113480_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;有序集合sorted-set特性&#34;&gt;有序集合(sorted-set)特性&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;sorted-set是集合的基础上，增加了给每一个元素设置分数(score),利用该分数进行排序，集合元素是唯一的，分数是不唯一的。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;有序集合sorted-set常用创景&#34;&gt;有序集合(sorted-set)常用创景&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;利用它的特性，可以适合于排序的场景，如排行榜等&lt;/li&gt;
&lt;li&gt;根据集合的每个元素都设置了一个score分数的特性，做带权的队列，如：普通的信息的权重为1，重要的信息的权重为2，
应用线程可以根据权重调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1690533&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Redis底层数据结构详解&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>初探jwt(json web Token)</title>
        <link>https://zcj-git520.github.io/p/%E5%88%9D%E6%8E%A2jwtjson-web-token/</link>
        <pubDate>Tue, 30 Nov 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E5%88%9D%E6%8E%A2jwtjson-web-token/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E5%88%9D%E6%8E%A2jwtjson-web-token/1.png" alt="Featured image of post 初探jwt(json web Token)" /&gt;&lt;h2 id=&#34;jwt&#34;&gt;jwt&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;jwt 它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息，是最流行的跨域认证的解决方案&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;传统跨域认证&#34;&gt;传统跨域认证&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客服端向服务器发送用用户名和密码，服务器验证通过后，把当前对话的session里保存
相关数据，并写在客户端的cookie, 向客户端返回一个session id。客户端再次通过cookie,
经session id 传回服务器，服务器通过session id得知访问客户端的身份。&lt;/li&gt;
&lt;li&gt;存在的问题：扩展性不佳，服务器集群或者跨域的服务导向架构，就需要共享session共享数据
解决方案：1. 将session 数据保存在数据库中或者其他的持久层，服务器访问持久层的session数据    2. 服务器不保存session数据，所有的数据保存在客户端，每次请求都发回服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jwt的原理&#34;&gt;jwt的原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;服务器认证以后，生成一个json对象，返回给客户端之后，客户端与服务器靠这个json对象认证，会会
加上签名来防止客户端修该json 对象&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;jwt的数据结构&#34;&gt;jwt的数据结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;jwt的数据结构为：Header(头部)、payload(负载)、signature(签名)&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 190; 
			flex-basis: 457px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E6%8E%A2jwtjson-web-token/1.png&#34; data-size=&#34;1185x621&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E6%8E%A2jwtjson-web-token/1.png&#34;
			width=&#34;1185&#34;
			height=&#34;621&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E6%8E%A2jwtjson-web-token/1_hu679d1d76db059750024901bffb37cf39_65265_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E6%8E%A2jwtjson-web-token/1_hu679d1d76db059750024901bffb37cf39_65265_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;header头部&#34;&gt;Header(头部)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Header部分是一个json对象，描述jwt的元素据。声明类型，这里是jwt声明加密的算法 通常直接使用 HMAC SHA256，结构如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  &#39;typ&#39;: &#39;JWT&#39;,
  &#39;alg&#39;: &#39;HS256&#39;
} 
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;payload负载&#34;&gt;payload(负载)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;payload 也是一个json对象，用来存放实际需要的传递的数据，iss：发行人，exp：到期时间，sub：主题，aud：用户，
nbf：在此之前不可用，iat：发布时间，jti：JWT ID用于标识该JWT&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
  &amp;quot;sub&amp;quot;: &amp;quot;1234567890&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;,
  &amp;quot;admin&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;signature签名&#34;&gt;signature(签名)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是对前两部分进行签名，防止篡改。在服务器上指明一个密钥，在根据header中指定的算法，
按照格式产生签名，header (base64后的)、payload (base64后的)、secret。其格式如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// javascript
var encodedString = base64UrlEncode(header) + &#39;.&#39; + base64UrlEncode(payload);

var signature = HMACSHA256(encodedString, &#39;secret&#39;); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;jwt的特点&#34;&gt;jwt的特点&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;jwt默认不加密，但是可以对原生的Token加密或者使用https加密传输&lt;/li&gt;
&lt;li&gt;jwt在不加密的情况下，不能加秘密数据写入jwt&lt;/li&gt;
&lt;li&gt;jwt不仅可以使用与认证，也能用于信息的交换&lt;/li&gt;
&lt;li&gt;jwt不能在使用过程中清除莫一个token和更改该token的权限，一旦签发一直到到期都是有效的，应该jwt
的有效期&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;认证&#34;&gt;认证&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;认证就是根据声明者所持有的识别信息，确认声明者的身份&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;授权&#34;&gt;授权&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一般是指获取用户的委派的权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;鉴权&#34;&gt;鉴权&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;指对一个声明者所声明的身份的权限的真实性进行鉴别和确认的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;权限控制&#34;&gt;权限控制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是指可执行和操作的组合配置的权限列表，然后根据执行者的权限，若其操作在权限范围内，则允许执行，否则禁止&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/576dbf44b2ae&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;什么是 JWT &amp;ndash; JSON WEB TOKEN&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>初识Nginx</title>
        <link>https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/</link>
        <pubDate>Wed, 24 Nov 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/1.jpg" alt="Featured image of post 初识Nginx" /&gt;&lt;h2 id=&#34;nginx&#34;&gt;Nginx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;nginx 是轻量级高并发web服务器，是基于Rest架构风格。通过http协议提供各种网络服务&lt;br&gt;
其高并发是基于事件驱动架构，io多路复用的epoll,使得可以轻松支持百万计的icp连接。&lt;br&gt;
轻量级主要体现在：采用插件化开发，cup亲和，将cpu与nginx工作进程绑定，减少cpu切换带来的消耗&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代理&#34;&gt;代理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;代理是客户端与服务器之间的一层服务器，将客户端的请求转发给服务器，然后服务器的响应转发给客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;正向代理&#34;&gt;正向代理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;客户端向代理服务器转发请求和指定目标服务器，代理服务器向目标服务器发送请求，并将结果返回给客户端。
对客户端是透明的，即客户端知道访问的是目标服务器，对目标服务器来说是非透明的，并不知道访问服务器是
客户端还是代理服务器&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反向代理&#34;&gt;反向代理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;客户端向代理服务器发送请求，代理服务器将请求转发给内部的网络服务器(目标服务器)，在将结果返回给客户端。对于客户端
是非透明的，即客户端不清楚是访问是那一台目标服务器。对于目标服务器是透明的，即目标服务器知道访问的是
代理服务器&lt;/li&gt;
&lt;li&gt;nginx反向代理的配置如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;server {
         listen       80;
         server_name  www.123.com;
 
         location / {
             proxy_pass http://127.0.0.1:8080;
             index  index.html index.htm index.jsp;
         }
     }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们监听80端口，访问域名为www.123.com，不加端口号时默认为80端口，故访问该域名时会跳转到127.0.0.1:8080路径上&lt;/p&gt;
&lt;h2 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;当请求过大时，将请求分发给各个服务器。负载均衡的分配策略为：weight(权重)轮询，fair(智能调整调度)&lt;/li&gt;
&lt;li&gt;nginx轮询配置(所有请求都按照时间顺序分配到不同的服务上)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;upstream  dalaoyang-server {
       server    localhost:10001;
       server    localhost:10002;
}  
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;nginx权重配置(权重轮询：代理服务器接收到请求，按照设定的权重，请求分配到不同的后端服务器，如果发现后端服务器宕机时，
代理服务器会将其剔除出队列)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;upstream  dalaoyang-server {
       server    localhost:10001 weight=1;
       server    localhost:10002 weight=2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;nginx iphash 配置(每个请求都根据访问ip的hash结果分配)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;upstream  dalaoyang-server {
       ip_hash; 
       server    localhost:10001 weight=1;
       server    localhost:10002 weight=2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;最少连接(将请求分配到连接数最少的服务上)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;upstream  dalaoyang-server {
       least_conn;
       server    localhost:10001 weight=1;
       server    localhost:10002 weight=2;
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;far 智能调整调度算法：动态根据后端服务器的请求处理到响应时间进行均衡分配。即响应时间短，处理效率高的服务器
分配到请求的概率高。响应时间长，效率低的服务器分配到请求的概率低。&lt;/li&gt;
&lt;li&gt;far 配置文件如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;upstream  dalaoyang-server {
       server    localhost:10001 weight=1;
       server    localhost:10002 weight=2;
       fair;  
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;流量控制&#34;&gt;流量控制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;限流实际就是限制流入请求的数量：有计数器固定窗口算法、令牌桶算法、漏桶算法和限制并发连接数限制&lt;br&gt;
令牌桶算法:存在一个大小固定的令牌桶，会以恒定的速率源源不断产生令牌。如果令牌消耗速率小于生产令牌的速度，
令牌就会一直产生直至装满整个令牌桶。如果请求获取令牌失败则请求会被禁止访问&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 106; 
			flex-basis: 256px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/2.png&#34; data-size=&#34;999x936&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/2.png&#34;
			width=&#34;999&#34;
			height=&#34;936&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/2_hu32db3512bcf017fe8e89ae9cfa277d82_97071_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/2_hu32db3512bcf017fe8e89ae9cfa277d82_97071_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
漏桶算法:突发流量会进入到一个漏桶，漏桶会按照我们定义的速率依次处理请求，如果水流过大也就是突发流量过大就会直接溢出，
则多余的请求会被拒绝。所以漏桶算法能控制数据的传输速率。算法的核心是：缓存请求、匀速处理、多余的请求直接丢弃。&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 139; 
			flex-basis: 335px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/4.png&#34; data-size=&#34;853x610&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/4.png&#34;
			width=&#34;853&#34;
			height=&#34;610&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/4_hu4c34e61a7398a86af1a9bb7f3b6efcab_287999_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%88%9D%E8%AF%86nginx/4_hu4c34e61a7398a86af1a9bb7f3b6efcab_287999_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;统一鉴权&#34;&gt;统一鉴权&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;客户端请求时，将Token放入在请求头head中。服务器解析Token,对访问者都进行鉴权，最后进入权力访问&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主流的网关&#34;&gt;主流的网关&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hong：是基于nginx+lua开源的网关&lt;/li&gt;
&lt;li&gt;Traefik是http反向代理和负载均衡器，支持动态配置和较好的伸缩性&lt;/li&gt;
&lt;li&gt;kubernetes是基于Envog Proxy构建的原生k8s网关&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ysocean/p/9392908.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Nginx（三）nginx 反向代理 &lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>http协议底层分析</title>
        <link>https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</link>
        <pubDate>Thu, 18 Nov 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/1.jpg" alt="Featured image of post http协议底层分析" /&gt;&lt;h2 id=&#34;http&#34;&gt;HTTP&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP是(Hyper Text Transfer Protocol)超文本传输协议, 基于tcp的应用层传输协议（请求-响应）协议&lt;/li&gt;
&lt;li&gt;影响HTTP网络请求的主要因素带宽和延迟&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;延迟的种类&#34;&gt;延迟的种类:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;浏览器阻塞(超过浏览器连接数限制的后续请求都会被阻塞)&lt;/li&gt;
&lt;li&gt;DNS查询 (将域名解析造成的延迟，可以通过缓存DNS进行解决)&lt;/li&gt;
&lt;li&gt;建立链接 (因HTTP是基于TCP的应用层协议，在建立连接时需要进行)&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http10&#34;&gt;HTTP1.0&lt;/h2&gt;
&lt;h3 id=&#34;http10存在的问题&#34;&gt;http1.0存在的问题：&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;短连接：规定客户端与服务器只保持短暂连接，客户端每次请求都需要建立连接，服务器完成请求后
断开连接，服务器不跟踪客户端，不保存客户端的请求记录。&lt;/li&gt;
&lt;li&gt;没有host头域：每台服务器都绑定一个唯一的IP地址，请求消息中的URL并没有传递主机名（hostname）&lt;/li&gt;
&lt;li&gt;不允许短点续传&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http11&#34;&gt;HTTP1.1&lt;/h2&gt;
&lt;h3 id=&#34;根据http10暴露的问题http11增加优化方案&#34;&gt;根据http1.0暴露的问题，http1.1增加优化方案&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;缓存处理：http1.1增加更多的缓存控制策略&lt;/li&gt;
&lt;li&gt;带宽优化及网络连接的使用：http1.1中请求头引入了range头域和支持断点续传的功能&lt;/li&gt;
&lt;li&gt;Host头处理：http1.1的请求消息和相应消息虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机(Multi-homed Web Servers),并且它们共享一个IP地址,HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）&lt;/li&gt;
&lt;li&gt;长连接： 支持长连接和流水线处理，默认开始是长连接：keep-alive&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;http11-也带来新的问题http-队头阻塞head-of-line-blocking&#34;&gt;http1.1 也带来新的问题：HTTP 队头阻塞(head of line blocking)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因http1.1支持了长连接和使用了管道机制，客户端与服务器建立一次连接，客户端不用等待服务器响应就能发送下一个请求，支持了并行发送多个请求，
但服务器必须按照请求的顺序来相应请求，也就是通过串行响应请求，这就造成了HTTP的队头阻塞。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解决http-队头阻塞方法&#34;&gt;解决Http 队头阻塞方法&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;并发连接：一个域名允许分配多个长连接，增加处理请求任务&lt;/li&gt;
&lt;li&gt;域名分片：将一个域名分解为多个域名，在进行并发连接&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;http20&#34;&gt;HTTP2.0&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP2.0主要是基于SPDY协议。实现了低延时高吞吐量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;spdy协议&#34;&gt;SPDY协议&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;是基于TCP协议的应用层协议，其目标是通过头部压缩、多路复用、优先级等作用缩短网页放入加载时间和
优化http的性能，其核心是尽量减少TCP连接数&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;http-20的特性&#34;&gt;HTTP 2.0的特性&lt;/h3&gt;
&lt;h3 id=&#34;头部压缩&#34;&gt;头部压缩&lt;/h3&gt;
&lt;p&gt;头部存在大量的信息，而且每次在发送都会降低http的性能，在用HPACK算法对头部进行压缩：
1.在客户端和服务器维持一个头部表来跟踪和存储客户端发来的键值对
2.客户端在请求的时候便只需要发送在表里的索引位置即可
3.HPACK 不仅仅通过索引键值对来降低数据量，同时还会将字符串进行霍夫曼编码来压缩字符串大小
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 305; 
			flex-basis: 733px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/1.jpg&#34; data-size=&#34;792x259&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/1.jpg&#34;
			width=&#34;792&#34;
			height=&#34;259&#34;
			srcset=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/1_hu7de10a5ba4c09963d2757d75c9451326_29719_480x0_resize_q75_box.jpg 480w, https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/1_hu7de10a5ba4c09963d2757d75c9451326_29719_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;多路复用&#34;&gt;多路复用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;基于二进制分帧，在共享的Tcp连接的基础上同时发送请求和响应。http的消息被分解成独立的帧层，交错发出
通过流标识符和首部将他们重新组装起来，避免了队头阻塞和提高了传输的性能
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 371; 
			flex-basis: 890px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/2.jpg&#34; data-size=&#34;720x194&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/2.jpg&#34;
			width=&#34;720&#34;
			height=&#34;194&#34;
			srcset=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/2_hu26c551d112db882bece071ac063555bc_17388_480x0_resize_q75_box.jpg 480w, https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/2_hu26c551d112db882bece071ac063555bc_17388_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;二进制分帧&#34;&gt;二进制分帧&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;经http报文格式转换成二进制格式，全部的io串。将原来的header的报文分成二进制帧沉在的头部字段，
body被拆分成二进制帧存放在请求体数据段。服务器接收的不是http报文，而是二进制帧。&lt;/li&gt;
&lt;li&gt;帧(frame)包含部分：类型Type, 长度Length, 标记Flags, 流标识Stream和frame payload有效载荷。&lt;/li&gt;
&lt;li&gt;消息(message)：一个完整的请求或者响应，比如请求、响应等，由一个或多个 Frame 组成。&lt;/li&gt;
&lt;li&gt;流是连接中的一个虚拟信道，可以承载双向消息传输。每个流有唯一整数标识符。为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID。&lt;/li&gt;
&lt;li&gt;流标识是描述二进制frame的格式，使得每个frame能够基于http2发送，与流标识联系的是一个流，每个流是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的http2连接中。一个http2连接上可包含多个并发打开的流，这个并发流的数量能够由客户端设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 190; 
			flex-basis: 456px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/3.jpg&#34; data-size=&#34;624x328&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/3.jpg&#34;
			width=&#34;624&#34;
			height=&#34;328&#34;
			srcset=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/3_hua465648554d7afaa965ef67ab7bc541e_26894_480x0_resize_q75_box.jpg 480w, https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/3_hua465648554d7afaa965ef67ab7bc541e_26894_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;二进制分帧的特性&#34;&gt;二进制分帧的特性&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;并发性：同时可发多个帧&lt;/li&gt;
&lt;li&gt;自增性：流的id不可重用，按顺序递增，到阈值后置零&lt;/li&gt;
&lt;li&gt;双向性：客户端与服务端都可到流，互不干扰，都可收发&lt;/li&gt;
&lt;li&gt;可设优先级：设置帧的优先级，服务器优先处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;服务器推送&#34;&gt;服务器推送&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;服务器不在是完全被动的接收和响应请求，也能创建新的资源(流)发送给客户端。&lt;/li&gt;
&lt;li&gt;服务器可以对一个客户端请求发送多个响应，服务器向客户端推送资源无需客户端明确地请求。
并且，服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。&lt;/li&gt;
&lt;li&gt;当服务端需要主动推送某个资源时，便会发送一个 Frame Type 为 PUSH_PROMISE 的 Frame，里面带了 PUSH 需要新建的 Stream ID。
意思是告诉客户端：接下来我要用这个 ID 向你发送东西，客户端准备好接着。客户端解析 Frame 时，发现它是一个 PUSH_PROMISE 类型，
便会准备接收服务端要推送的流。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 235; 
			flex-basis: 564px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/4jpg.jpg&#34; data-size=&#34;494x210&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/4jpg.jpg&#34;
			width=&#34;494&#34;
			height=&#34;210&#34;
			srcset=&#34;https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/4jpg_huc6e2de94992377f280c901e7e640fbf3_19870_480x0_resize_q75_box.jpg 480w, https://zcj-git520.github.io/p/http%E5%8D%8F%E8%AE%AE%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90/4jpg_huc6e2de94992377f280c901e7e640fbf3_19870_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;请求优先级&#34;&gt;请求优先级&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;通过设置帧的优先级，优化帧的传输顺序&lt;/li&gt;
&lt;li&gt;把http消息分为很多独立帧之后，就可以通过优化这些帧的交错和传输顺序进一步优化性能。每个流都可以带有一个31比特的优先值：0 表示最高优先级；2的31次方-1 表示最低优先级。&lt;/li&gt;
&lt;li&gt;服务器可以根据流的优先级，控制资源分配（CPU、内存、带宽），而在响应数据准备好之后，优先将最高优先级的帧发送给客户端。高优先级的流都应该优先发送，但又不会绝对的。绝对地准守，可能又会引入首队阻塞的问题：高优先级的请求慢导致阻塞其他资源交付。
4.分配处理资源和客户端与服务器间的带宽，不同优先级的混合也是必须的。客户端会指定哪个流是最重要的，有一些依赖参数，这样一个流可以依赖另外一个流。优先级别可以在运行时动态改变，当用户滚动页面时，可以告诉浏览器哪个图像是最重要的，你也可以在一组流中进行优先筛选，能够突然抓住重点流。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;优先级等级&#34;&gt;优先级等级：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;优先级最高：主要的html&lt;/li&gt;
&lt;li&gt;优先级高：CSS文件&lt;/li&gt;
&lt;li&gt;优先级中：js文件&lt;/li&gt;
&lt;li&gt;优先级低：图片&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
</description>
        </item>
        <item>
        <title>PRC</title>
        <link>https://zcj-git520.github.io/p/prc/</link>
        <pubDate>Mon, 15 Nov 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/prc/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/prc/1.jpg" alt="Featured image of post PRC" /&gt;&lt;h2 id=&#34;rpc&#34;&gt;RPC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;RPC(Remote Procedure Call Protocol)——远程过程调用协议，它是一种通过网络从远程计算机程序上请求服务，
而不需要了解底层网络技术的协议。RPC协议假定某些传输协议的存在，如TCP/IP或UDP，为通信程序之间携带信息数据。
RPC将原来的本地调用转变为调用远端的服务器上的方法，给系统的处理能力和吞吐量带来了近似于无限制提升的可能。
在OSI网络通信模型中，RPC跨域了传输层和应用层。RPC使得开发包括网络分布式多程序在内的应用程序更加容易&lt;/li&gt;
&lt;li&gt;RPC采用客户机/服务器(client-server)模式,也是一种请求/响应(request-response)模式，可以通过TCP/UDP以及HTTP
协议进行传输&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rpc-架构&#34;&gt;RPC 架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CAll ID 映射：客户端通过ID传输给服务器，服务器通过ID调用相应的函数返回&lt;/li&gt;
&lt;li&gt;序列化与烦序列化：客户端与服务器通过序列化与反序列化进行传参&lt;/li&gt;
&lt;li&gt;一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub可以理解为存根。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;客户端(Client)，服务的调用方。&lt;/li&gt;
&lt;li&gt;客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。&lt;/li&gt;
&lt;li&gt;服务端(Server)，真正的服务提供者。&lt;/li&gt;
&lt;li&gt;服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;rpc调用过程&#34;&gt;RPC调用过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;客户端（client）以本地调用方式（即以接口的方式）调用服务；&lt;/li&gt;
&lt;li&gt;客户端存根（client stub）接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体（将消息体对象序列化为二进制）；&lt;/li&gt;
&lt;li&gt;客户端通过sockets将消息发送到服务端；&lt;/li&gt;
&lt;li&gt;服务端存根( server stub）收到消息后进行解码（将消息对象反序列化）；&lt;/li&gt;
&lt;li&gt;服务端存根( server stub）根据解码结果调用本地的服务；&lt;/li&gt;
&lt;li&gt;本地服务执行并将结果返回给服务端存根( server stub）；&lt;/li&gt;
&lt;li&gt;服务端存根( server stub）将返回结果打包成消息（将结果消息对象序列化）；&lt;/li&gt;
&lt;li&gt;服务端（server）通过sockets将消息发送到客户端；&lt;/li&gt;
&lt;li&gt;客户端存根（client stub）接收到结果消息，并进行解码（将结果消息发序列化）；&lt;/li&gt;
&lt;li&gt;客户端（client）得到最终结果。&lt;br&gt;
RPC的目标是要把2、3、4、7、8、9这些步骤都封装起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;注意：无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二进制流，而数据的接收方则需要把二进制流再恢复为对象。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 159; 
			flex-basis: 382px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/prc/1.jpg&#34; data-size=&#34;500x314&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/prc/1.jpg&#34;
			width=&#34;500&#34;
			height=&#34;314&#34;
			srcset=&#34;https://zcj-git520.github.io/p/prc/1_hu92b5144e2fe44c426742bd76f38787bf_37611_480x0_resize_q75_box.jpg 480w, https://zcj-git520.github.io/p/prc/1_hu92b5144e2fe44c426742bd76f38787bf_37611_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gprc&#34;&gt;gPRC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;gRPC 是一种现代开源高性能远程过程调用 (RPC) 框架，可以在任何环境中运行。它可以通过对负载平衡、跟踪、健康检查和身份验证的可插拔支持，有效地连接数据中心内和数据中心之间的服务。它还适用于分布式计算的最后一英里，将设备、移动应用程序和浏览器连接到后端服务。&lt;/li&gt;
&lt;li&gt;gRPC 是基于HTTP2.0(多路复用,消除了线头阻塞)标准协议色设计的基于ProtoBuf序列化的高性能框架。
&lt;a class=&#34;link&#34; href=&#34;http://doc.oschina.net/grpc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;《gRPC 官方文档中文版》&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;protocol-buffers&#34;&gt;Protocol Buffers&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据序列化，很适合做数据存储或 RPC 数据交换格式。它可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式&lt;/li&gt;
&lt;li&gt;序列化：将数据结构或对象转换成能被传输或者存储（如二进制格式）的过程。&lt;/li&gt;
&lt;li&gt;反序列化：将在序列化过程中所生成的(格式)转换成数据结构或者对象的过程。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/94983974&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RPC原理解析&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>RestfulAPI</title>
        <link>https://zcj-git520.github.io/p/restfulapi/</link>
        <pubDate>Wed, 10 Nov 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/restfulapi/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/restfulapi/1.jpg" alt="Featured image of post RestfulAPI" /&gt;&lt;h2 id=&#34;restful-api&#34;&gt;Restful API&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;rest是Representational state Transfer 的缩写（表述性转态传递）&lt;/li&gt;
&lt;li&gt;api是应用程序接口&lt;/li&gt;
&lt;li&gt;Restful API是一种软件结构风格，设计风格，让软件更加清晰、简洁、易维护。是一种流行的软件API
设计风格&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rest的指导风格&#34;&gt;Rest的指导风格&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;客户端-服务器：通过将用户接口问题与数据存储问题分开，简化服务器组件来提高跨平台放入用户接口的
可移植性性并提高可伸缩性&lt;/li&gt;
&lt;li&gt;无转态：从客户端到服务器的每个请求都必须包含理解请求所需的所有信息，并且不能利用服务器上任何存储的上下文。因此，会话状态完全保留在客户端上。&lt;/li&gt;
&lt;li&gt;可缓存：缓存约束要求将对请求的响应中的数据隐式或显式标记为可缓存或不可缓存。如果响应是可缓存的，则客户端缓存有权重用该响应数据以用于以后的等效请求。&lt;/li&gt;
&lt;li&gt;统一接口：通过将通用性的软件工程原理应用于组件接口，简化了整个系统架构，提高了交互的可见性。为了获得统一的接口，需要多个架构约束来指导组件的行为。REST由四个接口约束定义：资源识别; 通过陈述来处理资源; 自我描述性的信息; 并且，超媒体作为应用程序状态的引擎&lt;/li&gt;
&lt;li&gt;分层系统：分层系统风格允许通过约束组件行为来使体系结构由分层层组成，这样每个组件都不能“看到”超出与它们交互的直接层。&lt;/li&gt;
&lt;li&gt;按需编码（可选）： REST允许通过以小程序或脚本的形式下载和执行代码来扩展客户端功能。这通过减少预先实现所需的功能数量来简化客户端&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;restful-架构&#34;&gt;RestFul 架构&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;资源：网络的实体或者是具体的信息，使用URI(统一资源定位符)，URI是每一个资源的地址或者独一无二的是识别符&lt;/li&gt;
&lt;li&gt;表现层： 对资源的外在表现，如：json、xml、txt、二进制等&lt;/li&gt;
&lt;li&gt;转态转化：互联网是一种无转态的协议，所有的状态都是保存在服务器上，客户端通过
HTTP的操作方式(GET,POST,PUT,DELETE)等改变服务器的“状态变化”
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 186; 
			flex-basis: 447px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/restfulapi/1.jpg&#34; data-size=&#34;412x221&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/restfulapi/1.jpg&#34;
			width=&#34;412&#34;
			height=&#34;221&#34;
			srcset=&#34;https://zcj-git520.github.io/p/restfulapi/1_hu5d30570469f48ece7400dce081384b39_15097_480x0_resize_q75_box.jpg 480w, https://zcj-git520.github.io/p/restfulapi/1_hu5d30570469f48ece7400dce081384b39_15097_1024x0_resize_q75_box.jpg 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;restful-api接口规范&#34;&gt;RESTful API接口规范&lt;/h2&gt;
&lt;h3 id=&#34;接口风格&#34;&gt;接口风格&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;路径和变量均采用小驼峰式，例如deviceId&lt;/li&gt;
&lt;li&gt;使用HTTP动词作为action操作URL资源，动词一律大写。
&lt;ul&gt;
&lt;li&gt;GET：读取\查询（Read）&lt;/li&gt;
&lt;li&gt;POST：新建（Create）&lt;/li&gt;
&lt;li&gt;PUT：更新（Update）&lt;/li&gt;
&lt;li&gt;PATCH：更新（Update），通常是部分更新&lt;/li&gt;
&lt;li&gt;DELETE：删除（Delete）&lt;/li&gt;
&lt;li&gt;HEAD：获取资源的元数据。&lt;/li&gt;
&lt;li&gt;OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。&lt;/li&gt;
&lt;li&gt;5种请求动作中，GET、PUT、PATCH、DELETE均是幂等的；只有POST是非幂等的。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。&lt;strong&gt;是非幂等是判断接口使用POST还是PUT的决定条件&lt;/strong&gt;。幂等的理解见本文附录。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;参数：
&lt;ul&gt;
&lt;li&gt;PATH（路径）：
&lt;ul&gt;
&lt;li&gt;版本号放入PATH，且在最前
&lt;ul&gt;
&lt;li&gt;尽量使用名词，不使用动词，把每个URL看成一个资源，名称都用复数&lt;/li&gt;
&lt;li&gt;微服务名称不放入PATH中&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Query参数：主要用在GET查询中，简单的PUT动作，也用Query参数&lt;/li&gt;
&lt;li&gt;Headers参数：公共参数通过header传递，content-type、authorization认证必填，其他统一按调用链规范、速率限制规范填写。content-type应该固定为&lt;code&gt;application/json&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;Body：
&lt;ul&gt;
&lt;li&gt;统一使用json格式，所有返回都是json格式
&lt;ul&gt;
&lt;li&gt;POST所有参数通过JSON传递&lt;/li&gt;
&lt;li&gt;GET请求不允许有body， 所有参数通过拼接在URL之后传递，&lt;strong&gt;所有的请求参数都要进行遵循&lt;a class=&#34;link&#34; href=&#34;https://link.zhihu.com/?target=https%3A//tools.ietf.org/html/rfc3986&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RFC 3986&lt;/a&gt;的URL Encode&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;DELETE删除单个资源时，资源标识通过path传递，批量删除时，通过在body中传递JSON。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回结果
&lt;ul&gt;
&lt;li&gt;状态码：HTTP状态码标准用法，见后状态码规范&lt;/li&gt;
&lt;li&gt;Body返回，只提供json返回格式&lt;/li&gt;
&lt;li&gt;GET：返回资源对象，完整对象或通过Query参数可过滤&lt;/li&gt;
&lt;li&gt;POST：返回新生成的资源对象，可能是ID或完整的资源对象&lt;/li&gt;
&lt;li&gt;PUT：返回完整的资源对象&lt;/li&gt;
&lt;li&gt;DELETE：返回一个空文档&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;过滤信息：查询及查询结果使用
&lt;ul&gt;
&lt;li&gt;pageNo：分页查询标识第几页&lt;/li&gt;
&lt;li&gt;pageSize：分页查询标识每页多少条数据&lt;/li&gt;
&lt;li&gt;begin：录像/截图开始时间，Unix时间戳，单位秒&lt;/li&gt;
&lt;li&gt;end：录像/截图结束时间，Unix时间戳，单位秒&lt;/li&gt;
&lt;li&gt;orderby：排序规则，desc或asc&lt;/li&gt;
&lt;li&gt;q：搜索关键字（uri encode之后的）&lt;/li&gt;
&lt;li&gt;totalCount：总记录数，分页查询，返回json携带&lt;/li&gt;
&lt;li&gt;totalPages：总页数，分页查询，返回json携带，等于page时，表示当前是最后一页&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;微服务内部使用http协议，对外使用https协议&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;详细设计要求&#34;&gt;详细设计要求&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;输入参数要精简有效
&lt;ul&gt;
&lt;li&gt;不能把内部对象作为接口参数，通过DTO进行转换；&lt;/li&gt;
&lt;li&gt;required的字段尽可能少&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;CRUD的U(POST)要通过业务分析（领域建模）具体化操作，不要提供灵活但是支持不全面的接口&lt;/li&gt;
&lt;li&gt;查询尽可能提供丰富的查询条件，可以返回尽可能详细的信息&lt;/li&gt;
&lt;li&gt;同类资源尽可能统一接口&lt;/li&gt;
&lt;li&gt;避免多级 URL，比如获取某个作者的某一类文章：
&lt;code&gt;GET /authors/12/categories/2&lt;/code&gt;
这种 URL 不利于扩展，语义也不明确，往往要想一会，才能明白含义。
更好的做法是，除了第一级，其他级别都用查询字符串表达。
&lt;code&gt;GET /authors/12?categories=2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如何设计批量处理
把URL设计为&lt;code&gt;PATCH /authors/batch&lt;/code&gt;，也就是具体的id传入batch表示批量，参数通过body传递，例如如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
   {&amp;quot;method&amp;quot;:&amp;quot;DELETE&amp;quot;,&amp;quot;id&amp;quot;:&amp;quot;12&amp;quot;,&amp;quot;value&amp;quot;:&amp;quot;&amp;quot;}
   {&amp;quot;method&amp;quot;:&amp;quot;PUT&amp;quot;,&amp;quot;id&amp;quot;:&amp;quot;23&amp;quot;,&amp;quot;value&amp;quot;:{&amp;quot;name&amp;quot;:&amp;quot;michael&amp;quot;,&amp;quot;group&amp;quot;:&amp;quot;fisrt&amp;quot;,...}}
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在method中传递HTTP动词，主要是PUT\DELETE，GET通过查询条件本身就支持批量，POST是创建，几乎不需批量创建，而PUT\DELETE都是对某个id操作，同时修改或删除多个id就是批量操作；在id中明确具体的id，value则传递与操作单个id一致的数据。批量操作的返回body与传入body保持一致，只是value可能是error数据也可能是PUT的结果数据。通过这种设计，在实现时，batch操作可以复用单个id操作的处理过程。&lt;/p&gt;
&lt;h3 id=&#34;状态码规范&#34;&gt;状态码规范&lt;/h3&gt;
&lt;h4 id=&#34;正确&#34;&gt;正确&lt;/h4&gt;
&lt;p&gt;接口正常访问情况下，服务器返回2××的HTTP状态码。
&lt;code&gt;200 OK&lt;/code&gt; ：表示已在响应中发出、资源更改成功（GET、PUT）
&lt;code&gt;201 Created&lt;/code&gt;：表示新资源被创建（POST）
&lt;code&gt;204 No Content&lt;/code&gt; ：资源被删除（DELETE）&lt;/p&gt;
&lt;h4 id=&#34;错误&#34;&gt;错误&lt;/h4&gt;
&lt;p&gt;当用户访问接口出错时，服务器会返回给一个合适的4××或者5××的HTTP状态码；以及一个application/json格式的消息体，消息体中包含错误码code和错误说明message，json格式如下：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;{
    &amp;quot;code&amp;quot;:&amp;quot;内部错误代码可以是数字或Exeption字符串，例如20003, OAuthException&amp;quot;
    &amp;quot;message&amp;quot;:&amp;quot;格式化的错误信息，英文，此message是对code的更细的错误描述，可以把一些状态变量格式化嵌入。&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;补充说明：以上错误返回全英文，若Web提示，由web客户端建立code的多语言字符串表，把错误码转化为对于的多语言字符串，展示多语言提示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发生错误时，绝对不要返回 200 状态码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;4××错误( &lt;code&gt;400=&amp;lt;status code&amp;lt;500&lt;/code&gt; )为客户端的请求错误，需要根据具体的code做相应的提示和逻辑处理，message仅供开发时参考，不建议作为用户提示。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;5××错误( &lt;code&gt;500=&amp;lt;status code&lt;/code&gt; )为服务器或程序出错，客户端只需要提示“服务异常，请稍后重试”即可，该类错误不在每个接口中列出。&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;400 Bad Request&lt;/code&gt; ：服务器不理解客户端的请求，未做任何处理。&lt;br&gt;
&lt;code&gt;401 Unauthorized&lt;/code&gt; ：用户未提供身份验证凭据，或者没有通过身份验证。&lt;br&gt;
&lt;code&gt;403 Forbidden&lt;/code&gt; ：用户通过了身份验证，但是不具有访问资源所需的权限。&lt;br&gt;
&lt;code&gt;404 Not Found&lt;/code&gt; ：所请求的资源不存在，或不可用。&lt;br&gt;
&lt;code&gt;405 Method Not Allowed&lt;/code&gt; ：用户已经通过身份验证，但是所用的 HTTP 方法不在他的权限之内。&lt;br&gt;
&lt;code&gt;410 Gone&lt;/code&gt; ：所请求的资源已从这个地址转移，不再可用。&lt;br&gt;
&lt;code&gt;415 Unsupported Media Type&lt;/code&gt; ：客户端要求的返回格式不支持。比如，API 只能返回 JSON 格式，但是客户端要求返回 XML 格式。&lt;br&gt;
&lt;code&gt;422 Unprocessable Entity&lt;/code&gt;  ：客户端上传的附件无法处理，导致请求失败。&lt;br&gt;
&lt;code&gt;429 Too Many Requests&lt;/code&gt; ：客户端的请求次数超过限额。&lt;br&gt;
&lt;code&gt;500 Internal Server Error&lt;/code&gt; ：客户端请求有效，服务器处理时发生了意外。&lt;br&gt;
&lt;code&gt;503 Service Unavailable&lt;/code&gt; ：服务器无法处理请求，一般用于网站或设备维护状态。&lt;/p&gt;
&lt;h3 id=&#34;附录幂等性&#34;&gt;附录：幂等性&lt;/h3&gt;
&lt;p&gt;幂等性：幂等性是分布式环境下常见的问题；幂等性指的是多次操作，结果是一致的。（多次操作数据库数据是一致的。）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GET方法用于获取资源，不应有副作用，所以是幂等的。&lt;/li&gt;
&lt;li&gt;DELETE方法用于删除资源，有副作用，但它应该满足幂等性。&lt;/li&gt;
&lt;li&gt;POST所对应的URI并非创建的资源本身，而是资源的接收者。比如： POST &lt;a class=&#34;link&#34; href=&#34;http://www.forum.com/articles&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.forum.com/articles&lt;/a&gt; 的语义是在 &lt;a class=&#34;link&#34; href=&#34;http://www.forum.com/articles&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.forum.com/articles&lt;/a&gt; 下创建一篇帖子，HTTP响应中应包含帖子的创建状态以及帖子的URI。两次相同的POST请求会在服务器端创建两份资源，它们具有不同的URI；所以，POST方法不具备幂等性。&lt;/li&gt;
&lt;li&gt;PUT所对应的URI是要创建或更新的资源本身。比如： PUT &lt;a class=&#34;link&#34; href=&#34;http://www.forum/articles/4231&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.forum/articles/4231&lt;/a&gt; 的语义是创建或更新ID为4231的帖子。对同一URI进行多次PUT的副作用和一次PUT是相同的；因此，PUT方法具有幂等性。&lt;/li&gt;
&lt;li&gt;如何把非幂等的POST操作设计为幂等的，可以参加下面的帖子的示例：
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/weidagang2046/archive/2011/06/04/idempotence.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Docker知识总览</title>
        <link>https://zcj-git520.github.io/p/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88/</link>
        <pubDate>Fri, 05 Nov 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/docker%E7%9F%A5%E8%AF%86%E6%80%BB%E8%A7%88/1.jpg" alt="Featured image of post Docker知识总览" /&gt;&lt;h2 id=&#34;概念知识&#34;&gt;概念知识&lt;/h2&gt;
&lt;h3 id=&#34;docker镜像&#34;&gt;Docker镜像&lt;/h3&gt;
&lt;p&gt;Docker镜像是由文件和元数据组成的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件：语言环境、库、执行文件
&lt;ul&gt;
&lt;li&gt;由于 Docker 使用 Union FS，相同的层只需要保存一份即可，因此实际镜像硬盘占用空间很可能要比这个列表镜像大小的总和要小的多。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;元数据：环境变量、端口映射、卷等&lt;/li&gt;
&lt;li&gt;镜像信息：
&lt;ul&gt;
&lt;li&gt;RESPOSITORY：仓库名&lt;/li&gt;
&lt;li&gt;TAG：标签&lt;/li&gt;
&lt;li&gt;IMAGE ID：镜像ID&lt;/li&gt;
&lt;li&gt;CREATED：创建时间&lt;/li&gt;
&lt;li&gt;SIZE：所占用的空间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;虚悬镜像(dangling image)
&lt;ul&gt;
&lt;li&gt;RESPOSITROY及TAG都为&lt;!-- raw HTML omitted --&gt;&lt;/li&gt;
&lt;li&gt;使用docker image prune 可以删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;容器&#34;&gt;容器&lt;/h3&gt;
&lt;p&gt;容器是从镜像中创建，继承了他们的文件系统，并使用他们的元数据来确定其启动配置。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动时，运行一个进程，不过可派生其他进程。&lt;/li&gt;
&lt;li&gt;文件的变更通过写时复制存储在容器中，基础镜像不会受影响。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据卷&#34;&gt;数据卷&lt;/h3&gt;
&lt;p&gt;数据卷 是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据卷 可以在容器之间共享和重用&lt;/li&gt;
&lt;li&gt;对 数据卷 的修改会立马生效&lt;/li&gt;
&lt;li&gt;对 数据卷 的更新，不会影响镜像&lt;/li&gt;
&lt;li&gt;数据卷 默认会一直存在，即使容器被删除&lt;/li&gt;
&lt;li&gt;注意：数据卷 的使用，类似于 Linux 下对目录或文件进行 mount，镜像中的被指定为挂载点的目录中的文件会复制到数据卷中（仅数据卷为空时会复制）。&lt;/li&gt;
&lt;li&gt;数据卷 是被设计用来持久化数据的，它的生命周期独立于容器，Docker 不会在容器被删除后自动删除 数据卷&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;docker网络&#34;&gt;Docker网络&lt;/h3&gt;
&lt;p&gt;当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。&lt;/p&gt;
&lt;p&gt;同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。&lt;/p&gt;
&lt;p&gt;当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。
&lt;figure 
	&gt;
	&lt;a href=&#34;https://gblobscdn.gitbook.com/assets%2F-M5xTVjmK7ax94c8ZQcm%2F-M5xT_hHX2g5ldlyp9nm%2F-M5xTloJ8V-9G0aacJWQ%2Fnetwork.png?alt=media&#34; &gt;
		&lt;img src=&#34;https://gblobscdn.gitbook.com/assets%2F-M5xTVjmK7ax94c8ZQcm%2F-M5xT_hHX2g5ldlyp9nm%2F-M5xTloJ8V-9G0aacJWQ%2Fnetwork.png?alt=media&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;image&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;image&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他知识&#34;&gt;其他知识&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Docker 不是虚拟机，容器中的应用都应该以前台执行，而不是像虚拟机、物理机里面那样，用 systemd 去启动后台服务，容器内没有后台服务的概念。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;使用镜像的命令工具&#34;&gt;使用镜像的命令工具&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;docker pull [Registry地址[:端口]/] 仓库名[:标签]&lt;/td&gt;
&lt;td&gt;Registry 地址拉取镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker run 仓库名:标签 [命令]&lt;/td&gt;
&lt;td&gt;以容器形式运行一个Docker镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker run -it 仓库名:标签 [命令]&lt;/td&gt;
&lt;td&gt;-it表示进入交互终端&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker run &amp;ndash;rm 仓库名:标签 [命令]&lt;/td&gt;
&lt;td&gt;&amp;ndash;rm退出后删除，否则docker ps -a看得到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image ls&lt;/td&gt;
&lt;td&gt;列出已经下载下来的镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker images&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image ls [仓库名][:标签]&lt;/td&gt;
&lt;td&gt;列出指定仓库名或附带标签的镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image ls -q&lt;/td&gt;
&lt;td&gt;仅列出表格的IMAGE ID列表&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image ls -f label=com.example.version=0.1&lt;/td&gt;
&lt;td&gt;-f 增加过滤器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image ls &amp;ndash;format &amp;ldquo;{{.ID}}: {{.Repository}}&amp;rdquo;&lt;/td&gt;
&lt;td&gt;利用Go的模板语法列出信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image ls &amp;ndash;digests&lt;/td&gt;
&lt;td&gt;列出镜像，增加DIGEST摘要显示（确保唯一）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image rm [选项] &amp;lt;镜像1&amp;gt; [&amp;lt;镜像2&amp;gt; &amp;hellip;]&lt;/td&gt;
&lt;td&gt;删除镜像，镜像可以是ID、仓库名:标签，摘要&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image rm $(docker images -q redis)&lt;/td&gt;
&lt;td&gt;删除所有redis名称的镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image rm $(docker images -q -f before=镜像)&lt;/td&gt;
&lt;td&gt;删除某个镜像前面的镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run &amp;ndash;name webserver -d -p 80:80 nginx&lt;/td&gt;
&lt;td&gt;指定容器名称为webserver，且配置端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker exec -it webserver bash&lt;/td&gt;
&lt;td&gt;进入容器，打开bash控制台&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker commit [选项] &amp;lt;容器ID或容器名&amp;gt; [&amp;lt;仓库名&amp;gt;[:&amp;lt;标签&amp;gt;]]&lt;/td&gt;
&lt;td&gt;保存镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Docker tag&lt;/td&gt;
&lt;td&gt;给一个Docker镜像打标签&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker system df&lt;/td&gt;
&lt;td&gt;便捷的查看镜像、容器、数据卷所占用的空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker image prune&lt;/td&gt;
&lt;td&gt;删除虚悬镜像(dangling image)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker build [选项] &amp;lt;上下文路径/URL/-&amp;gt;&lt;/td&gt;
&lt;td&gt;构建镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;$ docker commit \
    --author &amp;quot;Tao Wang &amp;lt;twang2218@gmail.com&amp;gt;&amp;quot; \
    --message &amp;quot;修改了默认网页&amp;quot; \
    webserver \
    nginx:v2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用dockerfile定制镜像&#34;&gt;使用Dockerfile定制镜像&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;指令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;FROM &amp;lt;基础镜像&amp;gt;&lt;/td&gt;
&lt;td&gt;基础镜像&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;FROM scratch&lt;/td&gt;
&lt;td&gt;不以任何镜像为基础，Go语言开发的应用很多会使用这种方式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUN shell格式命令&lt;/td&gt;
&lt;td&gt;shell命令追加层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;RUN [&amp;ldquo;可执行文件&amp;rdquo;, &amp;ldquo;参数1&amp;rdquo;, &amp;ldquo;参数2&amp;rdquo;]&lt;/td&gt;
&lt;td&gt;exec格式追加层&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COPY ./package.json /app/&lt;/td&gt;
&lt;td&gt;其中.表示上下文目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker build -t nginx:v3 .&lt;/td&gt;
&lt;td&gt;其中.就是传入的上下文目录，一般及时Dockerfile文件所在目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;COPY [&amp;ndash;chown=&lt;!-- raw HTML omitted --&gt;:&lt;!-- raw HTML omitted --&gt;] &amp;lt;源路径&amp;gt;&amp;hellip; &amp;lt;目标路径&amp;gt;&lt;/td&gt;
&lt;td&gt;复制上下文目录中的文件/目录到镜像中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WORKDIR &amp;lt;绝对路径&amp;gt;&lt;/td&gt;
&lt;td&gt;指定某个绝对路径作为后续的相对路径&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ADD [&amp;ndash;chown=&lt;!-- raw HTML omitted --&gt;:&lt;!-- raw HTML omitted --&gt;] &amp;lt;源路径&amp;gt;&amp;hellip; &amp;lt;目标路径&amp;gt;&lt;/td&gt;
&lt;td&gt;仅源自动解压缩时使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CMD &amp;lt;shell命令&amp;gt;&lt;/td&gt;
&lt;td&gt;容器主进程的启动命令，例如ubuntu镜像默认的CMD是/bin/bash&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CMD [&amp;ldquo;可执行文件&amp;rdquo;, &amp;ldquo;参数1&amp;rdquo;, &amp;ldquo;参数2&amp;rdquo;&amp;hellip;]&lt;/td&gt;
&lt;td&gt;exec 格式容器主进程的启动命令，推荐使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ENTRYPOINT [&amp;ldquo;可执行文件&amp;rdquo;, &amp;ldquo;参数1&amp;rdquo;, &amp;ldquo;参数2&amp;rdquo;&amp;hellip;]&lt;/td&gt;
&lt;td&gt;入口点，镜像变成命令一样使用，或者运行前的准备工作&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ENV &lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt;&lt;/td&gt;
&lt;td&gt;ENV 设置环境变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ENV &lt;!-- raw HTML omitted --&gt;=&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt;=&lt;!-- raw HTML omitted --&gt;&amp;hellip;&lt;/td&gt;
&lt;td&gt;ENV 设置环境变量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ARG &amp;lt;参数名&amp;gt;[=&amp;lt;默认值&amp;gt;]&lt;/td&gt;
&lt;td&gt;docker build中用&amp;ndash;build-arg &amp;lt;参数名&amp;gt;=&amp;lt;值&amp;gt;来覆盖，生效范围为下一个指令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VOLUME [&amp;quot;&amp;lt;路径1&amp;gt;&amp;quot;, &amp;ldquo;&amp;lt;路径2&amp;gt;&amp;rdquo;&amp;hellip;]&lt;/td&gt;
&lt;td&gt;VOLUME 定义匿名卷，这样运行时，不会向容器存储层写入数据，运行命令-v可以覆盖位置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;VOLUME &amp;lt;路径&amp;gt;&lt;/td&gt;
&lt;td&gt;VOLUME 定义匿名卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;EXPOSE &amp;lt;端口1&amp;gt; [&amp;lt;端口2&amp;gt;&amp;hellip;]&lt;/td&gt;
&lt;td&gt;暴露端口，容器运行时提供服务的端口，这只是一个声明&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;WORKDIR &amp;lt;工作目录路径&amp;gt;&lt;/td&gt;
&lt;td&gt;指定工作目录（或者称为当前目录），如该目录不存在，WORKDIR 会帮你建立目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;USER &amp;lt;用户名&amp;gt;[:&amp;lt;用户组&amp;gt;]&lt;/td&gt;
&lt;td&gt;指定当前用户，这个用户必须是事先建立好的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEALTHCHECK [选项] CMD &amp;lt;命令&amp;gt;&lt;/td&gt;
&lt;td&gt;设置检查容器健康状况的命令&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;HEALTHCHECK NONE&lt;/td&gt;
&lt;td&gt;如果基础镜像有健康检查指令，使用这行可以屏蔽掉其健康检查指令\&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ONBUILD &amp;lt;其它指令&amp;gt;&lt;/td&gt;
&lt;td&gt;后面指令，以当前镜像为基础镜像构建下一级镜像时被执行。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LABEL &lt;!-- raw HTML omitted --&gt;=&lt;!-- raw HTML omitted --&gt; &lt;!-- raw HTML omitted --&gt;=&lt;!-- raw HTML omitted --&gt; &amp;hellip;&lt;/td&gt;
&lt;td&gt;镜像以键值对的形式添加一些元数据（metadata）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SHELL [&amp;ldquo;executable&amp;rdquo;, &amp;ldquo;parameters&amp;rdquo;]&lt;/td&gt;
&lt;td&gt;指定RUN ENTRYPOINT CMD 指令的 shell，Linux 中默认为 [&amp;quot;/bin/sh&amp;quot;, &amp;ldquo;-c&amp;rdquo;]&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;示例&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM FROM nginx
RUN echo &#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&#39; &amp;gt; /usr/share/nginx/html/index.html
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;docker build -t nginx:v3 .
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM debian:stretch

RUN apt-get update
RUN apt-get install -y gcc libc6-dev make wget
RUN wget -O redis.tar.gz &amp;quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&amp;quot;
RUN mkdir -p /usr/src/redis
RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1
RUN make -C /usr/src/redis
RUN make -C /usr/src/redis install
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM debian:stretch

RUN set -x; buildDeps=&#39;gcc libc6-dev make wget&#39; \
    &amp;amp;&amp;amp; apt-get update \
    &amp;amp;&amp;amp; apt-get install -y $buildDeps \
    &amp;amp;&amp;amp; wget -O redis.tar.gz &amp;quot;http://download.redis.io/releases/redis-5.0.3.tar.gz&amp;quot; \
    &amp;amp;&amp;amp; mkdir -p /usr/src/redis \
    &amp;amp;&amp;amp; tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \
    &amp;amp;&amp;amp; make -C /usr/src/redis \
    &amp;amp;&amp;amp; make -C /usr/src/redis install \
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/* \
    &amp;amp;&amp;amp; rm redis.tar.gz \
    &amp;amp;&amp;amp; rm -r /usr/src/redis \
    &amp;amp;&amp;amp; apt-get purge -y --auto-remove $buildDeps
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;COPY package.json /usr/src/app/
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;COPY hom* /mydir/
COPY hom?.txt /mydir/
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;COPY --chown=55:mygroup files* /mydir/
COPY --chown=bin files* /mydir/
COPY --chown=1 files* /mydir/
COPY --chown=10:11 files* /mydir/
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ADD --chown=55:mygroup files* /mydir/
ADD --chown=bin files* /mydir/
ADD --chown=1 files* /mydir/
ADD --chown=10:11 files* /mydir/
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM ubuntu:18.04
RUN apt-get update \
    &amp;amp;&amp;amp; apt-get install -y curl \
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ &amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;http://myip.ipip.net&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM ubuntu:18.04
RUN apt-get update \
    &amp;amp;&amp;amp; apt-get install -y curl \
    &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
ENTRYPOINT [ &amp;quot;curl&amp;quot;, &amp;quot;-s&amp;quot;, &amp;quot;http://myip.ipip.net&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ENV VERSION=1.0 DEBUG=on \
    NAME=&amp;quot;Happy Feet&amp;quot;
# 后面的指令中，可以通过$VERSION、$NAME来引用。列指令可以支持环境变量展开：
# ADD、COPY、ENV、EXPOSE、FROM、LABEL、USER、WORKDIR、VOLUME、STOPSIGNAL、ONBUILD、RUN。
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ARG DOCKER_USERNAME=library

FROM ${DOCKER_USERNAME}/alpine

# 在FROM 之后使用变量，必须在每个阶段分别指定
ARG DOCKER_USERNAME=library

RUN set -x ; echo ${DOCKER_USERNAME}

FROM ${DOCKER_USERNAME}/alpine

# 在FROM 之后使用变量，必须在每个阶段分别指定
ARG DOCKER_USERNAME=library

RUN set -x ; echo ${DOCKER_USERNAME}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;RUN groupadd -r redis &amp;amp;&amp;amp; useradd -r -g redis redis
USER redis
RUN [ &amp;quot;redis-server&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM nginx
RUN apt-get update &amp;amp;&amp;amp; apt-get install -y curl &amp;amp;&amp;amp; rm -rf /var/lib/apt/lists/*
HEALTHCHECK --interval=5s --timeout=3s \
  CMD curl -fs http://localhost/ || exit 1
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;dockerfile多阶段构建&#34;&gt;Dockerfile多阶段构建&lt;/h2&gt;
&lt;p&gt;在Docker 17.05之后，开始支持多阶段构建 (multistage builds)。解决了之前编写2个Dockerfile的方案，一个Dockerfile把项目及其依赖库编译测试打包，一个Dockerfile构建运行镜像包，把之前的构建结果拷贝到运行环境。&lt;/p&gt;
&lt;p&gt;我们可以使用 as 来为某一阶段命名，例如&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  FROM golang:alpine as builder
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一个为go程序，多阶段构建的例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM golang:alpine as builder

RUN apk --no-cache add git

WORKDIR /go/src/github.com/go/helloworld/

RUN go get -d -v github.com/go-sql-driver/mysql

COPY app.go .

RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest as prod

RUN apk --no-cache add ca-certificates

WORKDIR /root/

COPY --from=0 /go/src/github.com/go/helloworld/app .

CMD [&amp;quot;./app&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;例如当我们只想构建 builder 阶段的镜像时，增加 &amp;ndash;target=builder 参数即可&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  docker build --target builder -t username/imagename:tag .
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建时从其他镜像复制文件&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;  COPY --from=nginx:latest /etc/nginx/nginx.conf /nginx.conf
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;构建多种系统架构支持的-docker-镜像&#34;&gt;构建多种系统架构支持的 Docker 镜像&lt;/h2&gt;
&lt;p&gt;参见：https://yeasy.gitbook.io/docker_practice/image/manifest&lt;/p&gt;
&lt;h2 id=&#34;docker-镜像的导入和导出-docker-save-和-docker-load&#34;&gt;Docker 镜像的导入和导出 docker save 和 docker load&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令示例&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;docker save alpine -o filename&lt;/td&gt;
&lt;td&gt;把alphine镜像保存到filename文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker save alpine&lt;/td&gt;
&lt;td&gt;gzip &amp;gt; alpine-latest.tar.gz&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker load -i alpine-latest.tar.gz&lt;/td&gt;
&lt;td&gt;把alpine-latest.tar.gz镜像压缩文件导入到Docker系统中&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;操作镜像&#34;&gt;操作镜像&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令示例&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;docker run ubuntu:18.04 /bin/echo &amp;lsquo;Hello world&amp;rsquo;&lt;/td&gt;
&lt;td&gt;通过镜像，输出一个 “Hello World”，之后终止容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run -t -i ubuntu:18.04 /bin/bash&lt;/td&gt;
&lt;td&gt;启动一个 bash 终端，允许用户进行交互&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container start 历史容器&lt;/td&gt;
&lt;td&gt;将一个已经终止（exited）的容器启动运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run -d ubuntu:18.04 /bin/sh -c &amp;ldquo;&amp;hellip;脚本&amp;rdquo;&lt;/td&gt;
&lt;td&gt;-d容器输出到容器中，会返回一个唯一的id&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container ls&lt;/td&gt;
&lt;td&gt;可以看到容器id，运行中的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container ls -a&lt;/td&gt;
&lt;td&gt;查看所有容器，加了-a包括已经终止的容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container logs [container ID or NAMES]&lt;/td&gt;
&lt;td&gt;可以获取容器的输出信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container stop [container ID or NAMES]&lt;/td&gt;
&lt;td&gt;终止一个运行中的容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker exec -it 69d1 bash&lt;/td&gt;
&lt;td&gt;进入container ID以69d1开头的容器，打开bash，退出时，容器继续运行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker attach -it 69d1 bash&lt;/td&gt;
&lt;td&gt;进入container ID以69d1开头的容器，打开bash，退出时，容器停止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker export 7691a814370e &amp;gt; ubuntu.tar&lt;/td&gt;
&lt;td&gt;导出容器快照到本地文件&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cat ubuntu.tar&lt;/td&gt;
&lt;td&gt;docker import - test/ubuntu:v1.0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker import &lt;a class=&#34;link&#34; href=&#34;http://example.com/exampleimage.tgz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://example.com/exampleimage.tgz&lt;/a&gt; example/imagerepo&lt;/td&gt;
&lt;td&gt;通过指定 URL 或者某个目录来导入&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container rm trusting_newton&lt;/td&gt;
&lt;td&gt;删除一个处于终止状态的NAMES为trusting_newton的容器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container prune&lt;/td&gt;
&lt;td&gt;清理所有处于终止状态的容器&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;数据管理&#34;&gt;数据管理&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令示例&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;docker volume create my-vol&lt;/td&gt;
&lt;td&gt;创建一个名称为my-vol的数据卷，宿主机默认目录/var/lib/docker/volumes/my-vol/_data&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker volume ls&lt;/td&gt;
&lt;td&gt;查看所有的 数据卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker volume inspect my-vol&lt;/td&gt;
&lt;td&gt;在主机里查看指定 数据卷 的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run -v my-vol:/usr/share/nginx/html [其他省略]&lt;/td&gt;
&lt;td&gt;运行时加载my-vol数据卷 到容器的 /usr/share/nginx/html 目录&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run &amp;ndash;mount source=my-vol,target=/usr/share/nginx/html [其他省略]&lt;/td&gt;
&lt;td&gt;同上，另一种写法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker inspect web&lt;/td&gt;
&lt;td&gt;查看web容器时，可以在Mouts中查看数据卷的具体信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker volume rm my-vol&lt;/td&gt;
&lt;td&gt;删除数据卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker rm -v &amp;lt;容器ID或名称&amp;gt;&lt;/td&gt;
&lt;td&gt;删除容器时，同时移除数据卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker volume prune&lt;/td&gt;
&lt;td&gt;清理无主的数据卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker -v /src/webapp:/usr/share/nginx/html [其他省略]&lt;/td&gt;
&lt;td&gt;挂载一个本地主机的目录到容器中去&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker &amp;ndash;mount type=bind,source=/src/webapp,target=/usr/share/nginx/html [其他省略]&lt;/td&gt;
&lt;td&gt;同上，另一种严格写法&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v /src/webapp:/usr/share/nginx/html:ro [其他省略]&lt;/td&gt;
&lt;td&gt;ro表示只读，不加表示读写&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ndash;mount type=bind,source=/src/webapp,target=/usr/share/nginx/html,readonly [其他省略]&lt;/td&gt;
&lt;td&gt;表示只读&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-v $HOME/.bash_history:/root/.bash_history  [其他省略]&lt;/td&gt;
&lt;td&gt;挂载一个本地主机文件作为数据卷&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;ndash;mount type=bind,source=$HOME/.bash_history,target=/root/.bash_history [其他省略]&lt;/td&gt;
&lt;td&gt;同上&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;使用网络&#34;&gt;使用网络&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;命令&lt;/th&gt;
&lt;th&gt;功能&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;docker run -p [其他省略]&lt;/td&gt;
&lt;td&gt;-p随机映射端口到内部容器开放的网络端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker container ls&lt;/td&gt;
&lt;td&gt;列表中PORTS（如0.0.0.0:32768-&amp;gt;80/tcp）前一个表示宿主机端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker logs &amp;lt;容器ID&amp;gt;&lt;/td&gt;
&lt;td&gt;上面已描述，查看容器内的打印&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run -p ip:hostPort:containerPort [其他省略]&lt;/td&gt;
&lt;td&gt;指定映射端口，-p可以多次使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run -p ip::containerPort [其他省略]&lt;/td&gt;
&lt;td&gt;指定映射端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run -p hostPort:containerPort [其他省略]&lt;/td&gt;
&lt;td&gt;指定映射端口&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker port &amp;lt;容器ID&amp;gt; &amp;lt;容器端口&amp;gt;&lt;/td&gt;
&lt;td&gt;查看当前映射的端口配置，和绑定的地址&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker network create -d bridge my-net&lt;/td&gt;
&lt;td&gt;创建Docker网络，-d指定类型，有bridge\overlay，my-net是名称&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mount&lt;/td&gt;
&lt;td&gt;在容器中使用mount可查看挂载信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run [其他省略] cat /etc/resolv.conf&lt;/td&gt;
&lt;td&gt;启动时，查看DNS配置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run [其他省略] -h HOSTNAME&lt;/td&gt;
&lt;td&gt;设定容器的主机名，写到容器内的/etc/hostname 和/etc/hosts，外包看不到&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;docker run [其他省略] &amp;ndash;dns=IP_ADDRESS&lt;/td&gt;
&lt;td&gt;添加 DNS 服务器到容器的/etc/resolv.conf 中，等在宿主/etc/hosts 临时增加&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;dockerfile最佳实践指南&#34;&gt;Dockerfile最佳实践指南&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不常变动的部分写在dockerfile上面，以便后续变更时可以利用缓存，减少build时间。&lt;/li&gt;
&lt;li&gt;编写 .dockerignore 编译镜像时，docker 先要准备编译用的context，默认情况下会把 Dockerfile所在的所在文件夹下所有文件包含进去，如果不想把src目录包含进去来加快编译速度，可以添加.dockerignore，内容如下 src/&lt;/li&gt;
&lt;li&gt;RUN rm xxx 删除前面层的文件不会减小镜像大小，因为包含文件的那层会一直存在，RUN set合并为一层&lt;/li&gt;
&lt;li&gt;尽量不在dockerfile去修改文件权限，修改权限后的文件会生成一份新的文件导致镜像变大，修改权限最好本地直接改好或写在启动脚本中(不推荐)。&lt;/li&gt;
&lt;li&gt;只复制需要的，如果可能，避免复制。在将文件复制到镜像中时，请确保对要复制的内容非常明确，避免 COPY . /home/admin/broker 这样的操作，使用COPY app/xxx.jar /home/admin/broker&lt;/li&gt;
&lt;li&gt;添加文件夹到指定目录，最好填写绝对路径，如果想把kafka文件夹添加到home，要写成ADD kafka/ /home/kafka/&lt;/li&gt;
&lt;li&gt;大的rpm包，如果要安装到镜像中，可以做成yum 源，yum install xx之后yum clean all，如果ADD XX.rpm /xx，这样rpm会使镜像增大。&lt;/li&gt;
&lt;li&gt;大的压缩包最好是做成可以下载的文件，下载解压后删除源文件&lt;/li&gt;
&lt;li&gt;多个RUN或者ENV最好合并为一个，这样生成的文件都在同一层，便于优化大小&lt;/li&gt;
&lt;li&gt;去掉不必要的组件，比如 yum install vim 不安装运行不必须得vim，可以减小镜像体积&lt;/li&gt;
&lt;li&gt;每次RUN的后面阶段删除不必要的文件，比如 yum install xx 安装软件后要执行 yum clean all 清除缓存，减小镜像。&lt;/li&gt;
&lt;li&gt;基础镜像要指定明确的版本 FROM openjdk:latest 建议使用 FROM openjdk:8-jre-alpine&lt;/li&gt;
&lt;li&gt;基础镜像如果可能，尽量使用官方发布的版本，第三方的版本有被植入病毒的风险，而且没法保证及时补丁升级和更新&lt;/li&gt;
&lt;li&gt;基础镜像尽量选择小体积的发行版本，比如基于alpine linux制作的镜像，&lt;/li&gt;
&lt;li&gt;分阶段编译，docker 17.05 版本以后开始支持分阶段编译，可以使用编译镜像去编译，生成的目标文件导入到运行环境镜像中，这样编译出的镜像就可以不需要一些编译工具，编译依赖，去掉编译中产生的无用文件&lt;/li&gt;
&lt;li&gt;WORKDIR 为 RUN CMD ENTRYPOINT指定一个默认的工作目录&lt;/li&gt;
&lt;li&gt;启动脚本中最好使用 exec去运行程序&lt;/li&gt;
&lt;li&gt;使用LABEL去添加一些附属信息，比如作者，联系方式，内部软件版本之类&lt;/li&gt;
&lt;li&gt;使用HEALTHCHECK添加健康检查，判断拉起的容器业务是否正常&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;FROM golang:1.7.3 AS builder
WORKDIR /go/src/github.com/alexellis/href-counter/
RUN go get -d -v golang.org/x/net/html  
COPY app.go    .
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .

FROM alpine:latest  
RUN apk --no-cache add ca-certificates
WORKDIR /root/
COPY --from=builder /go/src/github.com/alexellis/href-counter/app .
CMD [&amp;quot;./app&amp;quot;]  
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;docker-实战与练习&#34;&gt;Docker 实战与练习&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;./Docker.pdf&#34; &gt;Docker 实战与练习&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Python安全指南</title>
        <link>https://zcj-git520.github.io/p/python%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</link>
        <pubDate>Sat, 30 Oct 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/python%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/python%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/1.jpg" alt="Featured image of post Python安全指南" /&gt;&lt;h2 id=&#34;文章来源&#34;&gt;文章来源&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Tencent/secguide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;鹅厂(腾讯)代码安全指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;通用&#34;&gt;通用&lt;/h2&gt;
&lt;h3 id=&#34;加密算法&#34;&gt;加密算法&lt;/h3&gt;
&lt;h4 id=&#34;必须避免使用不安全的对称加密算法&#34;&gt;【必须】避免使用不安全的对称加密算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;DES和3DES已经不再适用于现代应用程序，应改为使用AES。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;程序日志&#34;&gt;程序日志&lt;/h3&gt;
&lt;h4 id=&#34;建议对每个重要行为都记录日志&#34;&gt;【建议】对每个重要行为都记录日志&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;确保重要行为都记录日志，且可靠保存6个月以上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;122-建议禁止将未经验证的用户输入直接记录日志&#34;&gt;1.2.2 【建议】禁止将未经验证的用户输入直接记录日志&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当日志条目包含未经净化的用户输入时会引发记录注入漏洞。恶意用户会插入伪造的日志数据，从而让系统管理员以为是系统行为。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;123-建议避免在日志中保存敏感信息&#34;&gt;1.2.3 【建议】避免在日志中保存敏感信息&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;不能在日志保存密码（包括明文密码和密文密码）、密钥和其它敏感信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;系统口令&#34;&gt;系统口令&lt;/h3&gt;
&lt;h4 id=&#34;必须禁止使用空口令弱口令已泄露口令&#34;&gt;【必须】禁止使用空口令、弱口令、已泄露口令&lt;/h4&gt;
&lt;h4 id=&#34;必须口令强度要求&#34;&gt;【必须】口令强度要求&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;口令强度须同时满足：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;密码长度大于14位&lt;/li&gt;
&lt;li&gt;必须包含下列元素：大小写英文字母、数字、特殊字符&lt;/li&gt;
&lt;li&gt;不得使用各系统、程序的默认初始密码&lt;/li&gt;
&lt;li&gt;不能与最近6次使用过的密码重复&lt;/li&gt;
&lt;li&gt;不得与其他外部系统使用相同的密码&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;必须口令存储安全&#34;&gt;【必须】口令存储安全&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;禁止明文存储口令&lt;/li&gt;
&lt;li&gt;禁止使用弱密码学算法（如DES和3DES）加密存储口令&lt;/li&gt;
&lt;li&gt;使用不可逆算法和随机salt对口令进行加密存储&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须禁止传递明文口令&#34;&gt;【必须】禁止传递明文口令&lt;/h4&gt;
&lt;h4 id=&#34;必须禁止在不安全的信道中传输口令&#34;&gt;【必须】禁止在不安全的信道中传输口令&lt;/h4&gt;
&lt;h2 id=&#34;配置环境&#34;&gt;配置&amp;amp;环境&lt;/h2&gt;
&lt;h3 id=&#34;python版本选择&#34;&gt;Python版本选择&lt;/h3&gt;
&lt;h4 id=&#34;建议使用python-36的版本&#34;&gt;【建议】使用Python 3.6+的版本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;新增的项目应使用 Python 3.6+&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么要这么做？&lt;/strong&gt;
由于 Python 2 在 &lt;a class=&#34;link&#34; href=&#34;https://www.python.org/doc/sunset-python-2/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2020 年停止维护&lt;/a&gt;，相关组件的漏洞不能得到及时修复与维护&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;第三方包安全&#34;&gt;第三方包安全&lt;/h3&gt;
&lt;h4 id=&#34;必须禁止使用不安全的组件&#34;&gt;【必须】禁止使用不安全的组件&lt;/h4&gt;
&lt;h3 id=&#34;配置信息&#34;&gt;配置信息&lt;/h3&gt;
&lt;h4 id=&#34;必须密钥存储安全&#34;&gt;【必须】密钥存储安全&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在使用对称密码算法时，需要保护好加密密钥。当算法涉及敏感、业务数据时，可通过非对称算法协商加密密钥。其他较为不敏感的数据加密，可以通过变换算法等方式保护密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须禁止硬编码敏感配置&#34;&gt;【必须】禁止硬编码敏感配置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;禁止在源码中硬编码AK/SK、IP、数据库账密等配置信息&lt;/li&gt;
&lt;li&gt;应使用配置系统或KMS密钥管理系统。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;后台&#34;&gt;后台&lt;/h2&gt;
&lt;h3 id=&#34;输入验证&#34;&gt;输入验证&lt;/h3&gt;
&lt;h4 id=&#34;必须按类型进行数据校验&#34;&gt;【必须】按类型进行数据校验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有程序外部输入的参数值，应进行数据校验。校验内容包括但不限于：数据长度、数据范围、数据类型与格式。校验不通过，应拒绝。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐使用组件：&lt;a class=&#34;link&#34; href=&#34;https://github.com/pyeve/cerberus&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Cerberus&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/Julian/jsonschema&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jsonschema&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://docs.djangoproject.com/en/dev/ref/validators/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Django-Validators&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# Cerberus示例&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Validator&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;type&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;string&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}})&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;validate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;name&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;john doe&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# jsonschema示例&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;schema&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;object&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
     &lt;span class=&#34;s2&#34;&gt;&amp;#34;properties&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;s2&#34;&gt;&amp;#34;price&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;number&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
         &lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;type&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;string&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
     &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;validate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;name&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;Eggs&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;price&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;34.99&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;schema&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;schema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;sql操作&#34;&gt;SQL操作&lt;/h3&gt;
&lt;h4 id=&#34;必须使用参数化查询&#34;&gt;【必须】使用参数化查询&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用参数化SQL语句，强制区分数据和命令，避免产生SQL注入漏洞。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 错误示例&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;mysql.connector&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;mydb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mydb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;userid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_id_from_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 使用%直接格式化字符串拼接SQL语句&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;SELECT `id`, `password` FROM `auth_user` WHERE `id`=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%s&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,))&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;myresult&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fetchall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安全示例&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;mysql.connector&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;mydb&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mysql&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mydb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cursor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;userid&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_id_from_user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 将元组以参数的形式传入&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;SELECT `id`, `password` FROM `auth_user` WHERE `id`=&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;%s&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt; &amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userid&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,))&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;myresult&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fetchall&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;推荐使用ORM框架来操作数据库，如：使用&lt;code&gt;SQLAlchemy&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安装sqlalchemy并初始化数据库连接&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# pip install sqlalchemy&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sqlalchemy&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_engine&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 初始化数据库连接，修改为你的数据库用户名和密码&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;engine&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;mysql+mysqlconnector://user:password@host:port/DATABASE&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 引用数据类型&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sqlalchemy&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Column&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Float&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sqlalchemy.ext.declarative&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;declarative_base&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;declarative_base&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 定义 Player 对象:&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Base&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;# 表的名字:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;__tablename__&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;player&amp;#39;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;# 表的结构:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;player_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Column&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;primary_key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;autoincrement&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;True&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;team_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Column&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;player_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Column&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;255&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Column&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Float&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 增删改查&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sqlalchemy.orm&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sessionmaker&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 创建 DBSession 类型:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;DBSession&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sessionmaker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 创建 session 对象:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;session&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DBSession&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 增:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;new_player&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;team_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;101&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;player_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Tom&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mf&#34;&gt;1.98&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;new_player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 删:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;row&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;player_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Tom&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;row&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 改:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;row&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;player_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;==&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;Tom&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;first&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;row&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.99&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 查:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;rows&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1.88&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;all&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 提交即保存到数据库:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;commit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 关闭 session:&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;必须对参数进行过滤&#34;&gt;【必须】对参数进行过滤&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;将接受到的外部参数动态拼接到SQL语句时，必须对参数进行安全过滤。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;sql_filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;max_length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;dirty_stuff&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#39;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;=&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;-&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;#&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;lt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;+&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
                   &lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;amp;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;$&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;(&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;)&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;%&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;@&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;,&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stuff&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dirty_stuff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;sql&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;replace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stuff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;x&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sql&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;执行命令&#34;&gt;执行命令&lt;/h3&gt;
&lt;h4 id=&#34;建议避免直接调用函数执行系统命令&#34;&gt;【建议】避免直接调用函数执行系统命令&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;相关功能的实现应避免直接调用系统命令（如&lt;code&gt;os.system()&lt;/code&gt;、&lt;code&gt;os.popen()&lt;/code&gt;、&lt;code&gt;subprocess.call()&lt;/code&gt;等），优先使用其他同类操作进行代替，比如：通过文件系统API进行文件操作而非直接调用操作系统命令&lt;/li&gt;
&lt;li&gt;如评估无法避免，执行命令应避免拼接外部数据，同时进行执行命令的白名单限制。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须过滤传入命令执行函数的字符&#34;&gt;【必须】过滤传入命令执行函数的字符&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;程序调用各类函数执行系统命令时，如果涉及的命令由外部传入，过滤传入命令执行函数的字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;os&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sys&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;shlex&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 替换可以用来注入命令的字符为空&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;badchars&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;amp;;|&amp;#39;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;$()`-&amp;#34;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;badchars&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;domain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;domain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;replace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;nslookup &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shlex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;quote&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;domain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;xml读写&#34;&gt;XML读写&lt;/h3&gt;
&lt;h4 id=&#34;必须禁用外部实体的方法&#34;&gt;【必须】禁用外部实体的方法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;禁用外部实体的方法，来预防XXE攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;lxml&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;etree&lt;/span&gt;
  
&lt;span class=&#34;n&#34;&gt;xmlData&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;etree&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;parse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;xmlSource&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;etree&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;XMLParser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;resolve_entities&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;文件操作&#34;&gt;文件操作&lt;/h3&gt;
&lt;h4 id=&#34;必须文件类型限制&#34;&gt;【必须】文件类型限制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;通过白名单对上传或者下载的文件类型、大小进行严格校验。仅允许业务所需文件类型上传，避免上传木马、WebShell等文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;os&lt;/span&gt;
  
&lt;span class=&#34;n&#34;&gt;ALLOWED_EXTENSIONS&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;txt&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;jpg&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;png&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
  
&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;allowed_file&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;.&amp;#39;&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; 
        &lt;span class=&#34;s1&#34;&gt;&amp;#39;..&amp;#39;&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;and&lt;/span&gt; 
        &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splitext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lower&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ALLOWED_EXTENSIONS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;None&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;必须禁止外部文件存储于可执行目录&#34;&gt;【必须】禁止外部文件存储于可执行目录&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;禁止外部文件存储于WEB容器的可执行目录（appBase）。建议使用 &lt;a class=&#34;link&#34; href=&#34;https://docs.python.org/3/library/tempfile.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;tempfile&lt;/a&gt; 库处理临时文件和临时目录。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须避免路径穿越&#34;&gt;【必须】避免路径穿越&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;保存在本地文件系统时，必须对路径进行合法校验，避免目录穿越漏洞&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;os&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;upload_dir&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;/tmp/upload/&amp;#39;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 预期的上传目录&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;file_name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;../../etc/hosts&amp;#39;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 用户传入的文件名&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;absolute_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;join&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;upload_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# /tmp/upload/../../etc/hosts&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;normalized_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;normpath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;absolute_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# /etc/hosts&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;normalized_path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;startswith&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;upload_dir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;# 检查最终路径是否在预期的上传目录中&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;raise&lt;/span&gt; &lt;span class=&#34;ne&#34;&gt;IOError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id=&#34;建议避免路径拼接&#34;&gt;【建议】避免路径拼接&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;文件目录避免外部参数拼接。保存文件目录建议后台写死并对文件名进行校验（字符类型、长度）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;建议文件名hash化处理&#34;&gt;【建议】文件名hash化处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;建议文件保存时，将文件名替换为随机字符串。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;uuid&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;def&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;random_filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ext&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;os&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;splitext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filename&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;new_filename&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;uuid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;uuid4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ext&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;new_filename&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;网络请求&#34;&gt;网络请求&lt;/h3&gt;
&lt;h4 id=&#34;必须限定访问网络资源地址范围&#34;&gt;【必须】限定访问网络资源地址范围&lt;/h4&gt;
&lt;p&gt;当程序需要从用户指定的&lt;code&gt;URL地址获取网页文本内容&lt;/code&gt;、&lt;code&gt;加载指定地址的图片&lt;/code&gt;、&lt;code&gt;进行下载&lt;/code&gt;等操作时，需要对URL地址进行安全校验：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;只允许HTTP或HTTPS协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解析目标URL，获取其host&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解析host，获取host指向的IP地址转换成long型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检查IP地址是否为内网IP&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。&lt;/span&gt;
&lt;span class=&#34;mf&#34;&gt;10.0.0.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;span class=&#34;mf&#34;&gt;172.16.0.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;
&lt;span class=&#34;mf&#34;&gt;192.168.0.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;
&lt;span class=&#34;mf&#34;&gt;127.0.0.0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start=&#34;5&#34;&gt;
&lt;li&gt;
&lt;p&gt;请求URL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果有跳转，跳转后执行1，否则对URL发起请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;响应输出&#34;&gt;响应输出&lt;/h3&gt;
&lt;h4 id=&#34;必须设置正确的http响应包类型&#34;&gt;【必须】设置正确的HTTP响应包类型&lt;/h4&gt;
&lt;p&gt;响应包的HTTP头“Content-Type”必须正确配置响应包的类型，禁止非HTML类型的响应包设置为“text/html”。&lt;/p&gt;
&lt;h4 id=&#34;必须设置安全的http响应头&#34;&gt;【必须】设置安全的HTTP响应头&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;X-Content-Type-Options&lt;/p&gt;
&lt;p&gt;添加“X-Content-Type-Options”响应头并将其值设置为“nosniff ”&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HttpOnly
控制用户登鉴权的Cookie字段 应当设置HttpOnly属性以防止被XSS漏洞/JavaScript操纵泄漏。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;X-Frame-Options&lt;/p&gt;
&lt;p&gt;设置X-Frame-Options响应头，并根据需求合理设置其允许范围。该头用于指示浏览器禁止当前页面在frame、 iframe、embed等标签中展现。从而避免点击劫持问题。它有三个可选的值: DENY: 浏览器会拒绝当前页面加 载任何frame页面; SAMEORIGIN:则frame页面的地址只能为同源域名下的页面 ALLOW-FROM origin:可以定 义允许frame加载的页面地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须对外输出页面包含第三方数据时须进行编码处理&#34;&gt;【必须】对外输出页面包含第三方数据时须进行编码处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当响应“Content-Type”为“text/html”类型时，需要对响应体进行编码处理&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 推荐使用mozilla维护的bleach库来进行过滤&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;bleach&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;bleach&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;clean&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;an &amp;lt;script&amp;gt;evil()&amp;lt;/script&amp;gt; example&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# u&amp;#39;an &amp;amp;lt;script&amp;amp;gt;evil()&amp;amp;lt;/script&amp;amp;gt; example&amp;#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;数据输出&#34;&gt;数据输出&lt;/h3&gt;
&lt;h4 id=&#34;必须敏感数据加密存储&#34;&gt;【必须】敏感数据加密存储&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;敏感数据应使用SHA2、RSA等算法进行加密存储&lt;/li&gt;
&lt;li&gt;敏感数据应使用独立的存储层，并在访问层开启访问控制&lt;/li&gt;
&lt;li&gt;包含敏感信息的临时文件或缓存一旦不再需要应立刻删除&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须敏感信息必须由后台进行脱敏处理&#34;&gt;【必须】敏感信息必须由后台进行脱敏处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;敏感信息须再后台进行脱敏后返回，禁止接口返回敏感信息交由前端/客户端进行脱敏处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须高敏感信息禁止存储展示&#34;&gt;【必须】高敏感信息禁止存储、展示&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;口令、密保答案、生理标识等鉴权信息禁止展示&lt;/li&gt;
&lt;li&gt;非金融类业务，信用卡cvv码及日志禁止存储&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须个人敏感信息脱敏展示&#34;&gt;【必须】个人敏感信息脱敏展示&lt;/h4&gt;
&lt;p&gt;在满足业务需求的情况下，个人敏感信息需脱敏展示，如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;身份证只显示第一位和最后一位字符，如3****************1。&lt;/li&gt;
&lt;li&gt;移动电话号码隐藏中间6位字符，如134******48。&lt;/li&gt;
&lt;li&gt;工作地址/家庭地址最多显示到“区”一级。&lt;/li&gt;
&lt;li&gt;银行卡号仅显示最后4位字符，如************8639&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须隐藏后台地址&#34;&gt;【必须】隐藏后台地址&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;若程序对外提供了登录后台地址，应使用随机字符串隐藏地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 不要采取这种方式&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;admin_login_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;xxxx/login&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 安全示例&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;admin_login_url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;xxxx/ranD0Str&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;权限管理&#34;&gt;权限管理&lt;/h3&gt;
&lt;h4 id=&#34;必须默认鉴权&#34;&gt;【必须】默认鉴权&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;除非资源完全可对外开放，否则系统默认进行身份认证（使用白名单的方式放开不需要认证的接口或页面）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;####【必须】授权遵循最小权限原则&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;程序默认用户应不具备任何操作权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须避免越权访问&#34;&gt;【必须】避免越权访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;对于非公共操作，应当校验当前访问账号进行操作权限（常见于CMS）和数据权限校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;验证当前用户的登录态；&lt;/li&gt;
&lt;li&gt;从可信结构中获取经过校验的当前请求账号的身份信息（如：session），禁止从用户请求参数或Cookie中获取外部传入不可信用户身份直接进行查询；&lt;/li&gt;
&lt;li&gt;校验当前用户是否具备该操作权限；&lt;/li&gt;
&lt;li&gt;校验当前用户是否具备所操作数据的权限；&lt;/li&gt;
&lt;li&gt;校验当前操作是否账户是否预期账户。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;建议及时清理不需要的权限&#34;&gt;【建议】及时清理不需要的权限&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;程序应定期清理非必需用户的权限。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;异常处理&#34;&gt;异常处理&lt;/h3&gt;
&lt;h4 id=&#34;必须不向对外错误提示&#34;&gt;【必须】不向对外错误提示&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;应合理使用&lt;code&gt;try/except/finally&lt;/code&gt; 处理系统异常，避免出错信息输出到前端。&lt;/li&gt;
&lt;li&gt;对外环境禁止开启debug模式，或将程序运行日志输出到前端。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须禁止异常抛出敏感信息&#34;&gt;【必须】禁止异常抛出敏感信息&lt;/h4&gt;
&lt;h3 id=&#34;flask安全&#34;&gt;Flask安全&lt;/h3&gt;
&lt;h4 id=&#34;必须生产环境关闭调试模式&#34;&gt;【必须】生产环境关闭调试模式&lt;/h4&gt;
&lt;h4 id=&#34;建议遵循flask安全规范&#34;&gt;【建议】遵循Flask安全规范&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;参考Flask文档中的安全注意事项 &lt;a class=&#34;link&#34; href=&#34;https://flask.palletsprojects.com/en/latest/security/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://flask.palletsprojects.com/en/latest/security/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;django安全&#34;&gt;Django安全&lt;/h3&gt;
&lt;h4 id=&#34;必须生产环境关闭调试模式-1&#34;&gt;【必须】生产环境关闭调试模式&lt;/h4&gt;
&lt;p&gt;####【建议】保持Django自带的安全特性开启&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保持Django自带的安全特性开启 &lt;a class=&#34;link&#34; href=&#34;https://docs.djangoproject.com/en/3.0/topics/security/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://docs.djangoproject.com/en/3.0/topics/security/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在默认配置下，Django自带的安全特性对XSS、CSRF、SQL注入、点击劫持等类型漏洞可以起到较好防护效果。应尽量避免关闭这些安全特性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>c/c&#43;&#43;安全指南</title>
        <link>https://zcj-git520.github.io/p/c/c-%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</link>
        <pubDate>Thu, 28 Oct 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/c/c-%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/c/c-%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/1.jpg" alt="Featured image of post c/c&#43;&#43;安全指南" /&gt;&lt;h2 id=&#34;文章来源&#34;&gt;文章来源&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Tencent/secguide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;鹅厂(腾讯)代码安全指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;通用安全指南&#34;&gt;通用安全指南&lt;/h2&gt;
&lt;h3 id=&#34;cc使用错误&#34;&gt;C/C++使用错误&lt;/h3&gt;
&lt;h4 id=&#34;必须不得直接使用无长度限制的字符拷贝函数&#34;&gt;【必须】不得直接使用无长度限制的字符拷贝函数&lt;/h4&gt;
&lt;p&gt;不应直接使用legacy的字符串拷贝、输入函数，如strcpy、strcat、sprintf、wcscpy、mbscpy等，这些函数的特征是：可以输出一长串字符串，而不限制长度。如果环境允许，应当使用其_s安全版本替代，或者使用n版本函数（如：snprintf，vsnprintf）。&lt;/p&gt;
&lt;p&gt;若使用形如sscanf之类的函数时，在处理字符串输入时应当通过%10s这样的方式来严格限制字符串长度，同时确保字符串末尾有\0。如果环境允许，应当使用_s安全版本。&lt;/p&gt;
&lt;p&gt;但是注意，虽然MSVC 2015时默认引入结尾为0版本的&lt;code&gt;snprintf&lt;/code&gt;（行为等同于C99定义的&lt;code&gt;snprintf&lt;/code&gt;）。但更早期的版本中，MSVC的&lt;code&gt;snprintf&lt;/code&gt;可能是&lt;code&gt;_snprintf&lt;/code&gt;的宏。而&lt;code&gt;_snprintf&lt;/code&gt;是不保证\0结尾的（见本节后半部分）。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MSVC&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Beginning&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;the&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UCRT&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Visual&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Studio&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2015&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;and&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Windows&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;no&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;longer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;identical&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;to&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;_snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;The&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;function&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;behavior&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;is&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;C99&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;standard&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;compliant&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;从&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Visual&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Studio&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2015&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;和&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Windows&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;中的&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;UCRT开始&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;snprintf不再与_snprintf相同&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;snprintf函数行为现在符合C99标准&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;。&lt;/span&gt;

&lt;span class=&#34;err&#34;&gt;请参考：&lt;/span&gt;&lt;span class=&#34;nl&#34;&gt;https&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//docs.microsoft.com/en-us/cpp/c-runtime-library/reference/snprintf-snprintf-snprintf-l-snwprintf-snwprintf-l?redirectedfrom=MSDN&amp;amp;view=vs-2019
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;因此，在使用n系列拷贝函数时，要确保正确计算缓冲区长度，同时，如果你不确定是否代码在各个编译器下都能确保末尾有0时，建议可以适当增加1字节输入缓冲区，并将其置为\0，以保证输出的字符串结尾一定有\0。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;101&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;foobar ...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一些需要注意的函数，例如&lt;code&gt;strncpy&lt;/code&gt;和&lt;code&gt;_snprintf&lt;/code&gt;是不安全的。 &lt;code&gt;strncpy&lt;/code&gt;不应当被视为&lt;code&gt;strcpy&lt;/code&gt;的n系列函数，它只是恰巧与其他n系列函数名字很像而已。&lt;code&gt;strncpy&lt;/code&gt;在复制时，如果复制的长度超过n，不会在结尾补\0。&lt;/p&gt;
&lt;p&gt;同样，MSVC &lt;code&gt;_snprintf&lt;/code&gt;系列函数在超过或等于n时也不会以0结尾。如果后续使用非0结尾的字符串，可能泄露相邻的内容或者导致程序崩溃。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;_snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;AAAA&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码在MSVC中执行后， a[4] == &amp;lsquo;A&amp;rsquo;，因此字符串未以0结尾。a的内容是&amp;quot;AAAA&amp;quot;，调用&lt;code&gt;strlen(a)&lt;/code&gt;则会越界访问。因此，正确的操作举例如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;_snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;AAAA&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 C++ 中，强烈建议用 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt; 等更高封装层次的基础组件代替原始指针和动态数组，对提高代码的可读性和安全性都有很大的帮助。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄露&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;低风险-拒绝服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-缓冲区溢出&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须创建进程类的函数的安全规范&#34;&gt;【必须】创建进程类的函数的安全规范&lt;/h4&gt;
&lt;p&gt;system、WinExec、CreateProcess、ShellExecute等启动进程类的函数，需要严格检查其参数。&lt;/p&gt;
&lt;p&gt;启动进程需要加上双引号，错误例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WinExec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;D:&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;program files&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;my folder&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;foobar.exe&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SW_SHOW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;当存在&lt;code&gt;D:\program files\my.exe&lt;/code&gt;的时候，my.exe会被启动。而foobar.exe不会启动。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WinExec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;D:&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;program files&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;my folder&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\\&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;foobar.exe&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\&amp;#34;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SW_SHOW&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另外，如果启动时从用户输入、环境变量读取组合命令行时，还需要注意是否可能存在命令注入。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cmdline&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;calc &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cmdline&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmdline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;比如，当用户输入&lt;code&gt;1+1 &amp;amp;&amp;amp; ls&lt;/code&gt;时，执行的实际上是calc 1+1和ls 两个命令，导致命令注入。&lt;/p&gt;
&lt;p&gt;需要检查用户输入是否含有非法数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cmdline&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;ls &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;cmdline&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmdline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;find_first_not_of&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1234567890.+-*/e &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;npos&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;system&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cmdline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c_str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
  &lt;span class=&#34;nf&#34;&gt;warning&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-代码执行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-权限提升&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须尽量减少使用-_alloca-和可变长度数组&#34;&gt;【必须】尽量减少使用 _alloca 和可变长度数组&lt;/h4&gt;
&lt;p&gt;_alloca 和&lt;a class=&#34;link&#34; href=&#34;https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%8F%98%E9%95%BF%E6%95%B0%E7%BB%84&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;可变长度数组&lt;/a&gt;使用的内存量在编译期间不可知。尤其是在循环中使用时，根据编译器的实现不同，可能会导致：（1）栈溢出，即拒绝服务； （2）缺少栈内存测试的编译器实现可能导致申请到非栈内存，并导致内存损坏。这在栈比较小的程序上，例如IoT设备固件上影响尤为大。对于 C++，可变长度数组也属于非标准扩展，在代码规范中禁止使用。&lt;/p&gt;
&lt;p&gt;错误示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_alloca&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mh&#34;&gt;0x10000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;something&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;..;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 不可控的栈溢出风险！
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 改用动态分配的堆内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mh&#34;&gt;0x10000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;..&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;do&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;something&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;..;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo_is_no_longer_needed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// C++
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// C
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;低风险-拒绝服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须printf系列参数必须对应&#34;&gt;【必须】printf系列参数必须对应&lt;/h4&gt;
&lt;p&gt;所有printf系列函数，如sprintf，snprintf，vprintf等必须对应控制符号和参数。&lt;/p&gt;
&lt;p&gt;错误示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%d: %p&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;some_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// %p 应为 %s
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;send_to_remote&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%d: %s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;some_string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf_size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;send_to_remote&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer_send_to_remote_client&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;前者可能会让client的攻击者获取部分服务器的原始指针地址，可以用于破坏ASLR保护。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄露&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须防止泄露指针包括p的值&#34;&gt;【必须】防止泄露指针（包括%p）的值&lt;/h4&gt;
&lt;p&gt;所有printf系列函数，要防止格式化完的字符串泄露程序布局信息。例如，如果将带有%p的字符串泄露给程序，则可能会破坏ASLR的防护效果。使得攻击者更容易攻破程序。&lt;/p&gt;
&lt;p&gt;%p的值只应当在程序内使用，而不应当输出到外部或被外部以某种方式获取。&lt;/p&gt;
&lt;p&gt;错误示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 如果这是暴露给客户的一个API：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetUniqueObjectId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pobject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;pobject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确示例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_object_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object_id_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_object_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 如果这是暴露给客户的一个API：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64_t&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetUniqueObjectId&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;object_id_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄露&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须不应当把用户可修改的字符串作为printf系列函数的format参数&#34;&gt;【必须】不应当把用户可修改的字符串作为printf系列函数的“format”参数&lt;/h4&gt;
&lt;p&gt;如果用户可以控制字符串，则通过 %n %p 等内容，最坏情况下可以直接执行任意恶意代码。&lt;/p&gt;
&lt;p&gt;在以下情况尤其需要注意： WIFI名，设备名……&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wifi_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;snprinf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;wifi_name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-代码执行&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄露&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;低风险-拒绝服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须对数组delete时需要使用delete&#34;&gt;【必须】对数组delete时需要使用delete[]&lt;/h4&gt;
&lt;p&gt;delete []操作符用于删除数组。delete操作符用于删除非数组对象。它们分别调用operator delete[]和operator delete。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// trigger assert in DEBUG mode
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在new[]返回的指针上调用delete将是取决于编译器的未定义行为。代码中存在对未定义行为的依赖是错误的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 C++ 代码中，使用 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt;、智能指针（比如&lt;a class=&#34;link&#34; href=&#34;https://zh.cppreference.com/w/cpp/memory/unique_ptr&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;std::unique_ptr&amp;lt;T[]&amp;gt;&lt;/a&gt;）等可以消除绝大多数 &lt;code&gt;delete[]&lt;/code&gt; 的使用场景，并且代码更清晰。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;低风险-内存泄漏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;低风险-拒绝服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须注意隐式符号转换&#34;&gt;【必须】注意隐式符号转换&lt;/h4&gt;
&lt;p&gt;两个无符号数相减为负数时，结果应当为一个很大的无符号数，但是小于int的无符号数在运算时可能会有预期外的隐式符号转换。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// a - b = -1 (signed int)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// a - b = -1 (signed int)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述结果均为a=6&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// a - b = 0xffffffff (unsigned int)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  
&lt;span class=&#34;c1&#34;&gt;// 4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// a - b = 0xffffffff (unsigned int)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述结果均为a=8&lt;/p&gt;
&lt;p&gt;如果预期为8，则错误代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// a - b = -1 (signed int)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确代码：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;short&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// a - b = 0xffff (unsigned short)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须注意八进制问题&#34;&gt;【必须】注意八进制问题&lt;/h4&gt;
&lt;p&gt;代码对齐时应当使用空格或者编辑器自带的对齐功能，谨慎在数字前使用0来对齐代码，以免不当将某些内容转换为八进制。&lt;/p&gt;
&lt;p&gt;例如，如果预期为20字节长度的缓冲区，则下列代码存在错误。buf2为020（OCT）长度，实际只有16（DEC）长度，在memcpy后越界：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mo&#34;&gt;0020&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;somebuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;19&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应当在使用8进制时明确注明这是八进制。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;access_mask&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0777&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// oct, rwxrwxrwx
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;不推荐的编程习惯&#34;&gt;不推荐的编程习惯&lt;/h3&gt;
&lt;h4 id=&#34;必须switch中应有default&#34;&gt;【必须】switch中应有default&lt;/h4&gt;
&lt;p&gt;switch中应该有default，以处理各种预期外的情况。这可以确保switch接受用户输入，或者后期在其他开发者修改函数后确保switch仍可以覆盖到所有情况，并确保逻辑正常运行。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;例如上述代码switch的取值可能从0～7，所以应当有default：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-内存泄漏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须不应当在debug或错误信息中提供过多内容&#34;&gt;【必须】不应当在Debug或错误信息中提供过多内容&lt;/h4&gt;
&lt;p&gt;包含过多信息的Debug消息不应当被用户获取到。Debug信息可能会泄露一些值，例如内存数据、内存地址等内容，这些内容可以帮助攻击者在初步控制程序后，更容易地攻击程序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;OutputDebugInfoToUser&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Wrong value for bar %p = %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而应该：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;

&lt;span class=&#34;cp&#34;&gt;#ifdef DEBUG
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;OutputDebugInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Wrong value for bar.&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;cp&#34;&gt;#endif
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄漏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须不应该在客户端代码中硬编码对称加密秘钥&#34;&gt;【必须】不应该在客户端代码中硬编码对称加密秘钥&lt;/h4&gt;
&lt;p&gt;不应该在客户端代码中硬编码对称加密秘钥。例如：不应在客户端代码使用硬编码的 AES/ChaCha20-Poly1305/SM1 密钥，使用固定密钥的程序基本和没有加密一样。&lt;/p&gt;
&lt;p&gt;如果业务需求是认证加密数据传输，应优先考虑直接用 HTTPS 协议。&lt;/p&gt;
&lt;p&gt;如果是其它业务需求，可考虑由服务器端生成对称秘钥，客户端通过 HTTPS 等认证加密通信渠道从服务器拉取。&lt;/p&gt;
&lt;p&gt;或者根据用户特定的会话信息，比如登录认证过程可以根据用户名用户密码业务上下文等信息，使用 HKDF 等算法衍生出对称秘钥。&lt;/p&gt;
&lt;p&gt;又或者使用 RSA/ECDSA + ECDHE 等进行认证秘钥协商，生成对称秘钥。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_aes_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{...};&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;AES_func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_aes_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;output_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以考虑在线为每个用户获取不同的密钥：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_aes_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;....&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;AES_encrypt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_aes_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;output_data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;g_aes_key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;get_key_from_https&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄露&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须返回栈上变量的地址&#34;&gt;【必须】返回栈上变量的地址&lt;/h4&gt;
&lt;p&gt;函数不可以返回栈上的变量的地址，其内容在函数返回后就会失效。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// WRONG
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;而应当使用堆来传递非简单类型变量。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;300&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// OK
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 C++ 程序来说，强烈建议返回 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt; 等类型，会让代码更加简单和安全。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须有逻辑联系的数组必须仔细检查&#34;&gt;【必须】有逻辑联系的数组必须仔细检查&lt;/h4&gt;
&lt;p&gt;例如下列程序将字符串转换为week day，但是两个数组并不一样长，导致程序可能会越界读一个int。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Mon&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Tue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Wed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Thu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Fri&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Sat&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Sun&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strcmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;应当确保有关联的nWeekdays和sWeekdays数据统一。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Mon&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Tue&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Wed&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Thu&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Fri&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Sat&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Sun&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;assert&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARRAY_SIZE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strcmp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nWeekdays&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须避免函数的声明和实现不同&#34;&gt;【必须】避免函数的声明和实现不同&lt;/h4&gt;
&lt;p&gt;在头文件、源代码、文档中列举的函数声明应当一致，不应当出现定义内容错位的情况。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;p&gt;foo.h&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;CalcArea&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;foo.cc&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;CalcArea&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// Different from foo.h
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;real_height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：
foo.h&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;CalcArea&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;foo.cc&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;CalcArea&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;real_height&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;height&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;width&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须检查复制粘贴的重复代码相同代码通常代表错误&#34;&gt;【必须】检查复制粘贴的重复代码（相同代码通常代表错误）&lt;/h4&gt;
&lt;p&gt;当开发中遇到较长的句子时，如果你选择了复制粘贴语句，请记得检查每一行代码，不要出现上下两句一模一样的情况，这通常代表代码哪里出现了错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SomeStruct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foobase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeStruct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeStruct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foobase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff0000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foobase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff0000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上例，通常可能是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SomeStruct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foobase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeStruct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeStruct&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foobase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff0000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;foo2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foobase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xffff0000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最好是把重复的代码片段提取成函数，如果函数比较短，可以考虑定义为 &lt;code&gt;inline&lt;/code&gt; 函数，在减少冗余的同时也能确保不会影响性能。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须左右一致的重复判断永远为真或假的判断通常代表错误&#34;&gt;【必须】左右一致的重复判断/永远为真或假的判断（通常代表错误）&lt;/h4&gt;
&lt;p&gt;这通常是由于自动完成或例如Visual Assistant X之类的补全插件导致的问题。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;…&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可能是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;err&#34;&gt;…&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须函数每个分支都应有返回值&#34;&gt;【必须】函数每个分支都应有返回值&lt;/h4&gt;
&lt;p&gt;函数的每个分支都应该有返回值，否则如果函数走到无返回值的分支，其结果是未知的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述例子当bar&amp;lt;10时，其结果是未知的值。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开启适当级别的警告（GCC 中为 &lt;code&gt;-Wreturn-type&lt;/code&gt; 并已包含在 &lt;code&gt;-Wall&lt;/code&gt; 中）并设置为错误，可以在编译阶段发现这类错误。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄漏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须不得使用栈上未初始化的变量&#34;&gt;【必须】不得使用栈上未初始化的变量&lt;/h4&gt;
&lt;p&gt;在栈上声明的变量要注意是否在使用它之前已经初始化了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// foo可能没有初始化
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;最好在声明的时候就立刻初始化变量，或者确保每个分支都初始化它。开启相应的编译器警告（GCC 中为 &lt;code&gt;-Wuninitialized&lt;/code&gt;），并把设置为错误级别，可以在编译阶段发现这类错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Foobar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄漏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;建议不得直接使用刚分配的未初始化的内存如realloc&#34;&gt;【建议】不得直接使用刚分配的未初始化的内存（如realloc）&lt;/h4&gt;
&lt;p&gt;一些刚申请的内存通常是直接从堆上分配的，可能包含有旧数据的，直接使用它们而不初始化，可能会导致安全问题。例如，CVE-2019-13751。应确保初始化变量，或者确保未初始化的值不会泄露给用户。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;99&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;char&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;char&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在 C++ 中，再次强烈推荐用 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt; 代替手动内存分配。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-信息泄漏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须校验内存相关函数的返回值&#34;&gt;【必须】校验内存相关函数的返回值&lt;/h4&gt;
&lt;p&gt;与内存分配相关的函数需要检查其返回值是否正确，以防导致程序崩溃或逻辑错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x800000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.....);&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x400000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\x88&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Wrong
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;如上例mmap如果失败，bar的值将是0xffffffff (ffffffff)，第二行将会往0x3ffffff写入字符，导致越界写。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x800000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;.....);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAP_FAILED&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x400000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\x88&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-越界操作&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须不要在if里面赋值&#34;&gt;【必须】不要在if里面赋值&lt;/h4&gt;
&lt;p&gt;if里赋值通常代表代码存在错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x99&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;通常应该是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x99&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;建议在构建系统中开启足够的编译器警告（GCC 中为 &lt;code&gt;-Wparentheses&lt;/code&gt; 并已包含在 &lt;code&gt;-Wall&lt;/code&gt; 中），并把该警告设置为错误。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;建议确认if里面的按位操作&#34;&gt;【建议】确认if里面的按位操作&lt;/h4&gt;
&lt;p&gt;if里，非bool类型和非bool类型的按位操作可能代表代码存在错误。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// binary 01
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foobar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// binary 10
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foobar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// result = 00, false
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码可能应该是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;   &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foobar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foobar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// result : true
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;多线程&#34;&gt;多线程&lt;/h3&gt;
&lt;h4 id=&#34;必须变量应确保线程安全性&#34;&gt;【必须】变量应确保线程安全性&lt;/h4&gt;
&lt;p&gt;当一个变量可能被多个线程使用时，应当使用原子操作或加锁操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;g_somechar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo_thread1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;g_somechar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo_thread2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;g_somechar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于可以使用原子操作的，应当使用一些可以确保内存安全的操作，如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;g_somechar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo_thread1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;__sync_fetch_and_add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_somechar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo_thread2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;__sync_fetch_and_add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;g_somechar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 C 代码，&lt;code&gt;C11&lt;/code&gt; 后推荐使用 &lt;a class=&#34;link&#34; href=&#34;https://en.cppreference.com/w/c/atomic&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;atomic&lt;/a&gt; 标准库。
对于 C++代码，&lt;code&gt;C++11&lt;/code&gt; 后，推荐使用 &lt;a class=&#34;link&#34; href=&#34;https://zh.cppreference.com/w/cpp/atomic/atomic&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;std::atomic&lt;/code&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须注意signal-handler导致的条件竞争&#34;&gt;【必须】注意signal handler导致的条件竞争&lt;/h4&gt;
&lt;p&gt;竞争条件经常出现在信号处理程序中，因为信号处理程序支持异步操作。攻击者能够利用信号处理程序争用条件导致软件状态损坏，从而可能导致拒绝服务甚至代码执行。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当信号处理程序中发生不可重入函数或状态敏感操作时，就会出现这些问题。因为信号处理程序中随时可以被调用。比如，当在信号处理程序中调用&lt;code&gt;free&lt;/code&gt;时，通常会出现另一个信号争用条件，从而导致双重释放。即使给定指针在释放后设置为&lt;code&gt;NULL&lt;/code&gt;，在释放内存和将指针设置为&lt;code&gt;NULL&lt;/code&gt;之间仍然存在竞争的可能。&lt;/li&gt;
&lt;li&gt;为多个信号设置了相同的信号处理程序，这尤其有问题——因为这意味着信号处理程序本身可能会重新进入。例如，malloc()和free()是不可重入的，因为它们可能使用全局或静态数据结构来管理内存，并且它们被syslog()等看似无害的函数间接使用；这些函数可能会导致内存损坏和代码执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;signum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;syslog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LOG_NOTICE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;log_m_essage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;log_message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[])&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;log_message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strdup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;argv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SIGHUP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;signal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SIGTERM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可以借由下列操作规避问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免在多个处理函数中共享某些变量。&lt;/li&gt;
&lt;li&gt;在信号处理程序中使用同步操作。&lt;/li&gt;
&lt;li&gt;屏蔽不相关的信号，从而提供原子性。&lt;/li&gt;
&lt;li&gt;避免在信号处理函数中调用不满足&lt;a class=&#34;link&#34; href=&#34;https://www.man7.org/linux/man-pages/man7/signal-safety.7.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;异步信号安全&lt;/a&gt;的函数。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;建议注意time-of-check-time-of-use-toctou-条件竞争&#34;&gt;【建议】注意Time-of-check Time-of-use (TOCTOU) 条件竞争&lt;/h4&gt;
&lt;p&gt;TOCTOU： 软件在使用某个资源之前检查该资源的状态，但是该资源的状态可以在检查和使用之间更改，从而使检查结果无效。当资源处于这种意外状态时，这可能会导致软件执行错误操作。&lt;/p&gt;
&lt;p&gt;当攻击者可以影响检查和使用之间的资源状态时，此问题可能与安全相关。这可能发生在共享资源(如&lt;strong&gt;文件、内存&lt;/strong&gt;，甚至多线程程序中的&lt;strong&gt;变量&lt;/strong&gt;)上。在编程时需要注意避免出现TOCTOU问题。&lt;/p&gt;
&lt;p&gt;例如，下面的例子中，该文件可能已经在检查和lstat之间进行了更新，特别是因为printf有延迟。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;stat&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;lstat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;foo&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;st&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;st_mtimespec&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Now updating things&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;UpdateThings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;TOCTOU难以修复，但是有以下缓解方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;限制对来自多个进程的文件的交叉操作。&lt;/li&gt;
&lt;li&gt;如果必须在多个进程或线程之间共享对资源的访问，那么请尝试限制”检查“（CHECK）和”使用“（USE）资源之间的时间量，使他们相距尽量不要太远。这不会从根本上解决问题，但可能会使攻击更难成功。&lt;/li&gt;
&lt;li&gt;在Use调用之后重新检查资源，以验证是否正确执行了操作。&lt;/li&gt;
&lt;li&gt;确保一些环境锁定机制能够被用来有效保护资源。但要确保锁定是检查之前进行的，而不是在检查之后进行的，以便检查时的资源与使用时的资源相同。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑问题&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;加密解密&#34;&gt;加密解密&lt;/h3&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;41--必须不得明文存储用户密码等敏感数据&#34;&gt;4.1  【必须】不得明文存储用户密码等敏感数据&lt;/h4&gt;
&lt;p&gt;用户密码应该使用 Argon2, scrypt, bcrypt, pbkdf2 等算法做哈希之后再存入存储系统, &lt;a class=&#34;link&#34; href=&#34;https://password-hashing.net/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://password-hashing.net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://libsodium.gitbook.io/doc/password_hashing/default_phf#example-2-password-storage&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://libsodium.gitbook.io/doc/password_hashing/default_phf#example-2-password-storage&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用户敏感数据，应该做到传输过程中加密，存储状态下加密
传输过程中加密，可以使用 HTTPS 等认证加密通信协议&lt;/p&gt;
&lt;p&gt;存储状态下加密，可以使用 SQLCipher 等类似方案。&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;42--必须内存中的用户密码等敏感数据应该安全抹除&#34;&gt;4.2  【必须】内存中的用户密码等敏感数据应该安全抹除&lt;/h4&gt;
&lt;p&gt;例如用户密码等，即使是临时使用，也应在使用完成后应当将内容彻底清空。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;openssl/crypto.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;password: %s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;password_from_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;snprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;password: %s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;password_from_input&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;OPENSSL_cleanse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_password&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-敏感信息泄露&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;43--必须rand-类函数应正确初始化&#34;&gt;4.3  【必须】rand() 类函数应正确初始化&lt;/h4&gt;
&lt;p&gt;rand类函数的随机性并不高。而且在使用前需要使用srand()来初始化。未初始化的随机数可能导致某些内容可预测。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述代码执行完成后，foo的值是固定的。它等效于 &lt;code&gt;srand(1); rand();&lt;/code&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;srand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;44--必须在需要高强度安全加密时不应使用弱prng函数&#34;&gt;4.4  【必须】在需要高强度安全加密时不应使用弱PRNG函数&lt;/h4&gt;
&lt;p&gt;在需要生成 AES/SM1/HMAC 等算法的密钥/IV/Nonce， RSA/ECDSA/ECDH 等算法的私钥，这类需要高安全性的业务场景，必须使用密码学安全的随机数生成器 (Cryptographically Secure PseudoRandom Number Generator (CSPRNG) ), 不得使用 &lt;code&gt;rand()&lt;/code&gt; 等无密码学安全性保证的普通随机数生成器。&lt;/p&gt;
&lt;p&gt;推荐使用的 CSPRNG 有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;OpenSSL 中的 &lt;code&gt;RAND_bytes()&lt;/code&gt; 函数, &lt;a class=&#34;link&#34; href=&#34;https://www.openssl.org/docs/man1.1.1/man3/RAND_bytes.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.openssl.org/docs/man1.1.1/man3/RAND_bytes.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;libsodium 中的 &lt;code&gt;randombytes_buf()&lt;/code&gt; 函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Linux kernel 的 &lt;code&gt;getrandom()&lt;/code&gt; 系统调用, &lt;a class=&#34;link&#34; href=&#34;https://man7.org/linux/man-pages/man2/getrandom.2.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://man7.org/linux/man-pages/man2/getrandom.2.html&lt;/a&gt; .
或者读 /dev/urandom 文件, 或者 /dev/random 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Apple IOS 的 &lt;code&gt;SecRandomCopyBytes()&lt;/code&gt;, &lt;a class=&#34;link&#34; href=&#34;https://developer.apple.com/documentation/security/1399291-secrandomcopybytes&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://developer.apple.com/documentation/security/1399291-secrandomcopybytes&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Windows 下的 &lt;code&gt;BCryptGenRandom()&lt;/code&gt;, &lt;code&gt;CryptGenRandom()&lt;/code&gt;, &lt;code&gt;RtlGenRandom()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;openssl/aes.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;openssl/crypto.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;openssl/rand.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;#include&lt;/span&gt; &lt;span class=&#34;cpf&#34;&gt;&amp;lt;unistd.h&amp;gt;&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RAND_bytes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//... 错误处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;AES_KEY&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aes_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AES_set_encrypt_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;aes_key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// ... 错误处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

        &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt;

        &lt;span class=&#34;n&#34;&gt;OPENSSL_cleanse&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;code&gt;rand()&lt;/code&gt;类函数的随机性并不高。敏感操作时，如设计加密算法时，不得使用rand()或者类似的简单线性同余伪随机数生成器来作为随机数发生器。符合该定义的比特序列的特点是，序列中“1”的数量约等于“0”的数量；同理，“01”、“00”、“10”、“11”的数量大致相同，以此类推。&lt;/p&gt;
&lt;p&gt;例如 C 标准库中的 &lt;code&gt;rand()&lt;/code&gt; 的实现只是简单的&lt;a class=&#34;link&#34; href=&#34;https://sourceware.org/git/?p=glibc.git;a=blob;f=stdlib/random_r.c;hb=glibc-2.28#l353&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;线性同余算法&lt;/a&gt;，生成的伪随机数具有较强的可预测性。&lt;/p&gt;
&lt;p&gt;当需要实现高强度加密，例如涉及通信安全时，不应当使用 &lt;code&gt;rand()&lt;/code&gt; 作为随机数发生器。&lt;/p&gt;
&lt;p&gt;实际应用中，&lt;a class=&#34;link&#34; href=&#34;https://docs.microsoft.com/en-us/cpp/standard-library/random-device-class?redirectedfrom=MSDN&amp;amp;view=vs-2019#remarks&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt; C++11 标准提供的&lt;code&gt;random_device&lt;/code&gt;保证加密的安全性和随机性&lt;/a&gt;
但是 &lt;a class=&#34;link&#34; href=&#34;https://stackoverflow.com/questions/44867500/is-stdrandom-device-cryptographic-secure&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;C++ 标准并不保证这一点&lt;/a&gt;。跨平台的代码可以考虑用 &lt;a class=&#34;link&#34; href=&#34;https://wiki.openssl.org/index.php/Random_Numbers&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;OpenSSL&lt;/a&gt; 等保证密码学安全的库里的随机数发生器。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-敏感数据泄露&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;45--必须自己实现的rand范围不应过小&#34;&gt;4.5  【必须】自己实现的rand范围不应过小&lt;/h4&gt;
&lt;p&gt;如果在弱安全场景相关的算法中自己实现了PRNG，请确保rand出来的随机数不会很小或可预测。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Bad
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1103515245U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12345U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;999999&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;上述例子可能想生成0~999999共100万种可能的随机数，但是999999的二进制是11110100001000111111，与&amp;amp;运算后，0位一直是0，所以生成出的范围明显会小于100万种。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1103515245U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12345U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1000000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Good
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int32_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1103515245U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12345U&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0x7fffffff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;文件操作&#34;&gt;文件操作&lt;/h3&gt;
&lt;h4 id=&#34;必须避免路径穿越问题&#34;&gt;【必须】避免路径穿越问题&lt;/h4&gt;
&lt;p&gt;在进行文件操作时，需要判断外部传入的文件名是否合法，如果文件名中包含 &lt;code&gt;../&lt;/code&gt; 等特殊字符，则会造成路径穿越，导致任意文件的读写。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PATH_MAX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/home/user/code/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 如果传入的文件名包含../可导致路径穿越
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 例如&amp;#34;../file.txt&amp;#34;，则可以读取到上层目录的file.txt文件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;../file.txt&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;O_RDONLY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;memset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STDOUT_FILENO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PATH_MAX&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/home/user/code/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;../file.txt&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 判断传入的文件名是否非法，例如&amp;#34;../file.txt&amp;#34;中包含非法字符../，直接返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strstr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;..&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;){&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 包含非法字符
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;file_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;O_RDONLY&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;memset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;STDOUT_FILENO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fd&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须避免相对路径导致的安全问题dllexe劫持等问题&#34;&gt;【必须】避免相对路径导致的安全问题（DLL、EXE劫持等问题）&lt;/h4&gt;
&lt;p&gt;在程序中，使用相对路径可能导致一些安全风险，例如DLL、EXE劫持等问题。&lt;/p&gt;
&lt;p&gt;例如以下代码，可能存在劫持问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 传入的是dll文件名，如果当前目录下被写入了恶意的同名dll，则可能导致dll劫持
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;HINSTANCE&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hinst&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LoadLibrary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;dll_nolib.dll&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;hinst&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;cout&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;dll loaded!&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;endl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;针对DLL劫持的安全编码的规范：&lt;/p&gt;
&lt;p&gt;1）调用LoadLibrary，LoadLibraryEx，CreateProcess，ShellExecute等进行模块加载的函数时，指明模块的完整（全）路径，禁止使用相对路径，这样就可避免从其它目录加载DLL。
2）在应用程序的开头调用SetDllDirectory(TEXT(&amp;quot;&amp;quot;)); 从而将当前目录从DLL的搜索列表中删除。结合SetDefaultDllDirectories，AddDllDirectory，RemoveDllDirectory这几个API配合使用，可以有效的规避DLL劫持问题。这些API只能在打了KB2533623补丁的Windows7，2008上使用。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须文件权限控制&#34;&gt;【必须】文件权限控制&lt;/h4&gt;
&lt;p&gt;在创建文件时，需要根据文件的敏感级别设置不同的访问权限，以防止敏感数据被其他恶意程序读取或写入。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 不要设置为777权限，以防止被其他恶意程序操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;creat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;file.txt&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mo&#34;&gt;0777&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;文件创建失败！&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;文件创建成功！&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;内存操作&#34;&gt;内存操作&lt;/h3&gt;
&lt;h4 id=&#34;必须防止各种越界写向前向后&#34;&gt;【必须】防止各种越界写（向前/向后）&lt;/h4&gt;
&lt;p&gt;错误1：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;错误2：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_controlled_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须防止任意地址写&#34;&gt;【必须】防止任意地址写&lt;/h4&gt;
&lt;p&gt;任意地址写会导致严重的安全隐患，可能导致代码执行。因此，在编码时必须校验写入的地址。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;MyStruct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dst_struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dst_struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;MyStruct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dst_stuct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;dst_stuct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;user_controlled_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dst_stuct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;数字操作&#34;&gt;数字操作&lt;/h3&gt;
&lt;h4 id=&#34;必须防止整数溢出&#34;&gt;【必须】防止整数溢出&lt;/h4&gt;
&lt;p&gt;在计算时需要考虑整数溢出的可能，尤其在进行内存操作时，需要对分配、拷贝等大小进行合法校验，防止整数溢出导致的漏洞。&lt;/p&gt;
&lt;p&gt;错误（该例子在计算时产生整数溢出）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kMicLen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 整数溢出
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// Bad, 由于len小于4字节，导致计算拷贝长度时，整数溢出
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// len - MIC_LEN == 0xfffffffd
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kMicLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;dst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;kMicLen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 拷贝前对长度进行判断
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;payload&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;memcpy good&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须防止off-by-one&#34;&gt;【必须】防止Off-By-One&lt;/h4&gt;
&lt;p&gt;在进行计算或者操作时，如果使用的最大值或最小值不正确，使得该值比正确值多1或少1，可能导致安全风险。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;strncat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 第二次调用strncat()可能会追加另外20个字符。如果这20个字符没有终止空字符，则存在安全问题
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strncat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;40&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 当使用像strncat()函数时，必须在缓冲区的末尾为终止空字符留下一个空字节，避免off-by-one
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;strncat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;firstname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;strncat&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;strlen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fullname&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 C++ 代码，再次强烈建议使用 &lt;code&gt;string&lt;/code&gt;、&lt;code&gt;vector&lt;/code&gt; 等组件代替原始指针和数组操作。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须避免大小端错误&#34;&gt;【必须】避免大小端错误&lt;/h4&gt;
&lt;p&gt;在一些涉及大小端数据处理的场景，需要进行大小端判断，例如从大端设备取出的值，要以大端进行处理，避免端序错误使用。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须检查除以零异常&#34;&gt;【必须】检查除以零异常&lt;/h4&gt;
&lt;p&gt;在进行除法运算时，需要判断被除数是否为零，以防导致程序不符合预期或者崩溃。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;divide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;divide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;divide&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;double&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DivideByZero&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;低风险-拒绝服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须防止数字类型的错误强转&#34;&gt;【必须】防止数字类型的错误强转&lt;/h4&gt;
&lt;p&gt;在有符号和无符号数字参与的运算中，需要注意类型强转可能导致的逻辑错误，建议指定参与计算时数字的类型或者统一类型参与计算。&lt;/p&gt;
&lt;p&gt;错误例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 1 &amp;lt; 9 - 10 ? 由于运算中无符号和有符号混用，导致计算结果以无符号计算
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Bad&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Good&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 统一两者计算类型为有符号
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;len&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Bad&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Good&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须比较数据大小时加上最小最大值的校验&#34;&gt;【必须】比较数据大小时加上最小/最大值的校验&lt;/h4&gt;
&lt;p&gt;在进行数据大小比较时，要合理地校验数据的区间范围，建议根据数字类型，对其进行最大和最小值的判断，以防止非预期错误。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 此处index是int型，只考虑了index小于数组大小，但是并未判断是否大于0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果index为负数，则越界
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 判断index的最大最小值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;指针操作&#34;&gt;指针操作&lt;/h3&gt;
&lt;h4 id=&#34;建议检查在pointer上使用sizeof&#34;&gt;【建议】检查在pointer上使用sizeof&lt;/h4&gt;
&lt;p&gt;除了测试当前指针长度，否则一般不会在pointer上使用sizeof。&lt;/p&gt;
&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pointer_length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可能错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;structure_length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可能是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;n&#34;&gt;size_t&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;structure_length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须检查直接将数组和0比较的代码&#34;&gt;【必须】检查直接将数组和0比较的代码&lt;/h4&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;该判断永远为真，等价于:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;可能是：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;开启足够的编译器警告（GCC 中为 &lt;code&gt;-Waddress&lt;/code&gt;，并已包含在 &lt;code&gt;-Wall&lt;/code&gt; 中），并设置为错误，可以在编译期间发现该问题。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;中风险-逻辑漏洞&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须不应当向指针赋予写死的地址&#34;&gt;【必须】不应当向指针赋予写死的地址&lt;/h4&gt;
&lt;p&gt;特殊情况需要特殊对待（比如开发硬件固件时可能需要写死）&lt;/p&gt;
&lt;p&gt;但是如果是系统驱动开发之类的，写死可能会导致后续的问题。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须检查空指针&#34;&gt;【必须】检查空指针&lt;/h4&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;ERROR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;foobar&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;ERROR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;foobar&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;foo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bar&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;sc&#34;&gt;&amp;#39;\0&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;...;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;低风险-拒绝服务&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须释放完后置空指针&#34;&gt;【必须】释放完后置空指针&lt;/h4&gt;
&lt;p&gt;在对指针进行释放后，需要将该指针设置为NULL，以防止后续free指针的误用，导致UAF等其他内存破坏问题。尤其是在结构体、类里面存储的原始指针。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 此时p所指向的内存已被释放，但是p所指的地址仍然不变
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 未设置为NULL，可能导致UAF等内存错误
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 没有起到防错作用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 错误使用已经释放的内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;malloc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;memcpy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 此时p所指向的内存已被释放，但是p所指的地址仍然不变
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;free&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//释放后将指针赋值为空
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 没有起到防错作用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 错误使用已经释放的内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;对于 C++ 代码，使用 string、vector、智能指针等代替原始内存管理机制，可以大量减少这类错误。&lt;/p&gt;
&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须防止错误的类型转换type-confusion&#34;&gt;【必须】防止错误的类型转换（type confusion）&lt;/h4&gt;
&lt;p&gt;在对指针、对象或变量进行操作时，需要能够正确判断所操作对象的原始类型。如果使用了与原始类型不兼容的类型进行访问，则存在安全隐患。&lt;/p&gt;
&lt;p&gt;错误：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NAME_TYPE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ID_TYPE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 该类型根据 msg_type 进行区分，如果在对MessageBuffer进行操作时没有判断目标对象，则存在类型混淆
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MessageBuffer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg_type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;union&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MessageBuffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;default_message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NAME_TYPE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;default_message&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Pointer of buf.name is %p&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 没有判断目标消息类型是否为ID_TYPE，直接修改nameID，导致类型混淆
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_controlled_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NAME_TYPE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Pointer of buf.name is now %p&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 以NAME_TYPE作为类型操作，可能导致非法内存读写
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Message: %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Message: Use ID %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确（判断操作的目标是否是预期类型）：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MessageBuffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;char&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;default_message&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 设置该消息类型为 NAME_TYPE，因此buf预期的类型为 msg_type + name
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NAME_TYPE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;default_msessage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Pointer of buf.name is %p&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 判断目标消息类型是否为 ID_TYPE，不是预期类型则做对应操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ID_TYPE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_id&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;user_controlled_value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;msg_type&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NAME_TYPE&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Pointer of buf.name is now %p&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Message: %s&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Message: Use ID %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h4 id=&#34;必须智能指针使用安全&#34;&gt;【必须】智能指针使用安全&lt;/h4&gt;
&lt;p&gt;在使用智能指针时，防止其和原始指针的混用，否则可能导致对象生命周期问题，例如 UAF 等安全风险。&lt;/p&gt;
&lt;p&gt;错误例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Foo&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
 &lt;span class=&#34;k&#34;&gt;public&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;explicit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Obj is %p, data = %d&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
 &lt;span class=&#34;k&#34;&gt;private&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;data_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;std&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;::&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;unique_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pfool_raw_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;nullptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Risk&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 从独占智能指针中获取原始指针,&amp;lt;Foo&amp;gt;(1)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;pfool_raw_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 调用&amp;lt;Foo&amp;gt;(1)的函数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;pfool_raw_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 独占智能指针重新赋值后会释放内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 通过原始指针操作会导致UAF，pfool_raw_ptr指向的对象已经释放
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;pfool_raw_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;


&lt;span class=&#34;c1&#34;&gt;// 输出：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Obj is 0000027943087B80, data = 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Obj is 0000027943087B80, data = -572662307
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;正确，通过智能指针操作:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c++&#34; data-lang=&#34;c++&#34;&gt;&lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Safe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 调用&amp;lt;Foo&amp;gt;(1)的函数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;

  &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;make_unique&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Foo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 调用&amp;lt;Foo&amp;gt;(2)的函数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;fool_u_ptr&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;function&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 输出：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Obj is 000002C7BB550830, data = 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// Obj is 000002C7BB557AF0, data = 2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;关联漏洞:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;高风险-内存破坏&lt;/code&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go安全指南</title>
        <link>https://zcj-git520.github.io/p/go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</link>
        <pubDate>Sun, 24 Oct 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/go%E5%AE%89%E5%85%A8%E6%8C%87%E5%8D%97/1.jpg" alt="Featured image of post Go安全指南" /&gt;&lt;h2 id=&#34;文章来源&#34;&gt;文章来源&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Tencent/secguide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;鹅厂(腾讯)代码安全指南&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;通用&#34;&gt;通用&lt;/h2&gt;
&lt;h3 id=&#34;内存管理&#34;&gt;内存管理&lt;/h3&gt;
&lt;h4 id=&#34;必须切片长度校验&#34;&gt;【必须】切片长度校验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在对slice进行操作时，必须判断长度是否合法，防止程序panic&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad: 未判断data的长度，可导致 index out of range
func decode(data []byte) bool {
	if data[0] == &#39;F&#39; &amp;amp;&amp;amp; data[1] == &#39;U&#39; &amp;amp;&amp;amp; data[2] == &#39;Z&#39; &amp;amp;&amp;amp; data[3] == &#39;Z&#39; &amp;amp;&amp;amp; data[4] == &#39;E&#39; &amp;amp;&amp;amp; data[5] == &#39;R&#39; {
		fmt.Println(&amp;quot;Bad&amp;quot;)
		return true
	}
	return false
}

// bad: slice bounds out of range
func foo() {
	var slice = []int{0, 1, 2, 3, 4, 5, 6}
	fmt.Println(slice[:10])
}

// good: 使用data前应判断长度是否合法
func decode(data []byte) bool {
	if len(data) == 6 {
		if data[0] == &#39;F&#39; &amp;amp;&amp;amp; data[1] == &#39;U&#39; &amp;amp;&amp;amp; data[2] == &#39;Z&#39; &amp;amp;&amp;amp; data[3] == &#39;Z&#39; &amp;amp;&amp;amp; data[4] == &#39;E&#39; &amp;amp;&amp;amp; data[5] == &#39;R&#39; {
			fmt.Println(&amp;quot;Good&amp;quot;)
			return true
		}
	}
	return false
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须nil指针判断&#34;&gt;【必须】nil指针判断&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;进行指针操作时，必须判断该指针是否为nil，防止程序panic，尤其在进行结构体Unmarshal时&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type Packet struct {
	PackeyType    uint8
	PackeyVersion uint8
	Data          *Data
}

type Data struct {
	Stat uint8
	Len  uint8
	Buf  [8]byte
}

func (p *Packet) UnmarshalBinary(b []byte) error {
	if len(b) &amp;lt; 2 {
		return io.EOF
	}

	p.PackeyType = b[0]
	p.PackeyVersion = b[1]

	// 若长度等于2，那么不会new Data
	if len(b) &amp;gt; 2 {
		p.Data = new(Data)
	}
	return nil
}

// bad: 未判断指针是否为nil
func main() {
	packet := new(Packet)
	data := make([]byte, 2)
	if err := packet.UnmarshalBinary(data); err != nil {
		fmt.Println(&amp;quot;Failed to unmarshal packet&amp;quot;)
		return
	}

	fmt.Printf(&amp;quot;Stat: %v\n&amp;quot;, packet.Data.Stat)
}

// good: 判断Data指针是否为nil
func main() {
	packet := new(Packet)
	data := make([]byte, 2)

	if err := packet.UnmarshalBinary(data); err != nil {
		fmt.Println(&amp;quot;Failed to unmarshal packet&amp;quot;)
		return
	}

	if packet.Data == nil {
		return
	}

	fmt.Printf(&amp;quot;Stat: %v\n&amp;quot;, packet.Data.Stat)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须整数安全&#34;&gt;【必须】整数安全&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在进行数字运算操作时，需要做好长度限制，防止外部输入运算导致异常：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保无符号整数运算时不会反转&lt;/li&gt;
&lt;li&gt;确保有符号整数运算时不会出现溢出&lt;/li&gt;
&lt;li&gt;确保整型转换时不会出现截断错误&lt;/li&gt;
&lt;li&gt;确保整型转换时不会出现符号错误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;以下场景必须严格进行长度限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为数组索引&lt;/li&gt;
&lt;li&gt;作为对象的长度或者大小&lt;/li&gt;
&lt;li&gt;作为数组的边界（如作为循环计数器）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad: 未限制长度，导致整数溢出
func overflow(numControlByUser int32) {
	var numInt int32 = 0
	numInt = numControlByUser + 1
	// 对长度限制不当，导致整数溢出
	fmt.Printf(&amp;quot;%d\n&amp;quot;, numInt)
	// 使用numInt，可能导致其他错误
}

func main() {
	overflow(2147483647)
}

// good
func overflow(numControlByUser int32) {
	var numInt int32 = 0
	numInt = numControlByUser + 1
	if numInt &amp;lt; 0 {
		fmt.Println(&amp;quot;integer overflow&amp;quot;)
		return
	}
	fmt.Println(&amp;quot;integer ok&amp;quot;)
}

func main() {
	overflow(2147483647)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须make分配长度验证&#34;&gt;【必须】make分配长度验证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在进行make分配内存时，需要对外部可控的长度进行校验，防止程序panic。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func parse(lenControlByUser int, data []byte) {
	size := lenControlByUser
	// 对外部传入的size，进行长度判断以免导致panic
	buffer := make([]byte, size)
	copy(buffer, data)
}

// good
func parse(lenControlByUser int, data []byte) ([]byte, error) {
	size := lenControlByUser
	// 限制外部可控的长度大小范围
	if size &amp;gt; 64*1024*1024 {
		return nil, errors.New(&amp;quot;value too large&amp;quot;)
	}
	buffer := make([]byte, size)
	copy(buffer, data)
	return buffer, nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须禁止setfinalizer和指针循环引用同时使用&#34;&gt;【必须】禁止SetFinalizer和指针循环引用同时使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;当一个对象从被GC选中到移除内存之前，runtime.SetFinalizer()都不会执行，即使程序正常结束或者发生错误。由指针构成的“循环引用”虽然能被GC正确处理，但由于无法确定Finalizer依赖顺序，从而无法调用runtime.SetFinalizer()，导致目标对象无法变成可达状态，从而造成内存无法被回收。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func foo() {
	var a, b Data
	a.o = &amp;amp;b
	b.o = &amp;amp;a

	// 指针循环引用，SetFinalizer()无法正常调用
	runtime.SetFinalizer(&amp;amp;a, func(d *Data) {
		fmt.Printf(&amp;quot;a %p final.\n&amp;quot;, d)
	})
	runtime.SetFinalizer(&amp;amp;b, func(d *Data) {
		fmt.Printf(&amp;quot;b %p final.\n&amp;quot;, d)
	})
}

func main() {
	for {
		foo()
		time.Sleep(time.Millisecond)
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须禁止重复释放channel&#34;&gt;【必须】禁止重复释放channel&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;重复释放一般存在于异常流程判断中，如果恶意攻击者构造出异常条件使程序重复释放channel，则会触发运行时panic，从而造成DoS攻击。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func foo(c chan int) {
	defer close(c)
	err := processBusiness()
	if err != nil {
		c &amp;lt;- 0
		close(c) // 重复释放channel
		return
	}
	c &amp;lt;- 1
}

// good
func foo(c chan int) {
	defer close(c) // 使用defer延迟关闭channel
	err := processBusiness()
	if err != nil {
		c &amp;lt;- 0
		return
	}
	c &amp;lt;- 1
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须确保每个协程都能退出&#34;&gt;【必须】确保每个协程都能退出&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;启动一个协程就会做一个入栈操作，在系统不退出的情况下，协程也没有设置退出条件，则相当于协程失去了控制，它占用的资源无法回收，可能会导致内存泄露。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad: 协程没有设置退出条件
func doWaiter(name string, second int) {
	for {
		time.Sleep(time.Duration(second) * time.Second)
		fmt.Println(name, &amp;quot; is ready!&amp;quot;)
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;推荐不使用unsafe包&#34;&gt;【推荐】不使用unsafe包&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;由于unsafe包绕过了 Golang 的内存安全原则，一般来说使用该库是不安全的，可导致内存破坏，尽量避免使用该包。若必须要使用unsafe操作指针，必须做好安全校验。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad: 通过unsafe操作原始指针
func unsafePointer() {
	b := make([]byte, 1)
	foo := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&amp;amp;b[0])) + uintptr(0xfffffffe)))
	fmt.Print(*foo + 1)
}

// [signal SIGSEGV: segmentation violation code=0x1 addr=0xc100068f55 pc=0x49142b]

&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;推荐不使用slice作为函数入参&#34;&gt;【推荐】不使用slice作为函数入参&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;slice是引用类型，在作为函数入参时采用的是地址传递，对slice的修改也会影响原始数据&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad: slice作为函数入参时是地址传递
func modify(array []int) {
	array[0] = 10 // 对入参slice的元素修改会影响原始数据
}

func main() {
	array := []int{1, 2, 3, 4, 5}

	modify(array)
	fmt.Println(array) // output：[10 2 3 4 5]
}

// good: 函数使用数组作为入参，而不是slice
func modify(array [5]int) {
	array[0] = 10
}

func main() {
	// 传入数组，注意数组与slice的区别
	array := [5]int{1, 2, 3, 4, 5}

	modify(array)
	fmt.Println(array)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;文件操作&#34;&gt;文件操作&lt;/h3&gt;
&lt;h4 id=&#34;必须-路径穿越检查&#34;&gt;【必须】 路径穿越检查&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在进行文件操作时，如果对外部传入的文件名未做限制，可能导致任意文件读取或者任意文件写入，严重可能导致代码执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad: 任意文件读取
func handler(w http.ResponseWriter, r *http.Request) {
	path := r.URL.Query()[&amp;quot;path&amp;quot;][0]

	// 未过滤文件路径，可能导致任意文件读取
	data, _ := ioutil.ReadFile(path)
	w.Write(data)

	// 对外部传入的文件名变量，还需要验证是否存在../等路径穿越的文件名
	data, _ = ioutil.ReadFile(filepath.Join(&amp;quot;/home/user/&amp;quot;, path))
	w.Write(data)
}

// bad: 任意文件写入
func unzip(f string) {
	r, _ := zip.OpenReader(f)
	for _, f := range r.File {
		p, _ := filepath.Abs(f.Name)
		// 未验证压缩文件名，可能导致../等路径穿越，任意文件路径写入
		ioutil.WriteFile(p, []byte(&amp;quot;present&amp;quot;), 0640)
	}
}

// good: 检查压缩的文件名是否包含..路径穿越特征字符，防止任意写入
func unzipGood(f string) bool {
	r, err := zip.OpenReader(f)
	if err != nil {
		fmt.Println(&amp;quot;read zip file fail&amp;quot;)
		return false
	}
	for _, f := range r.File {
		if !strings.Contains(f.Name, &amp;quot;..&amp;quot;) {
			p, _ := filepath.Abs(f.Name)
			ioutil.WriteFile(p, []byte(&amp;quot;present&amp;quot;), 0640)
		} else {
			return false
		}
	}
	return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须-文件访问权限&#34;&gt;【必须】 文件访问权限&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;根据创建文件的敏感性设置不同级别的访问权限，以防止敏感数据被任意权限用户读取。例如，设置文件权限为：&lt;code&gt;-rw-r-----&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;ioutil.WriteFile(p, []byte(&amp;quot;present&amp;quot;), 0640)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;系统接口&#34;&gt;系统接口&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1.3.1【必须】命令执行检查&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;exec.Command&lt;/code&gt;、&lt;code&gt;exec.CommandContext&lt;/code&gt;、&lt;code&gt;syscall.StartProcess&lt;/code&gt;、&lt;code&gt;os.StartProcess&lt;/code&gt;等函数时，第一个参数（path）直接取外部输入值时，应使用白名单限定可执行的命令范围，不允许传入&lt;code&gt;bash&lt;/code&gt;、&lt;code&gt;cmd&lt;/code&gt;、&lt;code&gt;sh&lt;/code&gt;等命令；&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;exec.Command&lt;/code&gt;、&lt;code&gt;exec.CommandContext&lt;/code&gt;等函数时，通过&lt;code&gt;bash&lt;/code&gt;、&lt;code&gt;cmd&lt;/code&gt;、&lt;code&gt;sh&lt;/code&gt;等创建shell，-c后的参数（arg）拼接外部输入，应过滤\n  $  &amp;amp;  ;  |  &#39;  &amp;quot;  ( )  `等潜在恶意字符；&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func foo() {
	userInputedVal := &amp;quot;&amp;amp;&amp;amp; echo &#39;hello&#39;&amp;quot; // 假设外部传入该变量值
	cmdName := &amp;quot;ping &amp;quot; + userInputedVal

	// 未判断外部输入是否存在命令注入字符，结合sh可造成命令注入
	cmd := exec.Command(&amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, cmdName)
	output, _ := cmd.CombinedOutput()
	fmt.Println(string(output))

	cmdName := &amp;quot;ls&amp;quot;
	// 未判断外部输入是否是预期命令
	cmd := exec.Command(cmdName)
	output, _ := cmd.CombinedOutput()
	fmt.Println(string(output))
}

// good
func checkIllegal(cmdName string) bool {
	if strings.Contains(cmdName, &amp;quot;&amp;amp;&amp;quot;) || strings.Contains(cmdName, &amp;quot;|&amp;quot;) || strings.Contains(cmdName, &amp;quot;;&amp;quot;) ||
		strings.Contains(cmdName, &amp;quot;$&amp;quot;) || strings.Contains(cmdName, &amp;quot;&#39;&amp;quot;) || strings.Contains(cmdName, &amp;quot;`&amp;quot;) ||
		strings.Contains(cmdName, &amp;quot;(&amp;quot;) || strings.Contains(cmdName, &amp;quot;)&amp;quot;) || strings.Contains(cmdName, &amp;quot;\&amp;quot;&amp;quot;) {
		return true
	}
	return false
}

func main() {
	userInputedVal := &amp;quot;&amp;amp;&amp;amp; echo &#39;hello&#39;&amp;quot;
	cmdName := &amp;quot;ping &amp;quot; + userInputedVal

	if checkIllegal(cmdName) { // 检查传给sh的命令是否有特殊字符
		return // 存在特殊字符直接return
	}

	cmd := exec.Command(&amp;quot;sh&amp;quot;, &amp;quot;-c&amp;quot;, cmdName)
	output, _ := cmd.CombinedOutput()
	fmt.Println(string(output))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;通信安全&#34;&gt;通信安全&lt;/h3&gt;
&lt;h4 id=&#34;必须网络通信采用tls方式&#34;&gt;【必须】网络通信采用TLS方式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;明文传输的通信协议目前已被验证存在较大安全风险，被中间人劫持后可能导致许多安全风险，因此必须采用至少TLS的安全通信方式保证通信安全，例如gRPC/Websocket都使用TLS1.3。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// good
func main() {
	http.HandleFunc(&amp;quot;/&amp;quot;, func(w http.ResponseWriter, req *http.Request) {
		w.Header().Add(&amp;quot;Strict-Transport-Security&amp;quot;, &amp;quot;max-age=63072000; includeSubDomains&amp;quot;)
		w.Write([]byte(&amp;quot;This is an example server.\n&amp;quot;))
	})

	// 服务器配置证书与私钥
	log.Fatal(http.ListenAndServeTLS(&amp;quot;:443&amp;quot;, &amp;quot;yourCert.pem&amp;quot;, &amp;quot;yourKey.pem&amp;quot;, nil))
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;推荐tls启用证书验证&#34;&gt;【推荐】TLS启用证书验证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;TLS证书应当是有效的、未过期的，且配置正确的域名，生产环境的服务端应启用证书验证。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
import (
	&amp;quot;crypto/tls&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func doAuthReq(authReq *http.Request) *http.Response {
	tr := &amp;amp;http.Transport{
		TLSClientConfig: &amp;amp;tls.Config{InsecureSkipVerify: true},
	}
	client := &amp;amp;http.Client{Transport: tr}
	res, _ := client.Do(authReq)
	return res
}

// good
import (
	&amp;quot;crypto/tls&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func doAuthReq(authReq *http.Request) *http.Response {
	tr := &amp;amp;http.Transport{
		TLSClientConfig: &amp;amp;tls.Config{InsecureSkipVerify: false},
	}
	client := &amp;amp;http.Client{Transport: tr}
	res, _ := client.Do(authReq)
	return res
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;敏感数据保护&#34;&gt;敏感数据保护&lt;/h3&gt;
&lt;h4 id=&#34;必须敏感信息访问&#34;&gt;【必须】敏感信息访问&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;禁止将敏感信息硬编码在程序中，既可能会将敏感信息暴露给攻击者，也会增加代码管理和维护的难度&lt;/li&gt;
&lt;li&gt;使用配置中心系统统一托管密钥等敏感信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须敏感数据输出&#34;&gt;【必须】敏感数据输出&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;只输出必要的最小数据集，避免多余字段暴露引起敏感信息泄露&lt;/li&gt;
&lt;li&gt;不能在日志保存密码（包括明文密码和密文密码）、密钥和其它敏感信息&lt;/li&gt;
&lt;li&gt;对于必须输出的敏感信息，必须进行合理脱敏展示&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func serve() {
	http.HandleFunc(&amp;quot;/register&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		r.ParseForm()
		user := r.Form.Get(&amp;quot;user&amp;quot;)
		pw := r.Form.Get(&amp;quot;password&amp;quot;)

		log.Printf(&amp;quot;Registering new user %s with password %s.\n&amp;quot;, user, pw)
	})
	http.ListenAndServe(&amp;quot;:80&amp;quot;, nil)
}

// good
func serve1() {
	http.HandleFunc(&amp;quot;/register&amp;quot;, func(w http.ResponseWriter, r *http.Request) {
		r.ParseForm()
		user := r.Form.Get(&amp;quot;user&amp;quot;)
		pw := r.Form.Get(&amp;quot;password&amp;quot;)

		log.Printf(&amp;quot;Registering new user %s.\n&amp;quot;, user)

		// ...
		use(pw)
	})
	http.ListenAndServe(&amp;quot;:80&amp;quot;, nil)
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;避免通过GET方法、代码注释、自动填充、缓存等方式泄露敏感信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须敏感数据存储&#34;&gt;【必须】敏感数据存储&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;敏感数据应使用SHA2、RSA等算法进行加密存储&lt;/li&gt;
&lt;li&gt;敏感数据应使用独立的存储层，并在访问层开启访问控制&lt;/li&gt;
&lt;li&gt;包含敏感信息的临时文件或缓存一旦不再需要应立刻删除&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须异常处理和日志记录&#34;&gt;【必须】异常处理和日志记录&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;应合理使用panic、recover、defer处理系统异常，避免出错信息输出到前端&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;defer func () {
	if r := recover(); r != nil {
		fmt.Println(&amp;quot;Recovered in start()&amp;quot;)
	}
}()
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;对外环境禁止开启debug模式，或将程序运行日志输出到前端&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;// bad
dlv --listen&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;:2345 --headless&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;true&lt;/span&gt; --api-version&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt; debug test.go
// good
dlv debug test.go
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;加密解密&#34;&gt;加密解密&lt;/h3&gt;
&lt;h4 id=&#34;必须不得硬编码密码密钥&#34;&gt;【必须】不得硬编码密码/密钥&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在进行用户登陆，加解密算法等操作时，不得在代码里硬编码密钥或密码，可通过变换算法或者配置等方式设置密码或者密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
const (
	user     = &amp;quot;dbuser&amp;quot;
	password = &amp;quot;s3cretp4ssword&amp;quot;
)

func connect() *sql.DB {
	connStr := fmt.Sprintf(&amp;quot;postgres://%s:%s@localhost/pqgotest&amp;quot;, user, password)
	db, err := sql.Open(&amp;quot;postgres&amp;quot;, connStr)
	if err != nil {
		return nil
	}
	return db
}

// bad
var (
	commonkey = []byte(&amp;quot;0123456789abcdef&amp;quot;)
)

func AesEncrypt(plaintext string) (string, error) {
	block, err := aes.NewCipher(commonkey)
	if err != nil {
		return &amp;quot;&amp;quot;, err
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;162必须密钥存储安全&#34;&gt;1.6.2【必须】密钥存储安全&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在使用对称密码算法时，需要保护好加密密钥。当算法涉及敏感、业务数据时，可通过非对称算法协商加密密钥。其他较为不敏感的数据加密，可以通过变换算法等方式保护密钥。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;163推荐不使用弱密码算法&#34;&gt;1.6.3【推荐】不使用弱密码算法&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在使用加密算法时，不建议使用加密强度较弱的算法。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
crypto/des，crypto/md5，crypto/sha1，crypto/rc4等。

// good
crypto/rsa，crypto/aes等。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;正则表达式&#34;&gt;正则表达式&lt;/h3&gt;
&lt;h4 id=&#34;推荐使用regexp进行正则表达式匹配&#34;&gt;【推荐】使用regexp进行正则表达式匹配&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;正则表达式编写不恰当可被用于DoS攻击，造成服务不可用，推荐使用regexp包进行正则表达式匹配。regexp保证了线性时间性能和优雅的失败：对解析器、编译器和执行引擎都进行了内存限制。但regexp不支持以下正则表达式特性，如业务依赖这些特性，则regexp不适合使用。
&lt;ul&gt;
&lt;li&gt;回溯引用&lt;a class=&#34;link&#34; href=&#34;https://www.regular-expressions.info/backref.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Backreferences&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;查看&lt;a class=&#34;link&#34; href=&#34;https://www.regular-expressions.info/lookaround.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Lookaround&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// good
matched, err := regexp.MatchString(`a.b`, &amp;quot;aaxbb&amp;quot;)
fmt.Println(matched) // true
fmt.Println(err)     // nil
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h2 id=&#34;后台&#34;&gt;后台&lt;/h2&gt;
&lt;h3 id=&#34;输入校验&#34;&gt;输入校验&lt;/h3&gt;
&lt;h4 id=&#34;必须按类型进行数据校验&#34;&gt;【必须】按类型进行数据校验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;所有外部输入的参数，应使用&lt;code&gt;validator&lt;/code&gt;进行白名单校验，校验内容包括但不限于数据长度、数据范围、数据类型与格式，校验不通过的应当拒绝&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// good
import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;github.com/go-playground/validator/v10&amp;quot;
)

var validate *validator.Validate

func validateVariable() {
	myEmail := &amp;quot;abc@tencent.com&amp;quot;
	errs := validate.Var(myEmail, &amp;quot;required,email&amp;quot;)
	if errs != nil {
		fmt.Println(errs)
		return
		//停止执行
	}
	// 验证通过，继续执行
	...
}

func main() {
	validate = validator.New()
	validateVariable()
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;无法通过白名单校验的应使用&lt;code&gt;html.EscapeString&lt;/code&gt;、&lt;code&gt;text/template&lt;/code&gt;或&lt;code&gt;bluemonday&lt;/code&gt;对&lt;code&gt;&amp;lt;, &amp;gt;, &amp;amp;, &#39;,&amp;quot;&lt;/code&gt;等字符进行过滤或编码&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;text/template&amp;quot;
)

// TestHTMLEscapeString HTML特殊字符转义
func main(inputValue string) string {
	escapedResult := template.HTMLEscapeString(inputValue)
	return escapedResult
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;sql操作&#34;&gt;SQL操作&lt;/h3&gt;
&lt;h4 id=&#34;必须sql语句默认使用预编译并绑定变量&#34;&gt;【必须】SQL语句默认使用预编译并绑定变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;database/sql&lt;/code&gt;的prepare、Query或使用GORM等ORM执行SQL操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;github.com/jinzhu/gorm&amp;quot;
	_ &amp;quot;github.com/jinzhu/gorm/dialects/sqlite&amp;quot;
)

type Product struct {
	gorm.Model
	Code  string
	Price uint
}

...
var product Product
...
db.First(&amp;amp;product, 1)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用参数化查询，禁止拼接SQL语句，另外对于传入参数用于order by或表名的需要通过校验&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
import (
	&amp;quot;database/sql&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func handler(db *sql.DB, req *http.Request) {
	q := fmt.Sprintf(&amp;quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#39;%s&#39; ORDER BY PRICE&amp;quot;,
		req.URL.Query()[&amp;quot;category&amp;quot;])
	db.Query(q)
}

// good
func handlerGood(db *sql.DB, req *http.Request) {
	// 使用?占位符
	q := &amp;quot;SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=&#39;?&#39; ORDER BY PRICE&amp;quot;
	db.Query(q, req.URL.Query()[&amp;quot;category&amp;quot;])
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;网络请求&#34;&gt;网络请求&lt;/h3&gt;
&lt;h4 id=&#34;必须资源请求过滤验证&#34;&gt;【必须】资源请求过滤验证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;&amp;quot;net/http&amp;quot;&lt;/code&gt;下的方法&lt;code&gt;http.Get(url)&lt;/code&gt;、&lt;code&gt;http.Post(url, contentType, body)&lt;/code&gt;、&lt;code&gt;http.Head(url)&lt;/code&gt;、&lt;code&gt;http.PostForm(url, data)&lt;/code&gt;、&lt;code&gt;http.Do(req)&lt;/code&gt;时，如变量值外部可控（指从参数中动态获取），应对请求目标进行严格的安全校验。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如请求资源域名归属固定的范围，如只允许&lt;code&gt;a.qq.com&lt;/code&gt;和&lt;code&gt;b.qq.com&lt;/code&gt;，应做白名单限制。如不适用白名单，则推荐的校验逻辑步骤是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第 1 步、只允许HTTP或HTTPS协议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 2 步、解析目标URL，获取其HOST&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 3 步、解析HOST，获取HOST指向的IP地址转换成Long型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 4 步、检查IP地址是否为内网IP，网段有：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 以RFC定义的专有网络为例，如有自定义私有网段亦应加入禁止访问列表。
10.0.0.0/8
172.16.0.0/12
192.168.0.0/16
127.0.0.0/8
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 5 步、请求URL&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第 6 步、如有跳转，跳转后执行1，否则绑定经校验的ip和域名，对URL发起请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;官方库&lt;code&gt;encoding/xml&lt;/code&gt;不支持外部实体引用，使用该库可避免xxe漏洞&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;encoding/xml&amp;quot;
	&amp;quot;fmt&amp;quot;
	&amp;quot;os&amp;quot;
)

func main() {
	type Person struct {
		XMLName  xml.Name `xml:&amp;quot;person&amp;quot;`
		Id       int      `xml:&amp;quot;id,attr&amp;quot;`
		UserName string   `xml:&amp;quot;name&amp;gt;first&amp;quot;`
		Comment  string   `xml:&amp;quot;,comment&amp;quot;`
	}

	v := &amp;amp;Person{Id: 13, UserName: &amp;quot;John&amp;quot;}
	v.Comment = &amp;quot; Need more details. &amp;quot;

	enc := xml.NewEncoder(os.Stdout)
	enc.Indent(&amp;quot;  &amp;quot;, &amp;quot;    &amp;quot;)
	if err := enc.Encode(v); err != nil {
		fmt.Printf(&amp;quot;error: %v\n&amp;quot;, err)
	}

}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;服务器端渲染&#34;&gt;服务器端渲染&lt;/h3&gt;
&lt;h4 id=&#34;必须模板渲染过滤验证&#34;&gt;【必须】模板渲染过滤验证&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;text/template&lt;/code&gt;或者&lt;code&gt;html/template&lt;/code&gt;渲染模板时禁止将外部输入参数引入模板，或仅允许引入白名单内字符。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func handler(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	x := r.Form.Get(&amp;quot;name&amp;quot;)

	var tmpl = `&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;
    &amp;lt;form action=&amp;quot;/&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
        First name:&amp;lt;br&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;
    &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot;&amp;gt;
    &amp;lt;/form&amp;gt;&amp;lt;p&amp;gt;` + x + ` &amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;`

	t := template.New(&amp;quot;main&amp;quot;)
	t, _ = t.Parse(tmpl)
	t.Execute(w, &amp;quot;Hello&amp;quot;)
}

// good
import (
	&amp;quot;fmt&amp;quot;
	&amp;quot;github.com/go-playground/validator/v10&amp;quot;
)

var validate *validator.Validate
validate = validator.New()

func validateVariable(val) {
	errs := validate.Var(val, &amp;quot;gte=1,lte=100&amp;quot;) // 限制必须是1-100的正整数
	if errs != nil {
		fmt.Println(errs)
		return false
	}
	return true
}

func handler(w http.ResponseWriter, r *http.Request) {
	r.ParseForm()
	x := r.Form.Get(&amp;quot;name&amp;quot;)

	if validateVariable(x) {
		var tmpl = `&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;
            &amp;lt;form action=&amp;quot;/&amp;quot; method=&amp;quot;post&amp;quot;&amp;gt;
            First name:&amp;lt;br&amp;gt;
            &amp;lt;input type=&amp;quot;text&amp;quot; name=&amp;quot;name&amp;quot; value=&amp;quot;&amp;quot;&amp;gt;
            &amp;lt;input type=&amp;quot;submit&amp;quot; value=&amp;quot;Submit&amp;quot;&amp;gt;
            &amp;lt;/form&amp;gt;&amp;lt;p&amp;gt;` + x + ` &amp;lt;/p&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;`
		t := template.New(&amp;quot;main&amp;quot;)
		t, _ = t.Parse(tmpl)
		t.Execute(w, &amp;quot;Hello&amp;quot;)
	} else {
		// ...
	}
}

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;web跨域&#34;&gt;Web跨域&lt;/h3&gt;
&lt;h4 id=&#34;必须跨域资源共享cors限制请求来源&#34;&gt;【必须】跨域资源共享CORS限制请求来源&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CORS请求保护不当可导致敏感信息泄漏，因此应当严格设置Access-Control-Allow-Origin使用同源策略进行保护。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// good
c := cors.New(cors.Options{
	AllowedOrigins:   []string{&amp;quot;http://qq.com&amp;quot;, &amp;quot;https://qq.com&amp;quot;},
	AllowCredentials: true,
	Debug:            false,
})

// 引入中间件
handler = c.Handler(handler)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;响应输出&#34;&gt;响应输出&lt;/h3&gt;
&lt;h4 id=&#34;必须设置正确的http响应包类型&#34;&gt;【必须】设置正确的HTTP响应包类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;响应头Content-Type与实际响应内容，应保持一致。如：API响应数据类型是json，则响应头使用&lt;code&gt;application/json&lt;/code&gt;；若为xml，则设置为&lt;code&gt;text/xml&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须添加安全响应头&#34;&gt;【必须】添加安全响应头&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;所有接口、页面，添加响应头 &lt;code&gt;X-Content-Type-Options: nosniff&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;所有接口、页面，添加响应头&lt;code&gt;X-Frame-Options &lt;/code&gt;。按需合理设置其允许范围，包括：&lt;code&gt;DENY&lt;/code&gt;、&lt;code&gt;SAMEORIGIN&lt;/code&gt;、&lt;code&gt;ALLOW-FROM origin&lt;/code&gt;。用法参考：&lt;a class=&#34;link&#34; href=&#34;https://developer.mozilla.org/zh-CN/docs/Web/HTTP/X-Frame-Options&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MDN文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须外部输入拼接到http响应头中需进行过滤&#34;&gt;【必须】外部输入拼接到HTTP响应头中需进行过滤&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;应尽量避免外部可控参数拼接到HTTP响应头中，如业务需要则需要过滤掉&lt;code&gt;\r&lt;/code&gt;、&lt;code&gt;\n&lt;/code&gt;等换行符，或者拒绝携带换行符号的外部输入。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;必须外部输入拼接到response页面前进行编码处理&#34;&gt;【必须】外部输入拼接到response页面前进行编码处理&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;直出html页面或使用模板生成html页面的，推荐使用&lt;code&gt;text/template&lt;/code&gt;自动编码，或者使用&lt;code&gt;html.EscapeString&lt;/code&gt;或&lt;code&gt;text/template&lt;/code&gt;对&lt;code&gt;&amp;lt;, &amp;gt;, &amp;amp;, &#39;,&amp;quot;&lt;/code&gt;等字符进行编码。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;html/template&amp;quot;
)

func outtemplate(w http.ResponseWriter, r *http.Request) {
	param1 := r.URL.Query().Get(&amp;quot;param1&amp;quot;)
	tmpl := template.New(&amp;quot;hello&amp;quot;)
	tmpl, _ = tmpl.Parse(`{{define &amp;quot;T&amp;quot;}}{{.}}{{end}}`)
	tmpl.ExecuteTemplate(w, &amp;quot;T&amp;quot;, param1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;会话管理&#34;&gt;会话管理&lt;/h3&gt;
&lt;h4 id=&#34;必须安全维护session信息&#34;&gt;【必须】安全维护session信息&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;用户登录时应重新生成session，退出登录后应清理session。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import (
	&amp;quot;github.com/gorilla/handlers&amp;quot;
	&amp;quot;github.com/gorilla/mux&amp;quot;
	&amp;quot;net/http&amp;quot;
)

// 创建cookie
func setToken(res http.ResponseWriter, req *http.Request) {
	expireToken := time.Now().Add(time.Minute * 30).Unix()
	expireCookie := time.Now().Add(time.Minute * 30)

	//...

	cookie := http.Cookie{
		Name:     &amp;quot;Auth&amp;quot;,
		Value:    signedToken,
		Expires:  expireCookie, // 过期失效
		HttpOnly: true,
		Path:     &amp;quot;/&amp;quot;,
		Domain:   &amp;quot;127.0.0.1&amp;quot;,
		Secure:   true,
	}

	http.SetCookie(res, &amp;amp;cookie)
	http.Redirect(res, req, &amp;quot;/profile&amp;quot;, 307)
}

// 删除cookie
func logout(res http.ResponseWriter, req *http.Request) {
	deleteCookie := http.Cookie{
		Name:    &amp;quot;Auth&amp;quot;,
		Value:   &amp;quot;none&amp;quot;,
		Expires: time.Now(),
	}
	http.SetCookie(res, &amp;amp;deleteCookie)
	return
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须csrf防护&#34;&gt;【必须】CSRF防护&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;涉及系统敏感操作或可读取敏感信息的接口应校验&lt;code&gt;Referer&lt;/code&gt;或添加&lt;code&gt;csrf_token&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// good
import (
	&amp;quot;github.com/gorilla/csrf&amp;quot;
	&amp;quot;github.com/gorilla/mux&amp;quot;
	&amp;quot;net/http&amp;quot;
)

func main() {
	r := mux.NewRouter()
	r.HandleFunc(&amp;quot;/signup&amp;quot;, ShowSignupForm)
	r.HandleFunc(&amp;quot;/signup/post&amp;quot;, SubmitSignupForm)
	// 使用csrf_token验证
	http.ListenAndServe(&amp;quot;:8000&amp;quot;,
		csrf.Protect([]byte(&amp;quot;32-byte-long-auth-key&amp;quot;))(r))
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;访问控制&#34;&gt;访问控制&lt;/h3&gt;
&lt;h4 id=&#34;必须默认鉴权&#34;&gt;【必须】默认鉴权&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;除非资源完全可对外开放，否则系统默认进行身份认证，使用白名单的方式放开不需要认证的接口或页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据资源的机密程度和用户角色，以最小权限原则，设置不同级别的权限，如完全公开、登录可读、登录可写、特定用户可读、特定用户可写等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;涉及用户自身相关的数据的读写必须验证登录态用户身份及其权限，避免越权操作&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;c1&#34;&gt;-- 伪代码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userid&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;session&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;userid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有独立账号体系的外网服务使用&lt;code&gt;QQ&lt;/code&gt;或&lt;code&gt;微信&lt;/code&gt;登录，内网服务使用&lt;code&gt;统一登录服务&lt;/code&gt;登录，其他使用账号密码登录的服务需要增加验证码等二次验证&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;h3 id=&#34;19-并发保护&#34;&gt;1.9 并发保护&lt;/h3&gt;
&lt;h4 id=&#34;191必须禁止在闭包中直接调用循环变量&#34;&gt;1.9.1【必须】禁止在闭包中直接调用循环变量&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在循环中启动协程，当协程中使用到了循环的索引值，由于多个协程同时使用同一个变量会产生数据竞争，造成执行结果异常。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func main() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	var group sync.WaitGroup

	for i := 0; i &amp;lt; 5; i++ {
		group.Add(1)
		go func() {
			defer group.Done()
			fmt.Printf(&amp;quot;%-2d&amp;quot;, i) // 这里打印的i不是所期望的
		}()
	}
	group.Wait()
}

// good
func main() {
	runtime.GOMAXPROCS(runtime.NumCPU())
	var group sync.WaitGroup

	for i := 0; i &amp;lt; 5; i++ {
		group.Add(1)
		go func(j int) {
			defer func() {
				if r := recover(); r != nil {
					fmt.Println(&amp;quot;Recovered in start()&amp;quot;)
				}
				group.Done()
			}()
			fmt.Printf(&amp;quot;%-2d&amp;quot;, j) // 闭包内部使用局部变量
		}(i) // 把循环变量显式地传给协程
	}
	group.Wait()
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须禁止并发写map&#34;&gt;【必须】禁止并发写map&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;并发写map容易造成程序崩溃并异常退出，建议加锁保护&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// bad
func main() {
	m := make(map[int]int)
	// 并发读写
	go func() {
		for {
			_ = m[1]
		}
	}()
	go func() {
		for {
			m[2] = 1
		}
	}()
	select {}
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;必须确保并发安全&#34;&gt;【必须】确保并发安全&lt;/h4&gt;
&lt;p&gt;敏感操作如果未作并发安全限制，可导致数据读写异常，造成业务逻辑限制被绕过。可通过同步锁或者原子操作进行防护。&lt;/p&gt;
&lt;p&gt;通过同步锁共享内存&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// good
var count int

func Count(lock *sync.Mutex) {
	lock.Lock() // 加写锁
	count++
	fmt.Println(count)
	lock.Unlock() // 解写锁，任何一个Lock()或RLock()均需要保证对应有Unlock()或RUnlock()
}

func main() {
	lock := &amp;amp;sync.Mutex{}
	for i := 0; i &amp;lt; 10; i++ {
		go Count(lock) // 传递指针是为了防止函数内的锁和调用锁不一致
	}
	for {
		lock.Lock()
		c := count
		lock.Unlock()
		runtime.Gosched() // 交出时间片给协程
		if c &amp;gt; 10 {
			break
		}
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;sync/atomic&lt;/code&gt;执行原子操作&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// good
import (
	&amp;quot;sync&amp;quot;
	&amp;quot;sync/atomic&amp;quot;
)

func main() {
	type Map map[string]string
	var m atomic.Value
	m.Store(make(Map))
	var mu sync.Mutex // used only by writers
	read := func(key string) (val string) {
		m1 := m.Load().(Map)
		return m1[key]
	}
	insert := func(key, val string) {
		mu.Lock() // 与潜在写入同步
		defer mu.Unlock()
		m1 := m.Load().(Map) // 导入struct当前数据
		m2 := make(Map)      // 创建新值
		for k, v := range m1 {
			m2[k] = v
		}
		m2[key] = val
		m.Store(m2) // 用新的替代当前对象
	}
	_, _ = read, insert
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>Uber go 语言编码规范</title>
        <link>https://zcj-git520.github.io/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</link>
        <pubDate>Wed, 20 Oct 2021 22:00:08 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/uber-go-%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/1.jpg" alt="Featured image of post Uber go 语言编码规范" /&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;uber-goguidehttpsgithubcomuber-goguide-的中文翻译&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/uber-go/guide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;uber-go/guide&lt;/a&gt; 的中文翻译&lt;/h2&gt;
&lt;h2 id=&#34;englishhttpsgithubcomuber-goguideblobmasterstylemd&#34;&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/uber-go/guide/blob/master/style.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;English&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id=&#34;uber-go-语言编码规范&#34;&gt;Uber go 语言编码规范&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.uber.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Uber&lt;/a&gt; 是一家美国硅谷的科技公司，也是 go 语言的早期 adopter。其开源了很多 golang 项目，诸如被
gopher 圈熟知的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/uber-go/zap&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;zap&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://github.com/jaegertracing/jaeger&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jaeger&lt;/a&gt; 等。2018 年年末 Uber 将内部的 &lt;a class=&#34;link&#34; href=&#34;https://github.com/uber-go/guide&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go 风格规范&lt;/a&gt; 开源到 GitHub，经过一年的积累和更新，该规范已经初具规模，并受到广大 gopher 的关注。本文是该规范的中文版本。本版本会根据原版实时更新。&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#uber-goguide-%e7%9a%84%e4%b8%ad%e6%96%87%e7%bf%bb%e8%af%91&#34; &gt;uber-
go/guide 的中文翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#english&#34; &gt;English&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#uber-go-%e8%af%ad%e8%a8%80%e7%bc%96%e7%a0%81%e8%a7%84%e8%8c%83&#34; &gt;Uber go 语言编码规范&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%89%88%e6%9c%ac&#34; &gt;版本&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%9b%ae%e5%bd%95&#34; &gt;目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bb%8b%e7%bb%8d&#34; &gt;介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8c%87%e5%af%bc%e5%8e%9f%e5%88%99&#34; &gt;指导原则&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8c%87%e5%90%91-interface-%e7%9a%84%e6%8c%87%e9%92%88&#34; &gt;指向 interface 的指针&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#interface-%e5%90%88%e7%90%86%e6%80%a7%e9%aa%8c%e8%af%81&#34; &gt;Interface 合理性验证&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8e%a5%e6%94%b6%e5%99%a8-receiver-%e4%b8%8e%e6%8e%a5%e5%8f%a3&#34; &gt;接收器 (receiver) 与接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%9b%b6%e5%80%bc-mutex-%e6%98%af%e6%9c%89%e6%95%88%e7%9a%84&#34; &gt;零值 Mutex 是有效的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%9c%a8%e8%be%b9%e7%95%8c%e5%a4%84%e6%8b%b7%e8%b4%9d-slices-%e5%92%8c-maps&#34; &gt;在边界处拷贝 Slices 和 Maps&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8e%a5%e6%94%b6-slices-%e5%92%8c-maps&#34; &gt;接收 Slices 和 Maps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e8%bf%94%e5%9b%9e-slices-%e6%88%96-maps&#34; &gt;返回 slices 或 maps&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8-defer-%e9%87%8a%e6%94%be%e8%b5%84%e6%ba%90&#34; &gt;使用 defer 释放资源&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#channel-%e7%9a%84-size-%e8%a6%81%e4%b9%88%e6%98%af-1%e8%a6%81%e4%b9%88%e6%98%af%e6%97%a0%e7%bc%93%e5%86%b2%e7%9a%84&#34; &gt;Channel 的 size 要么是 1，要么是无缓冲的&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%9e%9a%e4%b8%be%e4%bb%8e-1-%e5%bc%80%e5%a7%8b&#34; &gt;枚举从 1 开始&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8-time-%e5%a4%84%e7%90%86%e6%97%b6%e9%97%b4&#34; &gt;使用 time 处理时间&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8-timetime-%e8%a1%a8%e8%be%be%e7%9e%ac%e6%97%b6%e6%97%b6%e9%97%b4&#34; &gt;使用 &lt;code&gt;time.Time&lt;/code&gt; 表达瞬时时间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8-timeduration-%e8%a1%a8%e8%be%be%e6%97%b6%e9%97%b4%e6%ae%b5&#34; &gt;使用 &lt;code&gt;time.Duration&lt;/code&gt; 表达时间段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%af%b9%e5%a4%96%e9%83%a8%e7%b3%bb%e7%bb%9f%e4%bd%bf%e7%94%a8-timetime-%e5%92%8c-timeduration&#34; &gt;对外部系统使用 &lt;code&gt;time.Time&lt;/code&gt; 和 &lt;code&gt;time.Duration&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%94%99%e8%af%af%e7%b1%bb%e5%9e%8b&#34; &gt;错误类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%94%99%e8%af%af%e5%8c%85%e8%a3%85-error-wrapping&#34; &gt;错误包装 (Error Wrapping)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%a4%84%e7%90%86%e7%b1%bb%e5%9e%8b%e6%96%ad%e8%a8%80%e5%a4%b1%e8%b4%a5&#34; &gt;处理类型断言失败&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%b8%8d%e8%a6%81-panic&#34; &gt;不要 panic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8-gouberorgatomic&#34; &gt;使用 go.uber.org/atomic&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%81%bf%e5%85%8d%e5%8f%af%e5%8f%98%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f&#34; &gt;避免可变全局变量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%81%bf%e5%85%8d%e5%9c%a8%e5%85%ac%e5%85%b1%e7%bb%93%e6%9e%84%e4%b8%ad%e5%b5%8c%e5%85%a5%e7%b1%bb%e5%9e%8b&#34; &gt;避免在公共结构中嵌入类型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e5%86%85%e7%bd%ae%e5%90%8d%e7%a7%b0&#34; &gt;避免使用内置名称&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8-init&#34; &gt;避免使用 &lt;code&gt;init()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e8%bf%bd%e5%8a%a0%e6%97%b6%e4%bc%98%e5%85%88%e6%8c%87%e5%ae%9a%e5%88%87%e7%89%87%e5%ae%b9%e9%87%8f&#34; &gt;追加时优先指定切片容量&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%b8%bb%e5%87%bd%e6%95%b0%e9%80%80%e5%87%ba%e6%96%b9%e5%bc%8fexit&#34; &gt;主函数退出方式(Exit)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%b8%80%e6%ac%a1%e6%80%a7%e9%80%80%e5%87%ba&#34; &gt;一次性退出&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%80%a7%e8%83%bd&#34; &gt;性能&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bc%98%e5%85%88%e4%bd%bf%e7%94%a8-strconv-%e8%80%8c%e4%b8%8d%e6%98%af-fmt&#34; &gt;优先使用 strconv 而不是 fmt&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%81%bf%e5%85%8d%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%88%b0%e5%ad%97%e8%8a%82%e7%9a%84%e8%bd%ac%e6%8d%a2&#34; &gt;避免字符串到字节的转换&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8c%87%e5%ae%9a%e5%ae%b9%e5%99%a8%e5%ae%b9%e9%87%8f&#34; &gt;指定容器容量&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8c%87%e5%ae%9amap%e5%ae%b9%e9%87%8f%e6%8f%90%e7%a4%ba&#34; &gt;指定Map容量提示&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%8c%87%e5%ae%9a%e5%88%87%e7%89%87%e5%ae%b9%e9%87%8f&#34; &gt;指定切片容量&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e8%a7%84%e8%8c%83&#34; &gt;规范&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%b8%80%e8%87%b4%e6%80%a7&#34; &gt;一致性&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%9b%b8%e4%bc%bc%e7%9a%84%e5%a3%b0%e6%98%8e%e6%94%be%e5%9c%a8%e4%b8%80%e7%bb%84&#34; &gt;相似的声明放在一组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#import-%e5%88%86%e7%bb%84&#34; &gt;import 分组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%8c%85%e5%90%8d&#34; &gt;包名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%90%8d&#34; &gt;函数名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%af%bc%e5%85%a5%e5%88%ab%e5%90%8d&#34; &gt;导入别名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%87%bd%e6%95%b0%e5%88%86%e7%bb%84%e4%b8%8e%e9%a1%ba%e5%ba%8f&#34; &gt;函数分组与顺序&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%87%8f%e5%b0%91%e5%b5%8c%e5%a5%97&#34; &gt;减少嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%b8%8d%e5%bf%85%e8%a6%81%e7%9a%84-else&#34; &gt;不必要的 else&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%a1%b6%e5%b1%82%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e&#34; &gt;顶层变量声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%af%b9%e4%ba%8e%e6%9c%aa%e5%af%bc%e5%87%ba%e7%9a%84%e9%a1%b6%e5%b1%82%e5%b8%b8%e9%87%8f%e5%92%8c%e5%8f%98%e9%87%8f%e4%bd%bf%e7%94%a8_%e4%bd%9c%e4%b8%ba%e5%89%8d%e7%bc%80&#34; &gt;对于未导出的顶层常量和变量，使用_作为前缀&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%bb%93%e6%9e%84%e4%bd%93%e4%b8%ad%e7%9a%84%e5%b5%8c%e5%85%a5&#34; &gt;结构体中的嵌入&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%ad%97%e6%ae%b5%e5%90%8d%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84%e4%bd%93&#34; &gt;使用字段名初始化结构体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e6%9c%ac%e5%9c%b0%e5%8f%98%e9%87%8f%e5%a3%b0%e6%98%8e&#34; &gt;本地变量声明&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#nil-%e6%98%af%e4%b8%80%e4%b8%aa%e6%9c%89%e6%95%88%e7%9a%84-slice&#34; &gt;nil 是一个有效的 slice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%bc%a9%e5%b0%8f%e5%8f%98%e9%87%8f%e4%bd%9c%e7%94%a8%e5%9f%9f&#34; &gt;缩小变量作用域&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e9%81%bf%e5%85%8d%e5%8f%82%e6%95%b0%e8%af%ad%e4%b9%89%e4%b8%8d%e6%98%8e%e7%a1%aeavoid-naked-parameters&#34; &gt;避免参数语义不明确(Avoid Naked Parameters)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%8e%9f%e5%a7%8b%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%97%e9%9d%a2%e5%80%bc%e9%81%bf%e5%85%8d%e8%bd%ac%e4%b9%89&#34; &gt;使用原始字符串字面值，避免转义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84%e4%bd%93&#34; &gt;初始化结构体&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e4%bd%bf%e7%94%a8%e5%ad%97%e6%ae%b5%e5%90%8d%e5%88%9d%e5%a7%8b%e5%8c%96%e7%bb%93%e6%9e%84&#34; &gt;使用字段名初始化结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%9c%81%e7%95%a5%e7%bb%93%e6%9e%84%e4%b8%ad%e7%9a%84%e9%9b%b6%e5%80%bc%e5%ad%97%e6%ae%b5&#34; &gt;省略结构中的零值字段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%af%b9%e9%9b%b6%e5%80%bc%e7%bb%93%e6%9e%84%e4%bd%bf%e7%94%a8-var&#34; &gt;对零值结构使用 &lt;code&gt;var&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96-struct-%e5%bc%95%e7%94%a8&#34; &gt;初始化 Struct 引用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%88%9d%e5%a7%8b%e5%8c%96-maps&#34; &gt;初始化 Maps&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%ad%97%e7%ac%a6%e4%b8%b2-string-format&#34; &gt;字符串 string format&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%91%bd%e5%90%8d-printf-%e6%a0%b7%e5%bc%8f%e7%9a%84%e5%87%bd%e6%95%b0&#34; &gt;命名 Printf 样式的函数&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%bc%8f&#34; &gt;编程模式&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95&#34; &gt;表驱动测试&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#%e5%8a%9f%e8%83%bd%e9%80%89%e9%a1%b9&#34; &gt;功能选项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#linting&#34; &gt;Linting&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#lint-runners&#34; &gt;Lint Runners&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;#stargazers-over-time&#34; &gt;Stargazers over time&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;介绍&#34;&gt;介绍&lt;/h2&gt;
&lt;p&gt;样式 (style) 是支配我们代码的惯例。术语&lt;code&gt;样式&lt;/code&gt;有点用词不当，因为这些约定涵盖的范围不限于由
gofmt 替我们处理的源文件格式。&lt;/p&gt;
&lt;p&gt;本指南的目的是通过详细描述在 Uber 编写
go 代码的注意事项来管理这种复杂性。这些规则的存在是为了使代码库易于管理，同时仍然允许工程师更有效地使用
go 语言功能。&lt;/p&gt;
&lt;p&gt;该指南最初由 &lt;a class=&#34;link&#34; href=&#34;https://github.com/prashantv&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Prashant Varanasi&lt;/a&gt; 和 &lt;a class=&#34;link&#34; href=&#34;https://github.com/nomis52&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Simon Newton&lt;/a&gt; 编写，目的是使一些同事能快速使用
go。多年来，该指南已根据其他人的反馈进行了修改。&lt;/p&gt;
&lt;p&gt;本文档记录了我们在 Uber 遵循的
go 代码中的惯用约定。其中许多是
go 的通用准则，而其他扩展准则依赖于下面外部的指南：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;[Effective
go](https://
golang.org/doc/effective_
go.html)&lt;/li&gt;
&lt;li&gt;[
go Common Mistakes](&lt;a class=&#34;link&#34; href=&#34;https://github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/&lt;/a&gt;
golang/
go/wiki/CommonMistakes)&lt;/li&gt;
&lt;li&gt;[
go Code Review Comments](&lt;a class=&#34;link&#34; href=&#34;https://github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/&lt;/a&gt;
golang/
go/wiki/CodeReviewComments)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所有代码都应该通过&lt;code&gt; golint&lt;/code&gt;和&lt;code&gt; go vet&lt;/code&gt;的检查并无错误。我们建议您将编辑器设置为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保存时运行 &lt;code&gt; goimports&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行 &lt;code&gt; golint&lt;/code&gt; 和 &lt;code&gt; go vet&lt;/code&gt; 检查错误&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;您可以在以下
go 编辑器工具支持页面中找到更为详细的信息：
&amp;lt;https://github.com/
golang/
go/wiki/IDEsAndTextEditorPlugins&amp;gt;&lt;/p&gt;
&lt;h2 id=&#34;指导原则&#34;&gt;指导原则&lt;/h2&gt;
&lt;h3 id=&#34;指向-interface-的指针&#34;&gt;指向 interface 的指针&lt;/h3&gt;
&lt;p&gt;您几乎不需要指向接口类型的指针。您应该将接口作为值进行传递，在这样的传递过程中，实质上传递的底层数据仍然可以是指针。&lt;/p&gt;
&lt;p&gt;接口实质上在底层用两个字段表示：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个指向某些特定类型信息的指针。您可以将其视为&amp;quot;type&amp;quot;。&lt;/li&gt;
&lt;li&gt;数据指针。如果存储的数据是指针，则直接存储。如果存储的数据是一个值，则存储指向该值的指针。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果希望接口方法修改基础数据，则必须使用指针传递(将对象指针赋值给接口变量)。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

// f1.f()无法修改底层数据
// f2.f() 可以修改底层数据,给接口变量f2赋值时使用的是对象指针
var f1 F = S1{}
var f2 F = &amp;amp;S2{}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;interface-合理性验证&#34;&gt;Interface 合理性验证&lt;/h3&gt;
&lt;p&gt;在编译时验证接口的符合性。这包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将实现特定接口的导出类型作为接口API 的一部分进行检查&lt;/li&gt;
&lt;li&gt;实现同一接口的(导出和非导出)类型属于实现类型的集合&lt;/li&gt;
&lt;li&gt;任何违反接口合理性检查的场景,都会终止编译,并通知给用户&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;补充:上面3条是编译器对接口的检查机制,
大体意思是错误使用接口会在编译期报错.
所以可以利用这个机制让部分问题在编译期暴露.&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// 如果Handler没有实现http.Handler,会在运行时报错
type Handler struct {
  // ...
}
func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;
go
type Handler struct {
  // ...
}
// 用于触发编译期的接口的合理性检查机制
// 如果Handler没有实现http.Handler,会在编译期报错
var _ http.Handler = (*Handler)(nil)
func (h *Handler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果 &lt;code&gt;*Handler&lt;/code&gt; 与 &lt;code&gt;http.Handler&lt;/code&gt; 的接口不匹配,
那么语句 &lt;code&gt;var _ http.Handler = (*Handler)(nil)&lt;/code&gt; 将无法编译通过.&lt;/p&gt;
&lt;p&gt;赋值的右边应该是断言类型的零值。
对于指针类型（如 &lt;code&gt;*Handler&lt;/code&gt;）、切片和映射，这是 &lt;code&gt;nil&lt;/code&gt;；
对于结构类型，这是空结构。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type LogHandler struct {
  h   http.Handler
  log *zap.Logger
}
var _ http.Handler = LogHandler{}
func (h LogHandler) ServeHTTP(
  w http.ResponseWriter,
  r *http.Request,
) {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;接收器-receiver-与接口&#34;&gt;接收器 (receiver) 与接口&lt;/h3&gt;
&lt;p&gt;使用值接收器的方法既可以通过值调用，也可以通过指针调用。&lt;/p&gt;
&lt;p&gt;带指针接收器的方法只能通过指针或 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;addressable values&lt;/a&gt;调用.&lt;/p&gt;
&lt;p&gt;golang.org/ref/spec#Method_values&lt;/p&gt;
&lt;p&gt;例如，&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type S struct {
  data string
}

func (s S) Read() string {
  return s.data
}

func (s *S) Write(str string) {
  s.data = str
}

sVals := map[int]S{1: {&amp;quot;A&amp;quot;}}

// 你只能通过值调用 Read
sVals[1].Read()

// 这不能编译通过：
//  sVals[1].Write(&amp;quot;test&amp;quot;)

sPtrs := map[int]*S{1: {&amp;quot;A&amp;quot;}}

// 通过指针既可以调用 Read，也可以调用 Write 方法
sPtrs[1].Read()
sPtrs[1].Write(&amp;quot;test&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;类似的,即使方法有了值接收器,也同样可以用指针接收器来满足接口.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type F interface {
  f()
}

type S1 struct{}

func (s S1) f() {}

type S2 struct{}

func (s *S2) f() {}

s1Val := S1{}
s1Ptr := &amp;amp;S1{}
s2Val := S2{}
s2Ptr := &amp;amp;S2{}

var i F
i = s1Val
i = s1Ptr
i = s2Ptr

//  下面代码无法通过编译。因为 s2Val 是一个值，而 S2 的 f 方法中没有使用值接收器
//   i = s2Val
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;[Effective
go](https://
golang.org/doc/effective_
go.html) 中有一段关于 [pointers vs. values](https://
golang.org/doc/effective_
go.html#pointers_vs_values) 的精彩讲解。&lt;/p&gt;
&lt;p&gt;补充:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个类型可以有值接收器方法集和指针接收器方法集
&lt;ul&gt;
&lt;li&gt;值接收器方法集是指针接收器方法集的子集,反之不是&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;规则
&lt;ul&gt;
&lt;li&gt;值对象只可以使用值接收器方法集&lt;/li&gt;
&lt;li&gt;指针对象可以使用 值接收器方法集 + 指针接收器方法集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;接口的匹配(或者叫实现)
&lt;ul&gt;
&lt;li&gt;类型实现了接口的所有方法,叫匹配&lt;/li&gt;
&lt;li&gt;具体的讲,要么是类型的值方法集匹配接口,要么是指针方法集匹配接口&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;具体的匹配分两种:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值方法集和接口匹配
&lt;ul&gt;
&lt;li&gt;给接口变量赋值的不管是值还是指针对象,都ok,因为都包含值方法集&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;指针方法集和接口匹配
&lt;ul&gt;
&lt;li&gt;只能将指针对象赋值给接口变量,因为只有指针方法集和接口匹配&lt;/li&gt;
&lt;li&gt;如果将值对象赋值给接口变量,会在编译期报错(会触发接口合理性检查机制)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为啥 i = s2Val 会报错,因为值方法集和接口不匹配.&lt;/p&gt;
&lt;h3 id=&#34;零值-mutex-是有效的&#34;&gt;零值 Mutex 是有效的&lt;/h3&gt;
&lt;p&gt;零值 &lt;code&gt;sync.Mutex&lt;/code&gt; 和 &lt;code&gt;sync.RWMutex&lt;/code&gt; 是有效的。所以指向 mutex 的指针基本是不必要的。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
mu := new(sync.Mutex)
mu.Lock()
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var mu sync.Mutex
mu.Lock()
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果你使用结构体指针，mutex 可以非指针形式作为结构体的组成字段，或者更好的方式是直接嵌入到结构体中。
如果是私有结构体类型或是要实现 Mutex 接口的类型，我们可以使用嵌入 mutex 的方法：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type smap struct {
  sync.Mutex // only for unexported types（仅适用于非导出类型）

  data map[string]string
}

func newSMap() *smap {
  return &amp;amp;smap{
    data: make(map[string]string),
  }
}

func (m *smap) Get(k string) string {
  m.Lock()
  defer m.Unlock()

  return m.data[k]
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type SMap struct {
  mu sync.Mutex // 对于导出类型，请使用私有锁

  data map[string]string
}

func NewSMap() *SMap {
  return &amp;amp;SMap{
    data: make(map[string]string),
  }
}

func (m *SMap) Get(k string) string {
  m.mu.Lock()
  defer m.mu.Unlock()

  return m.data[k]
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;在边界处拷贝-slices-和-maps&#34;&gt;在边界处拷贝 Slices 和 Maps&lt;/h3&gt;
&lt;p&gt;slices 和 maps 包含了指向底层数据的指针，因此在需要复制它们时要特别注意。&lt;/p&gt;
&lt;h4 id=&#34;接收-slices-和-maps&#34;&gt;接收 Slices 和 Maps&lt;/h4&gt;
&lt;p&gt;请记住，当 map 或 slice 作为函数参数传入时，如果您存储了对它们的引用，则用户可以对其进行修改。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = trips
}

trips := ...
d1.SetTrips(trips)

// 你是要修改 d1.trips 吗？
trips[0] = ...
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func (d *Driver) SetTrips(trips []Trip) {
  d.trips = make([]Trip, len(trips))
  copy(d.trips, trips)
}

trips := ...
d1.SetTrips(trips)

// 这里我们修改 trips[0]，但不会影响到 d1.trips
trips[0] = ...
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;返回-slices-或-maps&#34;&gt;返回 slices 或 maps&lt;/h4&gt;
&lt;p&gt;同样，请注意用户对暴露内部状态的 map 或 slice 的修改。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Stats struct {
  mu sync.Mutex

  counters map[string]int
}

// Snapshot 返回当前状态。
func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  return s.counters
}

// snapshot 不再受互斥锁保护
// 因此对 snapshot 的任何访问都将受到数据竞争的影响
// 影响 stats.counters
snapshot := stats.Snapshot()
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Stats struct {
  mu sync.Mutex

  counters map[string]int
}

func (s *Stats) Snapshot() map[string]int {
  s.mu.Lock()
  defer s.mu.Unlock()

  result := make(map[string]int, len(s.counters))
  for k, v := range s.counters {
    result[k] = v
  }
  return result
}

// snapshot 现在是一个拷贝
snapshot := stats.Snapshot()
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;使用-defer-释放资源&#34;&gt;使用 defer 释放资源&lt;/h3&gt;
&lt;p&gt;使用 defer 释放资源，诸如文件和锁。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
p.Lock()
if p.count &amp;lt; 10 {
  p.Unlock()
  return p.count
}

p.count++
newCount := p.count
p.Unlock()

return newCount

// 当有多个 return 分支时，很容易遗忘 unlock
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
p.Lock()
defer p.Unlock()

if p.count &amp;lt; 10 {
  return p.count
}

p.count++
return p.count

// 更可读
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Defer 的开销非常小，只有在您可以证明函数执行时间处于纳秒级的程度时，才应避免这样做。使用 defer 提升可读性是值得的，因为使用它们的成本微不足道。尤其适用于那些不仅仅是简单内存访问的较大的方法，在这些方法中其他计算的资源消耗远超过 &lt;code&gt;defer&lt;/code&gt;。&lt;/p&gt;
&lt;h3 id=&#34;channel-的-size-要么是-1要么是无缓冲的&#34;&gt;Channel 的 size 要么是 1，要么是无缓冲的&lt;/h3&gt;
&lt;p&gt;channel 通常 size 应为 1 或是无缓冲的。默认情况下，channel 是无缓冲的，其 size 为零。任何其他尺寸都必须经过严格的审查。我们需要考虑如何确定大小，考虑是什么阻止了 channel 在高负载下和阻塞写时的写入，以及当这种情况发生时系统逻辑有哪些变化。(翻译解释：按照原文意思是需要界定通道边界，竞态条件，以及逻辑上下文梳理)&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// 应该足以满足任何情况！
c := make(chan int, 64)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// 大小：1
c := make(chan int, 1) // 或者
// 无缓冲 channel，大小为 0
c := make(chan int)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;枚举从-1-开始&#34;&gt;枚举从 1 开始&lt;/h3&gt;
&lt;p&gt;在
go 中引入枚举的标准方法是声明一个自定义类型和一个使用了 iota 的 const 组。由于变量的默认值为 0，因此通常应以非零值开头枚举。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Operation int

const (
  Add Operation = iota
  Subtract
  Multiply
)

// Add=0, Subtract=1, Multiply=2
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
)

// Add=1, Subtract=2, Multiply=3
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;在某些情况下，使用零值是有意义的（枚举从零开始），例如，当零值是理想的默认行为时。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Lo
goutput int

const (
  LogToStdout Lo
goutput = iota
  LogToFile
  LogToRemote
)

// LogToStdout=0, LogToFile=1, LogToRemote=2
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用-time-处理时间&#34;&gt;使用 time 处理时间&lt;/h3&gt;
&lt;p&gt;时间处理很复杂。关于时间的错误假设通常包括以下几点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一天有 24 小时&lt;/li&gt;
&lt;li&gt;一小时有 60 分钟&lt;/li&gt;
&lt;li&gt;一周有七天&lt;/li&gt;
&lt;li&gt;一年 365 天&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://infiniteundo.com/post/25326999628/falsehoods-programmers-believe-about-time&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;还有更多&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;例如，&lt;em&gt;1&lt;/em&gt; 表示在一个时间点上加上 24 小时并不总是产生一个新的日历日。&lt;/p&gt;
&lt;p&gt;因此，在处理时间时始终使用 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;&amp;quot;time&amp;quot;&lt;/code&gt;&lt;/a&gt; 包，因为它有助于以更安全、更准确的方式处理这些不正确的假设。&lt;/p&gt;
&lt;p&gt;golang.org/pkg/time/&lt;/p&gt;
&lt;h4 id=&#34;使用-timetime-表达瞬时时间&#34;&gt;使用 &lt;code&gt;time.Time&lt;/code&gt; 表达瞬时时间&lt;/h4&gt;
&lt;p&gt;在处理时间的瞬间时使用 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;time.Time&lt;/code&gt;&lt;/a&gt;，在比较、添加或减去时间时使用 &lt;code&gt;time.Time&lt;/code&gt; 中的方法。&lt;/p&gt;
&lt;p&gt;golang.org/pkg/time/#Time&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func isActive(now, start, stop int) bool {
  return start &amp;lt;= now &amp;amp;&amp;amp; now &amp;lt; stop
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func isActive(now, start, stop time.Time) bool {
  return (start.Before(now) || start.Equal(now)) &amp;amp;&amp;amp; now.Before(stop)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;使用-timeduration-表达时间段&#34;&gt;使用 &lt;code&gt;time.Duration&lt;/code&gt; 表达时间段&lt;/h4&gt;
&lt;p&gt;在处理时间段时使用 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;time.Duration&lt;/code&gt;&lt;/a&gt; .&lt;/p&gt;
&lt;p&gt;golang.org/pkg/time/#Duration&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func poll(delay int) {
  for {
    // ...
    time.Sleep(time.Duration(delay) * time.Millisecond)
  }
}
poll(10) // 是几秒钟还是几毫秒?
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func poll(delay time.Duration) {
  for {
    // ...
    time.Sleep(delay)
  }
}
poll(10*time.Second)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;回到第一个例子，在一个时间瞬间加上 24 小时，我们用于添加时间的方法取决于意图。如果我们想要下一个日历日(当前天的下一天)的同一个时间点，我们应该使用 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;Time.AddDate&lt;/code&gt;&lt;/a&gt;。但是，如果我们想保证某一时刻比前一时刻晚 24 小时，我们应该使用 [&lt;code&gt;Time.Add&lt;/code&gt;]。&lt;/p&gt;
&lt;p&gt;golang.org/pkg/time/#Time.AddDate
[&lt;code&gt;Time.Add&lt;/code&gt;]: https://
golang.org/pkg/time/#Time.Add&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
newDay := t.AddDate(0 /* years */, 0 /* months */, 1 /* days */)
maybeNewDay := t.Add(24 * time.Hour)
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;对外部系统使用-timetime-和-timeduration&#34;&gt;对外部系统使用 &lt;code&gt;time.Time&lt;/code&gt; 和 &lt;code&gt;time.Duration&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;尽可能在与外部系统的交互中使用 &lt;code&gt;time.Duration&lt;/code&gt; 和 &lt;code&gt;time.Time&lt;/code&gt; 例如 :&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Command-line 标志: &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;flag&lt;/code&gt;&lt;/a&gt; 通过 [&lt;code&gt;time.ParseDuration&lt;/code&gt;] 支持 &lt;code&gt;time.Duration&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JSON: [&lt;code&gt;encoding/json&lt;/code&gt;] 通过其 [&lt;code&gt;UnmarshalJSON&lt;/code&gt; method] 方法支持将 &lt;code&gt;time.Time&lt;/code&gt; 编码为 [RFC 3339] 字符串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL: [&lt;code&gt;database/sql&lt;/code&gt;] 支持将 &lt;code&gt;DATETIME&lt;/code&gt; 或 &lt;code&gt;TIMESTAMP&lt;/code&gt; 列转换为 &lt;code&gt;time.Time&lt;/code&gt;，如果底层驱动程序支持则返回&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;YAML: [&lt;code&gt; gopkg.in/yaml.v2&lt;/code&gt;] 支持将 &lt;code&gt;time.Time&lt;/code&gt; 作为 [RFC 3339] 字符串，并通过 [&lt;code&gt;time.ParseDuration&lt;/code&gt;] 支持 &lt;code&gt;time.Duration&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;golang.org/pkg/flag/
[&lt;code&gt;time.ParseDuration&lt;/code&gt;]: https://
golang.org/pkg/time/#ParseDuration
[&lt;code&gt;encoding/json&lt;/code&gt;]: https://
golang.org/pkg/encoding/json/
[RFC 3339]: &lt;a class=&#34;link&#34; href=&#34;https://tools.ietf.org/html/rfc3339&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://tools.ietf.org/html/rfc3339&lt;/a&gt;
[&lt;code&gt;UnmarshalJSON&lt;/code&gt; method]: https://
golang.org/pkg/time/#Time.UnmarshalJSON
[&lt;code&gt;database/sql&lt;/code&gt;]: https://
golang.org/pkg/database/sql/
[&lt;code&gt; gopkg.in/yaml.v2&lt;/code&gt;]: https://
godoc.org/
gopkg.in/yaml.v2&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当不能在这些交互中使用 &lt;code&gt;time.Duration&lt;/code&gt; 时，请使用 &lt;code&gt;int&lt;/code&gt; 或 &lt;code&gt;float64&lt;/code&gt;，并在字段名称中包含单位。&lt;/p&gt;
&lt;p&gt;例如，由于 &lt;code&gt;encoding/json&lt;/code&gt; 不支持 &lt;code&gt;time.Duration&lt;/code&gt;，因此该单位包含在字段的名称中。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// {&amp;quot;interval&amp;quot;: 2}
type Config struct {
  Interval int `json:&amp;quot;interval&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// {&amp;quot;intervalMillis&amp;quot;: 2000}
type Config struct {
  IntervalMillis int `json:&amp;quot;intervalMillis&amp;quot;`
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;当在这些交互中不能使用 &lt;code&gt;time.Time&lt;/code&gt; 时，除非达成一致，否则使用 &lt;code&gt;string&lt;/code&gt; 和 [RFC 3339] 中定义的格式时间戳。默认情况下，&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;Time.UnmarshalText&lt;/code&gt;&lt;/a&gt; 使用此格式，并可通过 [&lt;code&gt;time.RFC3339&lt;/code&gt;] 在 &lt;code&gt;Time.Format&lt;/code&gt; 和 &lt;code&gt;time.Parse&lt;/code&gt; 中使用。&lt;/p&gt;
&lt;p&gt;golang.org/pkg/time/#Time.UnmarshalText
[&lt;code&gt;time.RFC3339&lt;/code&gt;]: https://
golang.org/pkg/time/#RFC3339&lt;/p&gt;
&lt;p&gt;尽管这在实践中并不成问题，但请记住，&lt;code&gt;&amp;quot;time&amp;quot;&lt;/code&gt; 包不支持解析闰秒时间戳（&lt;a class=&#34;link&#34; href=&#34;https://github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;8728&lt;/a&gt;），也不在计算中考虑闰秒（[15190]）。如果您比较两个时间瞬间，则差异将不包括这两个瞬间之间可能发生的闰秒。&lt;/p&gt;
&lt;p&gt;golang/
go/issues/8728
[15190]: &lt;a class=&#34;link&#34; href=&#34;https://github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/&lt;/a&gt;
golang/
go/issues/15190&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;错误类型&#34;&gt;错误类型&lt;/h3&gt;
&lt;p&gt;go 中有多种声明错误（Error) 的选项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;errors.New&lt;/code&gt;&lt;/a&gt; 对于简单静态字符串的错误&lt;/li&gt;
&lt;li&gt;[&lt;code&gt;fmt.Errorf&lt;/code&gt;] 用于格式化的错误字符串&lt;/li&gt;
&lt;li&gt;实现 &lt;code&gt;Error()&lt;/code&gt; 方法的自定义类型&lt;/li&gt;
&lt;li&gt;用 [&lt;code&gt;&amp;quot;pkg/errors&amp;quot;.Wrap&lt;/code&gt;] 的 Wrapped errors&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;返回错误时，请考虑以下因素以确定最佳选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这是一个不需要额外信息的简单错误吗？如果是这样，&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;errors.New&lt;/code&gt;&lt;/a&gt; 足够了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户需要检测并处理此错误吗？如果是这样，则应使用自定义类型并实现该 &lt;code&gt;Error()&lt;/code&gt; 方法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;您是否正在传播下游函数返回的错误？如果是这样，请查看本文后面有关错误包装 &lt;a class=&#34;link&#34; href=&#34;#%e9%94%99%e8%af%af%e5%8c%85%e8%a3%85&#34;  title=&#34;Error-Wrapping&#34;
    &gt;section on error wrapping&lt;/a&gt; 部分的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则 [&lt;code&gt;fmt.Errorf&lt;/code&gt;] 就可以了。&lt;/p&gt;
&lt;p&gt;golang.org/pkg/errors/#New
[&lt;code&gt;fmt.Errorf&lt;/code&gt;]: https://
golang.org/pkg/fmt/#Errorf
[&lt;code&gt;&amp;quot;pkg/errors&amp;quot;.Wrap&lt;/code&gt;]: https://
godoc.org/github.com/pkg/errors#Wrap&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果客户端需要检测错误，并且您已使用创建了一个简单的错误 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;errors.New&lt;/code&gt;&lt;/a&gt;，请使用一个错误变量。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// package foo

func Open() error {
  return errors.New(&amp;quot;could not open&amp;quot;)
}

// package bar

func use() {
  if err := foo.Open(); err != nil {
    if err.Error() == &amp;quot;could not open&amp;quot; {
      // handle
    } else {
      panic(&amp;quot;unknown error&amp;quot;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// package foo

var ErrCouldNotOpen = errors.New(&amp;quot;could not open&amp;quot;)

func Open() error {
  return ErrCouldNotOpen
}

// package bar

if err := foo.Open(); err != nil {
  if errors.Is(err, foo.ErrCouldNotOpen) {
    // handle
  } else {
    panic(&amp;quot;unknown error&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果您有可能需要客户端检测的错误，并且想向其中添加更多信息（例如，它不是静态字符串），则应使用自定义类型。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func open(file string) error {
  return fmt.Errorf(&amp;quot;file %q not found&amp;quot;, file)
}

func use() {
  if err := open(&amp;quot;testfile.txt&amp;quot;); err != nil {
    if strings.Contains(err.Error(), &amp;quot;not found&amp;quot;) {
      // handle
    } else {
      panic(&amp;quot;unknown error&amp;quot;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type errNotFound struct {
  file string
}

func (e errNotFound) Error() string {
  return fmt.Sprintf(&amp;quot;file %q not found&amp;quot;, e.file)
}

func open(file string) error {
  return errNotFound{file: file}
}

func use() {
  if err := open(&amp;quot;testfile.txt&amp;quot;); err != nil {
    if _, ok := err.(errNotFound); ok {
      // handle
    } else {
      panic(&amp;quot;unknown error&amp;quot;)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;直接导出自定义错误类型时要小心，因为它们已成为程序包公共 API 的一部分。最好公开匹配器功能以检查错误。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// package foo

type errNotFound struct {
  file string
}

func (e errNotFound) Error() string {
  return fmt.Sprintf(&amp;quot;file %q not found&amp;quot;, e.file)
}

func IsNotFoundError(err error) bool {
  _, ok := err.(errNotFound)
  return ok
}

func Open(file string) error {
  return errNotFound{file: file}
}

// package bar

if err := foo.Open(&amp;quot;foo&amp;quot;); err != nil {
  if foo.IsNotFoundError(err) {
    // handle
  } else {
    panic(&amp;quot;unknown error&amp;quot;)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;错误包装-error-wrapping&#34;&gt;错误包装 (Error Wrapping)&lt;/h3&gt;
&lt;p&gt;一个（函数/方法）调用失败时，有三种主要的错误传播方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有要添加的其他上下文，并且您想要维护原始错误类型，则返回原始错误。&lt;/li&gt;
&lt;li&gt;添加上下文，使用 [&lt;code&gt;&amp;quot;pkg/errors&amp;quot;.Wrap&lt;/code&gt;] 以便错误消息提供更多上下文 ,&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;&amp;quot;pkg/errors&amp;quot;.Cause&lt;/code&gt;&lt;/a&gt; 可用于提取原始错误。&lt;/li&gt;
&lt;li&gt;如果调用者不需要检测或处理的特定错误情况，使用 [&lt;code&gt;fmt.Errorf&lt;/code&gt;]。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;建议在可能的地方添加上下文，以使您获得诸如“调用服务 foo：连接被拒绝”之类的更有用的错误，而不是诸如“连接被拒绝”之类的模糊错误。&lt;/p&gt;
&lt;p&gt;在将上下文添加到返回的错误时，请避免使用“failed to”之类的短语以保持上下文简洁，这些短语会陈述明显的内容，并随着错误在堆栈中的渗透而逐渐堆积：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        &amp;quot;failed to create new store: %v&amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
s, err := store.New()
if err != nil {
    return fmt.Errorf(
        &amp;quot;new store: %v&amp;quot;, err)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;failed to x: failed to y: failed to create new store: the error
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;x: y: new store: the error
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;但是，一旦将错误发送到另一个系统，就应该明确消息是错误消息（例如使用&lt;code&gt;err&lt;/code&gt;标记，或在日志中以”Failed”为前缀）。&lt;/p&gt;
&lt;p&gt;另请参见 [Don&amp;rsquo;t just check errors, handle them gracefully]. 不要只是检查错误，要优雅地处理错误&lt;/p&gt;
&lt;p&gt;godoc.org/github.com/pkg/errors#Cause
[Don&amp;rsquo;t just check errors, handle them gracefully]: &lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://dave.cheney.net/2016/04/27/dont-just-check-errors-handle-them-gracefully&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;处理类型断言失败&#34;&gt;处理类型断言失败&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;type assertion&lt;/a&gt; 的单个返回值形式针对不正确的类型将产生 panic。因此，请始终使用“comma ok”的惯用法。&lt;/p&gt;
&lt;p&gt;golang.org/ref/spec#Type_assertions&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
t := i.(string)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
t, ok := i.(string)
if !ok {
  // 优雅地处理错误
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;不要-panic&#34;&gt;不要 panic&lt;/h3&gt;
&lt;p&gt;在生产环境中运行的代码必须避免出现 panic。panic 是 &lt;a class=&#34;link&#34; href=&#34;https://en.wikipedia.org/wiki/Cascading_failure&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;cascading failures&lt;/a&gt; 级联失败的主要根源 。如果发生错误，该函数必须返回错误，并允许调用方决定如何处理它。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func run(args []string) {
  if len(args) == 0 {
    panic(&amp;quot;an argument is required&amp;quot;)
  }
  // ...
}

func main() {
  run(os.Args[1:])
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func run(args []string) error {
  if len(args) == 0 {
    return errors.New(&amp;quot;an argument is required&amp;quot;)
  }
  // ...
  return nil
}

func main() {
  if err := run(os.Args[1:]); err != nil {
    fmt.Fprintln(os.Stderr, err)
    os.Exit(1)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;panic/recover 不是错误处理策略。仅当发生不可恢复的事情（例如：nil 引用）时，程序才必须 panic。程序初始化是一个例外：程序启动时应使程序中止的不良情况可能会引起 panic。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var _statusTemplate = template.Must(template.New(&amp;quot;name&amp;quot;).Parse(&amp;quot;_statusHTML&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;即使在测试代码中，也优先使用&lt;code&gt;t.Fatal&lt;/code&gt;或者&lt;code&gt;t.FailNow&lt;/code&gt;而不是 panic 来确保失败被标记。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// func TestFoo(t *testing.T)

f, err := ioutil.TempFile(&amp;quot;&amp;quot;, &amp;quot;test&amp;quot;)
if err != nil {
  panic(&amp;quot;failed to set up test&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// func TestFoo(t *testing.T)

f, err := ioutil.TempFile(&amp;quot;&amp;quot;, &amp;quot;test&amp;quot;)
if err != nil {
  t.Fatal(&amp;quot;failed to set up test&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;使用&#34;&gt;使用&lt;/h3&gt;
&lt;p&gt;go.uber.org/atomic&lt;/p&gt;
&lt;p&gt;使用 [sync/atomic] 包的原子操作对原始类型 (&lt;code&gt;int32&lt;/code&gt;, &lt;code&gt;int64&lt;/code&gt;等）进行操作，因为很容易忘记使用原子操作来读取或修改变量。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;
go.uber.org/atomic&lt;/a&gt; 通过隐藏基础类型为这些操作增加了类型安全性。此外，它包括一个方便的&lt;code&gt;atomic.Bool&lt;/code&gt;类型。&lt;/p&gt;
&lt;p&gt;godoc.org/
go.uber.org/atomic
[sync/atomic]: https://
golang.org/pkg/sync/atomic/&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type foo struct {
  running int32  // atomic
}

func (f* foo) start() {
  if atomic.SwapInt32(&amp;amp;f.running, 1) == 1 {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running == 1  // race!
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type foo struct {
  running atomic.Bool
}

func (f *foo) start() {
  if f.running.Swap(true) {
     // already running…
     return
  }
  // start the Foo
}

func (f *foo) isRunning() bool {
  return f.running.Load()
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;避免可变全局变量&#34;&gt;避免可变全局变量&lt;/h3&gt;
&lt;p&gt;使用选择依赖注入方式避免改变全局变量。
既适用于函数指针又适用于其他值类型&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// sign.
go
var _timeNow = time.Now
func sign(msg string) string {
  now := _timeNow()
  return signWithTime(msg, now)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// sign.
go
type signer struct {
  now func() time.Time
}
func newSigner() *signer {
  return &amp;amp;signer{
    now: time.Now,
  }
}
func (s *signer) Sign(msg string) string {
  now := s.now()
  return signWithTime(msg, now)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// sign_test.
go
func TestSign(t *testing.T) {
  oldTimeNow := _timeNow
  _timeNow = func() time.Time {
    return someFixedTime
  }
  defer func() { _timeNow = oldTimeNow }()
  assert.Equal(t, want, sign(give))
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// sign_test.
go
func TestSigner(t *testing.T) {
  s := newSigner()
  s.now = func() time.Time {
    return someFixedTime
  }
  assert.Equal(t, want, s.Sign(give))
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;避免在公共结构中嵌入类型&#34;&gt;避免在公共结构中嵌入类型&lt;/h3&gt;
&lt;p&gt;这些嵌入的类型泄漏实现细节、禁止类型演化和模糊的文档。&lt;/p&gt;
&lt;p&gt;假设您使用共享的 &lt;code&gt;AbstractList&lt;/code&gt; 实现了多种列表类型，请避免在具体的列表实现中嵌入 &lt;code&gt;AbstractList&lt;/code&gt;。
相反，只需手动将方法写入具体的列表，该列表将委托给抽象列表。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type AbstractList struct {}
// 添加将实体添加到列表中。
func (l *AbstractList) Add(e Entity) {
  // ...
}
// 移除从列表中移除实体。
func (l *AbstractList) Remove(e Entity) {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  *AbstractList
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  list *AbstractList
}
// 添加将实体添加到列表中。
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}
// 移除从列表中移除实体。
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;go 允许 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;类型嵌入&lt;/a&gt; 作为继承和组合之间的折衷。
外部类型获取嵌入类型的方法的隐式副本。
默认情况下，这些方法委托给嵌入实例的同一方法。&lt;/p&gt;
&lt;p&gt;golang.org/doc/effective_
go.html#embedding&lt;/p&gt;
&lt;p&gt;结构还获得与类型同名的字段。
所以，如果嵌入的类型是 public，那么字段是 public。为了保持向后兼容性，外部类型的每个未来版本都必须保留嵌入类型。&lt;/p&gt;
&lt;p&gt;很少需要嵌入类型。
这是一种方便，可以帮助您避免编写冗长的委托方法。&lt;/p&gt;
&lt;p&gt;即使嵌入兼容的抽象列表 &lt;em&gt;interface&lt;/em&gt;，而不是结构体，这将为开发人员提供更大的灵活性来改变未来，但仍然泄露了具体列表使用抽象实现的细节。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// AbstractList 是各种实体列表的通用实现。
type AbstractList interface {
  Add(Entity)
  Remove(Entity)
}
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  AbstractList
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// ConcreteList 是一个实体列表。
type ConcreteList struct {
  list AbstractList
}
// 添加将实体添加到列表中。
func (l *ConcreteList) Add(e Entity) {
  l.list.Add(e)
}
// 移除从列表中移除实体。
func (l *ConcreteList) Remove(e Entity) {
  l.list.Remove(e)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;无论是使用嵌入式结构还是使用嵌入式接口，嵌入式类型都会限制类型的演化.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;向嵌入式接口添加方法是一个破坏性的改变。&lt;/li&gt;
&lt;li&gt;删除嵌入类型是一个破坏性的改变。&lt;/li&gt;
&lt;li&gt;即使使用满足相同接口的替代方法替换嵌入类型，也是一个破坏性的改变。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管编写这些委托方法是乏味的，但是额外的工作隐藏了实现细节，留下了更多的更改机会，还消除了在文档中发现完整列表接口的间接性操作。&lt;/p&gt;
&lt;h3 id=&#34;避免使用内置名称&#34;&gt;避免使用内置名称&lt;/h3&gt;
&lt;p&gt;go语言规范&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;language specification&lt;/a&gt; 概述了几个内置的，
不应在
go项目中使用的名称标识[predeclared identifiers]。&lt;/p&gt;
&lt;p&gt;根据上下文的不同，将这些标识符作为名称重复使用，
将在当前作用域（或任何嵌套作用域）中隐藏原始标识符，或者混淆代码。
在最好的情况下，编译器会报错；在最坏的情况下，这样的代码可能会引入潜在的、难以恢复的错误。&lt;/p&gt;
&lt;p&gt;golang.org/ref/spec
[predeclared identifiers]: https://
golang.org/ref/spec#Predeclared_identifiers&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var error string
// `error` 作用域隐式覆盖

// or

func handleErrorMessage(error string) {
    // `error` 作用域隐式覆盖
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var errorMessage string
// `error` 指向内置的非覆盖

// or

func handleErrorMessage(msg string) {
    // `error` 指向内置的非覆盖
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Foo struct {
    // 虽然这些字段在技术上不构成阴影，但`error`或`string`字符串的重映射现在是不明确的。
    error  error
    string string
}

func (f Foo) Error() error {
    // `error` 和 `f.error` 在视觉上是相似的
    return f.error
}

func (f Foo) String() string {
    // `string` and `f.string` 在视觉上是相似的
    return f.string
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Foo struct {
    // `error` and `string` 现在是明确的。
    err error
    str string
}

func (f Foo) Error() error {
    return f.err
}

func (f Foo) String() string {
    return f.str
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;注意，编译器在使用预先分隔的标识符时不会生成错误，
但是诸如&lt;code&gt; go vet&lt;/code&gt;之类的工具会正确地指出这些和其他情况下的隐式问题。&lt;/p&gt;
&lt;h3 id=&#34;避免使用-init&#34;&gt;避免使用 &lt;code&gt;init()&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;尽可能避免使用&lt;code&gt;init()&lt;/code&gt;。当&lt;code&gt;init()&lt;/code&gt;是不可避免或可取的，代码应先尝试：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无论程序环境或调用如何，都要完全确定。&lt;/li&gt;
&lt;li&gt;避免依赖于其他&lt;code&gt;init()&lt;/code&gt;函数的顺序或副作用。虽然&lt;code&gt;init()&lt;/code&gt;顺序是明确的，但代码可以更改，
因此&lt;code&gt;init()&lt;/code&gt;函数之间的关系可能会使代码变得脆弱和容易出错。&lt;/li&gt;
&lt;li&gt;避免访问或操作全局或环境状态，如机器信息、环境变量、工作目录、程序参数/输入等。&lt;/li&gt;
&lt;li&gt;避免&lt;code&gt;I/O&lt;/code&gt;，包括文件系统、网络和系统调用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;不能满足这些要求的代码可能属于要作为&lt;code&gt;main()&lt;/code&gt;调用的一部分（或程序生命周期中的其他地方），
或者作为&lt;code&gt;main()&lt;/code&gt;本身的一部分写入。特别是，打算由其他程序使用的库应该特别注意完全确定性，
而不是执行“init magic”&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Foo struct {
    // ...
}
var _defaultFoo Foo
func init() {
    _defaultFoo = Foo{
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var _defaultFoo = Foo{
    // ...
}
// or, 为了更好的可测试性:
var _defaultFoo = defaultFoo()
func defaultFoo() Foo {
    return Foo{
        // ...
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Config struct {
    // ...
}
var _config Config
func init() {
    // Bad: 基于当前目录
    cwd, _ := os.Getwd()
    // Bad: I/O
    raw, _ := ioutil.ReadFile(
        path.Join(cwd, &amp;quot;config&amp;quot;, &amp;quot;config.yaml&amp;quot;),
    )
    yaml.Unmarshal(raw, &amp;amp;_config)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Config struct {
    // ...
}
func loadConfig() Config {
    cwd, err := os.Getwd()
    // handle err
    raw, err := ioutil.ReadFile(
        path.Join(cwd, &amp;quot;config&amp;quot;, &amp;quot;config.yaml&amp;quot;),
    )
    // handle err
    var config Config
    yaml.Unmarshal(raw, &amp;amp;config)
    return config
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;考虑到上述情况，在某些情况下，&lt;code&gt;init()&lt;/code&gt;可能更可取或是必要的，可能包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不能表示为单个赋值的复杂表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可插入的钩子，如&lt;code&gt;database/sql&lt;/code&gt;、编码类型注册表等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对&lt;a class=&#34;link&#34; href=&#34;https://cloud.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;
google Cloud Functions&lt;/a&gt;和其他形式的确定性预计算的优化。&lt;/p&gt;
&lt;p&gt;google.com/functions/docs/bestpractices/tips#use_global_variables_to_reuse_objects_in_future_invocations&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;追加时优先指定切片容量&#34;&gt;追加时优先指定切片容量&lt;/h3&gt;
&lt;p&gt;追加时优先指定切片容量&lt;/p&gt;
&lt;p&gt;在尽可能的情况下，在初始化要追加的切片时为&lt;code&gt;make()&lt;/code&gt;提供一个容量值。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for n := 0; n &amp;lt; b.N; n++ {
  data := make([]int, 0)
  for k := 0; k &amp;lt; size; k++{
    data = append(data, k)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for n := 0; n &amp;lt; b.N; n++ {
  data := make([]int, 0, size)
  for k := 0; k &amp;lt; size; k++{
    data = append(data, k)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BenchmarkBad-4    100000000    2.48s
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Benchmark
good-4   100000000    0.21s
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;主函数退出方式exit&#34;&gt;主函数退出方式(Exit)&lt;/h3&gt;
&lt;p&gt;go程序使用&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt;os.Exit&lt;/code&gt;&lt;/a&gt; 或者 [&lt;code&gt;log.Fatal*&lt;/code&gt;] 立即退出 (使用&lt;code&gt;panic&lt;/code&gt;不是退出程序的好方法，请 &lt;a class=&#34;link&#34; href=&#34;#%e4%b8%8d%e8%a6%81-panic&#34; &gt;don&amp;rsquo;t panic&lt;/a&gt;.)&lt;/p&gt;
&lt;p&gt;golang.org/pkg/os/#Exit
[&lt;code&gt;log.Fatal*&lt;/code&gt;]: https://
golang.org/pkg/log/#Fatal&lt;/p&gt;
&lt;p&gt;**仅在&lt;code&gt;main（）&lt;/code&gt;**中调用其中一个 &lt;code&gt;os.Exit&lt;/code&gt; 或者 &lt;code&gt;log.Fatal*&lt;/code&gt;。所有其他函数应将错误返回到信号失败中。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func main() {
  body := readFile(path)
  fmt.Println(body)
}
func readFile(path string) string {
  f, err := os.Open(path)
  if err != nil {
    log.Fatal(err)
  }
  b, err := ioutil.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }
  return string(b)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func main() {
  body, err := readFile(path)
  if err != nil {
    log.Fatal(err)
  }
  fmt.Println(body)
}
func readFile(path string) (string, error) {
  f, err := os.Open(path)
  if err != nil {
    return &amp;quot;&amp;quot;, err
  }
  b, err := ioutil.ReadAll(f)
  if err != nil {
    return &amp;quot;&amp;quot;, err
  }
  return string(b), nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;原则上：退出的具有多种功能的程序存在一些问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不明显的控制流：任何函数都可以退出程序，因此很难对控制流进行推理。&lt;/li&gt;
&lt;li&gt;难以测试：退出程序的函数也将退出调用它的测试。这使得函数很难测试，并引入了跳过 &lt;code&gt; go test&lt;/code&gt; 尚未运行的其他测试的风险。&lt;/li&gt;
&lt;li&gt;跳过清理：当函数退出程序时，会跳过已经进入&lt;code&gt;defer&lt;/code&gt;队列里的函数调用。这增加了跳过重要清理任务的风险。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;一次性退出&#34;&gt;一次性退出&lt;/h4&gt;
&lt;p&gt;如果可能的话，你的&lt;code&gt;main（）&lt;/code&gt;函数中&lt;strong&gt;最多一次&lt;/strong&gt; 调用 &lt;code&gt;os.Exit&lt;/code&gt;或者&lt;code&gt;log.Fatal&lt;/code&gt;。如果有多个错误场景停止程序执行，请将该逻辑放在单独的函数下并从中返回错误。
这会缩短 &lt;code&gt;main()&lt;/code&gt;函数，并将所有关键业务逻辑放入一个单独的、可测试的函数中。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
package main
func main() {
  args := os.Args[1:]
  if len(args) != 1 {
    log.Fatal(&amp;quot;missing file&amp;quot;)
  }
  name := args[0]
  f, err := os.Open(name)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()
  // 如果我们调用log.Fatal 在这条线之后
  // f.Close 将会被执行.
  b, err := ioutil.ReadAll(f)
  if err != nil {
    log.Fatal(err)
  }
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
package main
func main() {
  if err := run(); err != nil {
    log.Fatal(err)
  }
}
func run() error {
  args := os.Args[1:]
  if len(args) != 1 {
    return errors.New(&amp;quot;missing file&amp;quot;)
  }
  name := args[0]
  f, err := os.Open(name)
  if err != nil {
    return err
  }
  defer f.Close()
  b, err := ioutil.ReadAll(f)
  if err != nil {
    return err
  }
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;性能&#34;&gt;性能&lt;/h2&gt;
&lt;p&gt;性能方面的特定准则只适用于高频场景。&lt;/p&gt;
&lt;h3 id=&#34;优先使用-strconv-而不是-fmt&#34;&gt;优先使用 strconv 而不是 fmt&lt;/h3&gt;
&lt;p&gt;将原语转换为字符串或从字符串转换时，&lt;code&gt;strconv&lt;/code&gt;速度比&lt;code&gt;fmt&lt;/code&gt;快。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for i := 0; i &amp;lt; b.N; i++ {
  s := fmt.Sprint(rand.Int())
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for i := 0; i &amp;lt; b.N; i++ {
  s := strconv.Itoa(rand.Int())
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BenchmarkFmtSprint-4    143 ns/op    2 allocs/op
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BenchmarkStrconv-4    64.2 ns/op    1 allocs/op
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;避免字符串到字节的转换&#34;&gt;避免字符串到字节的转换&lt;/h3&gt;
&lt;p&gt;不要反复从固定字符串创建字节 slice。相反，请执行一次转换并捕获结果。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for i := 0; i &amp;lt; b.N; i++ {
  w.Write([]byte(&amp;quot;Hello world&amp;quot;))
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
data := []byte(&amp;quot;Hello world&amp;quot;)
for i := 0; i &amp;lt; b.N; i++ {
  w.Write(data)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BenchmarkBad-4   50000000   22.2 ns/op
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Benchmark
good-4  500000000   3.25 ns/op
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;指定容器容量&#34;&gt;指定容器容量&lt;/h3&gt;
&lt;p&gt;尽可能指定容器容量，以便为容器预先分配内存。这将在添加元素时最小化后续分配（通过复制和调整容器大小）。&lt;/p&gt;
&lt;h4 id=&#34;指定map容量提示&#34;&gt;指定Map容量提示&lt;/h4&gt;
&lt;p&gt;在尽可能的情况下，在使用 &lt;code&gt;make()&lt;/code&gt; 初始化的时候提供容量信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
make(map[T1]T2, hint)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向&lt;code&gt;make()&lt;/code&gt;提供容量提示会在初始化时尝试调整map的大小，这将减少在将元素添加到map时为map重新分配内存。&lt;/p&gt;
&lt;p&gt;注意，与slices不同。map capacity提示并不保证完全的抢占式分配，而是用于估计所需的hashmap bucket的数量。
因此，在将元素添加到map时，甚至在指定map容量时，仍可能发生分配。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
m := make(map[string]os.FileInfo)

files, _ := ioutil.ReadDir(&amp;quot;./files&amp;quot;)
for _, f := range files {
    m[f.Name()] = f
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go

files, _ := ioutil.ReadDir(&amp;quot;./files&amp;quot;)

m := make(map[string]os.FileInfo, len(files))
for _, f := range files {
    m[f.Name()] = f
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;m&lt;/code&gt; 是在没有大小提示的情况下创建的； 在运行时可能会有更多分配。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;&lt;code&gt;m&lt;/code&gt; 是有大小提示创建的；在运行时可能会有更少的分配。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h4 id=&#34;指定切片容量&#34;&gt;指定切片容量&lt;/h4&gt;
&lt;p&gt;在尽可能的情况下，在使用&lt;code&gt;make()&lt;/code&gt;初始化切片时提供容量信息，特别是在追加切片时。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
make([]T, length, capacity)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与maps不同，slice capacity不是一个提示：编译器将为提供给&lt;code&gt;make()&lt;/code&gt;的slice的容量分配足够的内存，
这意味着后续的append()`操作将导致零分配（直到slice的长度与容量匹配，在此之后，任何append都可能调整大小以容纳其他元素）。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for n := 0; n &amp;lt; b.N; n++ {
  data := make([]int, 0)
  for k := 0; k &amp;lt; size; k++{
    data = append(data, k)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for n := 0; n &amp;lt; b.N; n++ {
  data := make([]int, 0, size)
  for k := 0; k &amp;lt; size; k++{
    data = append(data, k)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;BenchmarkBad-4    100000000    2.48s
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Benchmark
good-4   100000000    0.21s
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;规范&#34;&gt;规范&lt;/h2&gt;
&lt;h3 id=&#34;一致性&#34;&gt;一致性&lt;/h3&gt;
&lt;p&gt;本文中概述的一些标准都是客观性的评估，是根据场景、上下文、或者主观性的判断；&lt;/p&gt;
&lt;p&gt;但是最重要的是，&lt;strong&gt;保持一致&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;一致性的代码更容易维护、是更合理的、需要更少的学习成本、并且随着新的约定出现或者出现错误后更容易迁移、更新、修复 bug&lt;/p&gt;
&lt;p&gt;相反，在一个代码库中包含多个完全不同或冲突的代码风格会导致维护成本开销、不确定性和认知偏差。所有这些都会直接导致速度降低、代码审查痛苦、而且增加 bug 数量。&lt;/p&gt;
&lt;p&gt;将这些标准应用于代码库时，建议在 package（或更大）级别进行更改，子包级别的应用程序通过将多个样式引入到同一代码中，违反了上述关注点。&lt;/p&gt;
&lt;h3 id=&#34;相似的声明放在一组&#34;&gt;相似的声明放在一组&lt;/h3&gt;
&lt;p&gt;go 语言支持将相似的声明放在一个组内。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
import &amp;quot;a&amp;quot;
import &amp;quot;b&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
import (
  &amp;quot;a&amp;quot;
  &amp;quot;b&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这同样适用于常量、变量和类型声明：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go

const a = 1
const b = 2

var a = 1
var b = 2

type Area float64
type Volume float64
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
const (
  a = 1
  b = 2
)

var (
  a = 1
  b = 2
)

type (
  Area float64
  Volume float64
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;仅将相关的声明放在一组。不要将不相关的声明放在一组。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
  EnvVar = &amp;quot;MY_ENV&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Operation int

const (
  Add Operation = iota + 1
  Subtract
  Multiply
)

const EnvVar = &amp;quot;MY_ENV&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;分组使用的位置没有限制，例如：你可以在函数内部使用它们：&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func f() string {
  var red = color.New(0xff0000)
  var green = color.New(0x00ff00)
  var blue = color.New(0x0000ff)

  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func f() string {
  var (
    red   = color.New(0xff0000)
    green = color.New(0x00ff00)
    blue  = color.New(0x0000ff)
  )

  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;import-分组&#34;&gt;import 分组&lt;/h3&gt;
&lt;p&gt;导入应该分为两组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;标准库&lt;/li&gt;
&lt;li&gt;其他库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下，这是
goimports 应用的分组。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;os&amp;quot;
  &amp;quot;
go.uber.org/atomic&amp;quot;
  &amp;quot;
golang.org/x/sync/errgroup&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;os&amp;quot;

  &amp;quot;
go.uber.org/atomic&amp;quot;
  &amp;quot;
golang.org/x/sync/errgroup&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;包名&#34;&gt;包名&lt;/h3&gt;
&lt;p&gt;当命名包时，请按下面规则选择一个名称：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全部小写。没有大写或下划线。&lt;/li&gt;
&lt;li&gt;大多数使用命名导入的情况下，不需要重命名。&lt;/li&gt;
&lt;li&gt;简短而简洁。请记住，在每个使用的地方都完整标识了该名称。&lt;/li&gt;
&lt;li&gt;不用复数。例如&lt;code&gt;net/url&lt;/code&gt;，而不是&lt;code&gt;net/urls&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;不要用“common”，“util”，“shared”或“lib”。这些是不好的，信息量不足的名称。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另请参阅 &lt;a class=&#34;link&#34; href=&#34;https://blog.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Package Names&lt;/a&gt; 和 [
go 包样式指南].&lt;/p&gt;
&lt;p&gt;golang.org/package-names
[
go 包样式指南]: &lt;a class=&#34;link&#34; href=&#34;https://rakyll.org/style-packages/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://rakyll.org/style-packages/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;函数名&#34;&gt;函数名&lt;/h3&gt;
&lt;p&gt;我们遵循
go 社区关于使用 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MixedCaps 作为函数名&lt;/a&gt; 的约定。有一个例外，为了对相关的测试用例进行分组，函数名可能包含下划线，如：&lt;code&gt;TestMyFunction_WhatIsBeingTested&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;golang.org/doc/effective_
go.html#mixed-caps&lt;/p&gt;
&lt;h3 id=&#34;导入别名&#34;&gt;导入别名&lt;/h3&gt;
&lt;p&gt;如果程序包名称与导入路径的最后一个元素不匹配，则必须使用导入别名。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
import (
  &amp;quot;net/http&amp;quot;

  client &amp;quot;example.com/client-
go&amp;quot;
  trace &amp;quot;example.com/trace/v2&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在所有其他情况下，除非导入之间有直接冲突，否则应避免导入别名。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;os&amp;quot;

  nettrace &amp;quot;
golang.net/x/trace&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
import (
  &amp;quot;fmt&amp;quot;
  &amp;quot;os&amp;quot;
  &amp;quot;runtime/trace&amp;quot;

  nettrace &amp;quot;
golang.net/x/trace&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;函数分组与顺序&#34;&gt;函数分组与顺序&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;函数应按粗略的调用顺序排序。&lt;/li&gt;
&lt;li&gt;同一文件中的函数应按接收者分组。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，导出的函数应先出现在文件中，放在&lt;code&gt;struct&lt;/code&gt;, &lt;code&gt;const&lt;/code&gt;, &lt;code&gt;var&lt;/code&gt;定义的后面。&lt;/p&gt;
&lt;p&gt;在定义类型之后，但在接收者的其余方法之前，可能会出现一个 &lt;code&gt;newXYZ()&lt;/code&gt;/&lt;code&gt;NewXYZ()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于函数是按接收者分组的，因此普通工具函数应在文件末尾出现。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func (s *something) Cost() {
  return calcCost(s.weights)
}

type something struct{ ... }

func calcCost(n []int) int {...}

func (s *something) Stop() {...}

func newSomething() *something {
    return &amp;amp;something{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type something struct{ ... }

func newSomething() *something {
    return &amp;amp;something{}
}

func (s *something) Cost() {
  return calcCost(s.weights)
}

func (s *something) Stop() {...}

func calcCost(n []int) int {...}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;减少嵌套&#34;&gt;减少嵌套&lt;/h3&gt;
&lt;p&gt;代码应通过尽可能先处理错误情况/特殊情况并尽早返回或继续循环来减少嵌套。减少嵌套多个级别的代码的代码量。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for _, v := range data {
  if v.F1 == 1 {
    v = process(v)
    if err := v.Call(); err == nil {
      v.Send()
    } else {
      return err
    }
  } else {
    log.Printf(&amp;quot;Invalid v: %v&amp;quot;, v)
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
for _, v := range data {
  if v.F1 != 1 {
    log.Printf(&amp;quot;Invalid v: %v&amp;quot;, v)
    continue
  }

  v = process(v)
  if err := v.Call(); err != nil {
    return err
  }
  v.Send()
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;不必要的-else&#34;&gt;不必要的 else&lt;/h3&gt;
&lt;p&gt;如果在 if 的两个分支中都设置了变量，则可以将其替换为单个 if。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var a int
if b {
  a = 100
} else {
  a = 10
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
a := 10
if b {
  a = 100
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;顶层变量声明&#34;&gt;顶层变量声明&lt;/h3&gt;
&lt;p&gt;在顶层，使用标准&lt;code&gt;var&lt;/code&gt;关键字。请勿指定类型，除非它与表达式的类型不同。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var _s string = F()

func F() string { return &amp;quot;A&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var _s = F()
// 由于 F 已经明确了返回一个字符串类型，因此我们没有必要显式指定_s 的类型
// 还是那种类型

func F() string { return &amp;quot;A&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果表达式的类型与所需的类型不完全匹配，请指定类型。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type myError struct{}

func (myError) Error() string { return &amp;quot;error&amp;quot; }

func F() myError { return myError{} }

var _e error = F()
// F 返回一个 myError 类型的实例，但是我们要 error 类型
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;对于未导出的顶层常量和变量使用_作为前缀&#34;&gt;对于未导出的顶层常量和变量，使用_作为前缀&lt;/h3&gt;
&lt;p&gt;在未导出的顶级&lt;code&gt;vars&lt;/code&gt;和&lt;code&gt;consts&lt;/code&gt;， 前面加上前缀_，以使它们在使用时明确表示它们是全局符号。&lt;/p&gt;
&lt;p&gt;例外：未导出的错误值，应以&lt;code&gt;err&lt;/code&gt;开头。&lt;/p&gt;
&lt;p&gt;基本依据：顶级变量和常量具有包范围作用域。使用通用名称可能很容易在其他文件中意外使用错误的值。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// foo.
go

const (
  defaultPort = 8080
  defaultUser = &amp;quot;user&amp;quot;
)

// bar.
go

func Bar() {
  defaultPort := 9090
  ...
  fmt.Println(&amp;quot;Default port&amp;quot;, defaultPort)

  // We will not see a compile error if the first line of
  // Bar() is deleted.
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// foo.
go

const (
  _defaultPort = 8080
  _defaultUser = &amp;quot;user&amp;quot;
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;结构体中的嵌入&#34;&gt;结构体中的嵌入&lt;/h3&gt;
&lt;p&gt;嵌入式类型（例如 mutex）应位于结构体内的字段列表的顶部，并且必须有一个空行将嵌入式字段与常规字段分隔开。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Client struct {
  version int
  http.Client
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Client struct {
  http.Client

  version int
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;内嵌应该提供切实的好处，比如以语义上合适的方式添加或增强功能。
它应该在对用户不利影响的情况下完成这项工作（另请参见：&lt;code&gt;避免在公共结构中嵌入类型&lt;/code&gt;&lt;a class=&#34;link&#34; href=&#34;#avoid-embedding-types-in-public-structs&#34; &gt;Avoid Embedding Types in Public Structs&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;嵌入 &lt;strong&gt;不应该&lt;/strong&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;纯粹是为了美观或方便。&lt;/li&gt;
&lt;li&gt;使外部类型更难构造或使用。&lt;/li&gt;
&lt;li&gt;影响外部类型的零值。如果外部类型有一个有用的零值，则在嵌入内部类型之后应该仍然有一个有用的零值。&lt;/li&gt;
&lt;li&gt;作为嵌入内部类型的副作用，从外部类型公开不相关的函数或字段。&lt;/li&gt;
&lt;li&gt;公开未导出的类型。&lt;/li&gt;
&lt;li&gt;影响外部类型的复制形式。&lt;/li&gt;
&lt;li&gt;更改外部类型的API或类型语义。&lt;/li&gt;
&lt;li&gt;嵌入内部类型的非规范形式。&lt;/li&gt;
&lt;li&gt;公开外部类型的实现详细信息。&lt;/li&gt;
&lt;li&gt;允许用户观察或控制类型内部。&lt;/li&gt;
&lt;li&gt;通过包装的方式改变内部函数的一般行为，这种包装方式会给用户带来一些意料之外情况。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单地说，有意识地和有目的地嵌入。一种很好的测试体验是，
&amp;ldquo;是否所有这些导出的内部方法/字段都将直接添加到外部类型&amp;rdquo;
如果答案是&lt;code&gt;some&lt;/code&gt;或&lt;code&gt;no&lt;/code&gt;，不要嵌入内部类型-而是使用字段。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type A struct {
    // Bad: A.Lock() and A.Unlock() 现在可用
    // 不提供任何功能性好处，并允许用户控制有关A的内部细节。
    sync.Mutex
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type countingWriteCloser struct {
    // 
good: Write() 在外层提供用于特定目的，
    // 并且委托工作到内部类型的Write()中。
    io.WriteCloser
    count int
}
func (w *countingWriteCloser) Write(bs []byte) (int, error) {
    w.count += len(bs)
    return w.WriteCloser.Write(bs)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Book struct {
    // Bad: 指针更改零值的有用性
    io.ReadWriter
    // other fields
}
// later
var b Book
b.Read(...)  // panic: nil pointer
b.String()   // panic: nil pointer
b.Write(...) // panic: nil pointer
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Book struct {
    // 
good: 有用的零值
    bytes.Buffer
    // other fields
}
// later
var b Book
b.Read(...)  // ok
b.String()   // ok
b.Write(...) // ok
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Client struct {
    sync.Mutex
    sync.WaitGroup
    bytes.Buffer
    url.URL
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Client struct {
    mtx sync.Mutex
    wg  sync.WaitGroup
    buf bytes.Buffer
    url url.URL
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;使用字段名初始化结构体&#34;&gt;使用字段名初始化结构体&lt;/h3&gt;
&lt;p&gt;初始化结构体时，应该指定字段名称。现在由 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt; go vet&lt;/code&gt;&lt;/a&gt; 强制执行。&lt;/p&gt;
&lt;p&gt;golang.org/cmd/vet/&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
k := User{&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;, true}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
k := User{
    FirstName: &amp;quot;John&amp;quot;,
    LastName: &amp;quot;Doe&amp;quot;,
    Admin: true,
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;例外：如果有 3 个或更少的字段，则可以在测试表中省略字段名称。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
tests := []struct{
  op Operation
  want string
}{
  {Add, &amp;quot;add&amp;quot;},
  {Subtract, &amp;quot;subtract&amp;quot;},
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;本地变量声明&#34;&gt;本地变量声明&lt;/h3&gt;
&lt;p&gt;如果将变量明确设置为某个值，则应使用短变量声明形式 (&lt;code&gt;:=&lt;/code&gt;)。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var s = &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
s := &amp;quot;foo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;但是，在某些情况下，&lt;code&gt;var&lt;/code&gt; 使用关键字时默认值会更清晰。例如，声明空切片。&lt;/p&gt;
&lt;p&gt;golang/
go/wiki/CodeReviewComments#declaring-empty-slices&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func f(list []int) {
  filtered := []int{}
  for _, v := range list {
    if v &amp;gt; 10 {
      filtered = append(filtered, v)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func f(list []int) {
  var filtered []int
  for _, v := range list {
    if v &amp;gt; 10 {
      filtered = append(filtered, v)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;nil-是一个有效的-slice&#34;&gt;nil 是一个有效的 slice&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nil&lt;/code&gt; 是一个有效的长度为 0 的 slice，这意味着，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;您不应明确返回长度为零的切片。应该返回&lt;code&gt;nil&lt;/code&gt; 来代替。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;good&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
if x == &amp;quot;&amp;quot; {
  return []int{}
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
if x == &amp;quot;&amp;quot; {
  return nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;要检查切片是否为空，请始终使用&lt;code&gt;len(s) == 0&lt;/code&gt;。而非 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;good&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func isEmpty(s []string) bool {
  return s == nil
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
func isEmpty(s []string) bool {
  return len(s) == 0
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;零值切片（用&lt;code&gt;var&lt;/code&gt;声明的切片）可立即使用，无需调用&lt;code&gt;make()&lt;/code&gt;创建。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;good&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;!-- raw HTML omitted --&gt;&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
nums := []int{}
// or, nums := make([]int)

if add1 {
  nums = append(nums, 1)
}

if add2 {
  nums = append(nums, 2)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var nums []int

if add1 {
  nums = append(nums, 1)
}

if add2 {
  nums = append(nums, 2)
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;记住，虽然nil切片是有效的切片，但它不等于长度为0的切片（一个为nil，另一个不是），并且在不同的情况下（例如序列化），这两个切片的处理方式可能不同。&lt;/p&gt;
&lt;h3 id=&#34;缩小变量作用域&#34;&gt;缩小变量作用域&lt;/h3&gt;
&lt;p&gt;如果有可能，尽量缩小变量作用范围。除非它与 &lt;a class=&#34;link&#34; href=&#34;#%e5%87%8f%e5%b0%91%e5%b5%8c%e5%a5%97&#34; &gt;减少嵌套&lt;/a&gt;的规则冲突。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
err := ioutil.WriteFile(name, data, 0644)
if err != nil {
 return err
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
if err := ioutil.WriteFile(name, data, 0644); err != nil {
 return err
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;如果需要在 if 之外使用函数调用的结果，则不应尝试缩小范围。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
if data, err := ioutil.ReadFile(name); err == nil {
  err = cfg.Decode(data)
  if err != nil {
    return err
  }

  fmt.Println(cfg)
  return nil
} else {
  return err
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
data, err := ioutil.ReadFile(name)
if err != nil {
   return err
}

if err := cfg.Decode(data); err != nil {
  return err
}

fmt.Println(cfg)
return nil
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;避免参数语义不明确avoid-naked-parameters&#34;&gt;避免参数语义不明确(Avoid Naked Parameters)&lt;/h3&gt;
&lt;p&gt;函数调用中的&lt;code&gt;意义不明确的参数&lt;/code&gt;可能会损害可读性。当参数名称的含义不明显时，请为参数添加 C 样式注释 (&lt;code&gt;/* ... */&lt;/code&gt;)&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// func printInfo(name string, isLocal, done bool)

printInfo(&amp;quot;foo&amp;quot;, true, true)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// func printInfo(name string, isLocal, done bool)

printInfo(&amp;quot;foo&amp;quot;, true /* isLocal */, true /* done */)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;对于上面的示例代码，还有一种更好的处理方式是将上面的 &lt;code&gt;bool&lt;/code&gt; 类型换成自定义类型。将来，该参数可以支持不仅仅局限于两个状态（true/false）。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type Region int

const (
  UnknownRegion Region = iota
  Local
)

type Status int

const (
  StatusReady Status= iota + 1
  StatusDone
  // Maybe we will have a StatusInProgress in the future.
)

func printInfo(name string, region Region, status Status)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;使用原始字符串字面值避免转义&#34;&gt;使用原始字符串字面值，避免转义&lt;/h3&gt;
&lt;p&gt;go 支持使用 [原始字符串字面值](https://
golang.org/ref/spec#raw_string_lit)，也就是 &amp;quot; ` &amp;quot; 来表示原生字符串，在需要转义的场景下，我们应该尽量使用这种方案来替换。&lt;/p&gt;
&lt;p&gt;可以跨越多行并包含引号。使用这些字符串可以避免更难阅读的手工转义的字符串。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
wantError := &amp;quot;unknown name:\&amp;quot;test\&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
wantError := `unknown error:&amp;quot;test&amp;quot;`
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;初始化结构体&#34;&gt;初始化结构体&lt;/h3&gt;
&lt;h4 id=&#34;使用字段名初始化结构&#34;&gt;使用字段名初始化结构&lt;/h4&gt;
&lt;p&gt;初始化结构时，几乎应该始终指定字段名。目前由&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;&lt;code&gt; go vet&lt;/code&gt;&lt;/a&gt;强制执行。&lt;/p&gt;
&lt;p&gt;golang.org/cmd/vet/&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
k := User{&amp;quot;John&amp;quot;, &amp;quot;Doe&amp;quot;, true}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
k := User{
    FirstName: &amp;quot;John&amp;quot;,
    LastName: &amp;quot;Doe&amp;quot;,
    Admin: true,
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;例外：当有3个或更少的字段时，测试表中的字段名&lt;em&gt;may&lt;/em&gt;可以省略。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
tests := []struct{
  op Operation
  want string
}{
  {Add, &amp;quot;add&amp;quot;},
  {Subtract, &amp;quot;subtract&amp;quot;},
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;省略结构中的零值字段&#34;&gt;省略结构中的零值字段&lt;/h4&gt;
&lt;p&gt;初始化具有字段名的结构时，除非提供有意义的上下文，否则忽略值为零的字段。
也就是，让我们自动将这些设置为零值&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
user := User{
  FirstName: &amp;quot;John&amp;quot;,
  LastName: &amp;quot;Doe&amp;quot;,
  MiddleName: &amp;quot;&amp;quot;,
  Admin: false,
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
user := User{
  FirstName: &amp;quot;John&amp;quot;,
  LastName: &amp;quot;Doe&amp;quot;,
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这有助于通过省略该上下文中的默认值来减少阅读的障碍。只指定有意义的值。&lt;/p&gt;
&lt;p&gt;在字段名提供有意义上下文的地方包含零值。例如，&lt;a class=&#34;link&#34; href=&#34;#%e8%a1%a8%e9%a9%b1%e5%8a%a8%e6%b5%8b%e8%af%95&#34; &gt;表驱动测试&lt;/a&gt; 中的测试用例可以受益于字段的名称，即使它们是零值的。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
tests := []struct{
  give string
  want int
}{
  {give: &amp;quot;0&amp;quot;, want: 0},
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;对零值结构使用-var&#34;&gt;对零值结构使用 &lt;code&gt;var&lt;/code&gt;&lt;/h4&gt;
&lt;p&gt;如果在声明中省略了结构的所有字段，请使用 &lt;code&gt;var&lt;/code&gt; 声明结构。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
user := User{}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var user User
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;这将零值结构与那些具有类似于为[初始化 Maps]创建的,区别于非零值字段的结构区分开来，
并与我们更喜欢的&lt;a class=&#34;link&#34; href=&#34;https://github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;declare empty slices&lt;/a&gt;方式相匹配。&lt;/p&gt;
&lt;h4 id=&#34;初始化-struct-引用&#34;&gt;初始化 Struct 引用&lt;/h4&gt;
&lt;p&gt;在初始化结构引用时，请使用&lt;code&gt;&amp;amp;T{}&lt;/code&gt;代替&lt;code&gt;new(T)&lt;/code&gt;，以使其与结构体初始化一致。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
sval := T{Name: &amp;quot;foo&amp;quot;}

// inconsistent
sptr := new(T)
sptr.Name = &amp;quot;bar&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
sval := T{Name: &amp;quot;foo&amp;quot;}

sptr := &amp;amp;T{Name: &amp;quot;bar&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;初始化-maps&#34;&gt;初始化 Maps&lt;/h3&gt;
&lt;p&gt;对于空 map 请使用 &lt;code&gt;make(..)&lt;/code&gt; 初始化， 并且 map 是通过编程方式填充的。
这使得 map 初始化在表现上不同于声明，并且它还可以方便地在 make 后添加大小提示。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var (
  // m1 读写安全;
  // m2 在写入时会 panic
  m1 = map[T1]T2{}
  m2 map[T1]T2
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
var (
  // m1 读写安全;
  // m2 在写入时会 panic
  m1 = make(map[T1]T2)
  m2 map[T1]T2
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;声明和初始化看起来非常相似的。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;声明和初始化看起来差别非常大。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;在尽可能的情况下，请在初始化时提供 map 容量大小，详细请看 &lt;a class=&#34;link&#34; href=&#34;#%e6%8c%87%e5%ae%9aMap%e5%ae%b9%e9%87%8f%e6%8f%90%e7%a4%ba&#34; &gt;指定Map容量提示&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，如果 map 包含固定的元素列表，则使用 map literals(map 初始化列表) 初始化映射。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
m := make(map[T1]T2, 3)
m[k1] = v1
m[k2] = v2
m[k3] = v3
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
m := map[T1]T2{
  k1: v1,
  k2: v2,
  k3: v3,
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;基本准则是：在初始化时使用 map 初始化列表 来添加一组固定的元素。否则使用 &lt;code&gt;make&lt;/code&gt; (如果可以，请尽量指定 map 容量)。&lt;/p&gt;
&lt;h3 id=&#34;字符串-string-format&#34;&gt;字符串 string format&lt;/h3&gt;
&lt;p&gt;如果你在函数外声明&lt;code&gt;Printf&lt;/code&gt;-style 函数的格式字符串，请将其设置为&lt;code&gt;const&lt;/code&gt;常量。&lt;/p&gt;
&lt;p&gt;这有助于&lt;code&gt; go vet&lt;/code&gt;对格式字符串执行静态分析。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
msg := &amp;quot;unexpected values %v, %v\n&amp;quot;
fmt.Printf(msg, 1, 2)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
const msg = &amp;quot;unexpected values %v, %v\n&amp;quot;
fmt.Printf(msg, 1, 2)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;h3 id=&#34;命名-printf-样式的函数&#34;&gt;命名 Printf 样式的函数&lt;/h3&gt;
&lt;p&gt;声明&lt;code&gt;Printf&lt;/code&gt;-style 函数时，请确保&lt;code&gt; go vet&lt;/code&gt;可以检测到它并检查格式字符串。&lt;/p&gt;
&lt;p&gt;这意味着您应尽可能使用预定义的&lt;code&gt;Printf&lt;/code&gt;-style 函数名称。&lt;code&gt; go vet&lt;/code&gt;将默认检查这些。有关更多信息，请参见 &lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Printf 系列&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;golang.org/cmd/vet/#hdr-Printf_family&lt;/p&gt;
&lt;p&gt;如果不能使用预定义的名称，请以 f 结束选择的名称：&lt;code&gt;Wrapf&lt;/code&gt;，而不是&lt;code&gt;Wrap&lt;/code&gt;。&lt;code&gt; go vet&lt;/code&gt;可以要求检查特定的 Printf 样式名称，但名称必须以&lt;code&gt;f&lt;/code&gt;结尾。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;$ 
go vet -printfuncs&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;wrapf,statusf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;另请参阅 &lt;a class=&#34;link&#34; href=&#34;https://kuzminva.wordpress.com/2017/11/07/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;
go vet: Printf family check&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;go-vet-printf-family-check/&lt;/p&gt;
&lt;h2 id=&#34;编程模式&#34;&gt;编程模式&lt;/h2&gt;
&lt;h3 id=&#34;表驱动测试&#34;&gt;表驱动测试&lt;/h3&gt;
&lt;p&gt;当测试逻辑是重复的时候，通过  &lt;a class=&#34;link&#34; href=&#34;https://blog.&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;subtests&lt;/a&gt; 使用 table 驱动的方式编写 case 代码看上去会更简洁。&lt;/p&gt;
&lt;p&gt;golang.org/subtests&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// func TestSplitHostPort(t *testing.T)

host, port, err := net.SplitHostPort(&amp;quot;192.0.2.0:8000&amp;quot;)
require.NoError(t, err)
assert.Equal(t, &amp;quot;192.0.2.0&amp;quot;, host)
assert.Equal(t, &amp;quot;8000&amp;quot;, port)

host, port, err = net.SplitHostPort(&amp;quot;192.0.2.0:http&amp;quot;)
require.NoError(t, err)
assert.Equal(t, &amp;quot;192.0.2.0&amp;quot;, host)
assert.Equal(t, &amp;quot;http&amp;quot;, port)

host, port, err = net.SplitHostPort(&amp;quot;:8000&amp;quot;)
require.NoError(t, err)
assert.Equal(t, &amp;quot;&amp;quot;, host)
assert.Equal(t, &amp;quot;8000&amp;quot;, port)

host, port, err = net.SplitHostPort(&amp;quot;1:8&amp;quot;)
require.NoError(t, err)
assert.Equal(t, &amp;quot;1&amp;quot;, host)
assert.Equal(t, &amp;quot;8&amp;quot;, port)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// func TestSplitHostPort(t *testing.T)

tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  {
    give:     &amp;quot;192.0.2.0:8000&amp;quot;,
    wantHost: &amp;quot;192.0.2.0&amp;quot;,
    wantPort: &amp;quot;8000&amp;quot;,
  },
  {
    give:     &amp;quot;192.0.2.0:http&amp;quot;,
    wantHost: &amp;quot;192.0.2.0&amp;quot;,
    wantPort: &amp;quot;http&amp;quot;,
  },
  {
    give:     &amp;quot;:8000&amp;quot;,
    wantHost: &amp;quot;&amp;quot;,
    wantPort: &amp;quot;8000&amp;quot;,
  },
  {
    give:     &amp;quot;1:8&amp;quot;,
    wantHost: &amp;quot;1&amp;quot;,
    wantPort: &amp;quot;8&amp;quot;,
  },
}

for _, tt := range tests {
  t.Run(tt.give, func(t *testing.T) {
    host, port, err := net.SplitHostPort(tt.give)
    require.NoError(t, err)
    assert.Equal(t, tt.wantHost, host)
    assert.Equal(t, tt.wantPort, port)
  })
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;很明显，使用 test table 的方式在代码逻辑扩展的时候，比如新增 test case，都会显得更加的清晰。&lt;/p&gt;
&lt;p&gt;我们遵循这样的约定：将结构体切片称为&lt;code&gt;tests&lt;/code&gt;。 每个测试用例称为&lt;code&gt;tt&lt;/code&gt;。此外，我们鼓励使用&lt;code&gt;give&lt;/code&gt;和&lt;code&gt;want&lt;/code&gt;前缀说明每个测试用例的输入和输出值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
tests := []struct{
  give     string
  wantHost string
  wantPort string
}{
  // ...
}

for _, tt := range tests {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;功能选项&#34;&gt;功能选项&lt;/h3&gt;
&lt;p&gt;功能选项是一种模式，您可以在其中声明一个不透明 Option 类型，该类型在某些内部结构中记录信息。您接受这些选项的可变编号，并根据内部结构上的选项记录的全部信息采取行动。&lt;/p&gt;
&lt;p&gt;将此模式用于您需要扩展的构造函数和其他公共 API 中的可选参数，尤其是在这些功能上已经具有三个或更多参数的情况下。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// package db

func Open(
  addr string,
  cache bool,
  logger *zap.Logger
) (*Connection, error) {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
// package db

type Option interface {
  // ...
}

func WithCache(c bool) Option {
  // ...
}

func WithLogger(log *zap.Logger) Option {
  // ...
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;必须始终提供缓存和记录器参数，即使用户希望使用默认值。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
db.Open(addr, db.DefaultCache, zap.NewNop())
db.Open(addr, db.DefaultCache, log)
db.Open(addr, false /* cache */, zap.NewNop())
db.Open(addr, false /* cache */, log)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;只有在需要时才提供选项。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
db.Open(addr)
db.Open(addr, db.WithLogger(log))
db.Open(addr, db.WithCache(false))
db.Open(
  addr,
  db.WithCache(false),
  db.WithLogger(log),
)
&lt;/code&gt;&lt;/pre&gt;&lt;!-- raw HTML omitted --&gt;
&lt;p&gt;Our suggested way of implementing this pattern is with an &lt;code&gt;Option&lt;/code&gt; interface
that holds an unexported method, recording options on an unexported &lt;code&gt;options&lt;/code&gt;
struct.&lt;/p&gt;
&lt;p&gt;我们建议实现此模式的方法是使用一个 &lt;code&gt;Option&lt;/code&gt; 接口，该接口保存一个未导出的方法，在一个未导出的 &lt;code&gt;options&lt;/code&gt; 结构上记录选项。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;go
type options struct {
  cache  bool
  logger *zap.Logger
}

type Option interface {
  apply(*options)
}

type cacheOption bool

func (c cacheOption) apply(opts *options) {
  opts.cache = bool(c)
}

func WithCache(c bool) Option {
  return cacheOption(c)
}

type loggerOption struct {
  Log *zap.Logger
}

func (l loggerOption) apply(opts *options) {
  opts.logger = l.Log
}

func WithLogger(log *zap.Logger) Option {
  return loggerOption{Log: log}
}

// Open creates a connection.
func Open(
  addr string,
  opts ...Option,
) (*Connection, error) {
  options := options{
    cache:  defaultCache,
    logger: zap.NewNop(),
  }

  for _, o := range opts {
    o.apply(&amp;amp;options)
  }

  // ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;注意: 还有一种使用闭包实现这个模式的方法，但是我们相信上面的模式为作者提供了更多的灵活性，并且更容易对用户进行调试和测试。特别是，在不可能进行比较的情况下它允许在测试和模拟中对选项进行比较。此外，它还允许选项实现其他接口，包括 &lt;code&gt;fmt.Stringer&lt;/code&gt;，允许用户读取选项的字符串表示形式。&lt;/p&gt;
&lt;p&gt;还可以参考下面资料：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://commandcenter.blogspot.com/2014/01/self-referential-functions-and-design.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Self-referential functions and the design of options&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Functional options for friendly APIs&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;linting&#34;&gt;Linting&lt;/h2&gt;
&lt;p&gt;比任何 &amp;ldquo;blessed&amp;rdquo; linter 集更重要的是，lint在一个代码库中始终保持一致。&lt;/p&gt;
&lt;p&gt;我们建议至少使用以下linters，因为我认为它们有助于发现最常见的问题，并在不需要规定的情况下为代码质量建立一个高标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/kisielk/errcheck&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;errcheck&lt;/a&gt; 以确保错误得到处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;
goimports&lt;/a&gt; 格式化代码和管理 imports&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[
golint] 指出常见的文体错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[
govet] 分析代码中的常见错误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[staticcheck] 各种静态分析检查&lt;/p&gt;
&lt;p&gt;godoc.org/
golang.org/x/tools/cmd/
goimports
[
golint]: &lt;a class=&#34;link&#34; href=&#34;https://github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/&lt;/a&gt;
golang/lint
[
govet]: https://
golang.org/cmd/vet/
[staticcheck]: &lt;a class=&#34;link&#34; href=&#34;https://staticcheck.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://staticcheck.io/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lint-runners&#34;&gt;Lint Runners&lt;/h3&gt;
&lt;p&gt;我们推荐 &lt;a class=&#34;link&#34; href=&#34;https://github.com/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;
golangci-lint&lt;/a&gt; 作为
go-to lint的运行程序，这主要是因为它在较大的代码库中的性能以及能够同时配置和使用许多规范。这个repo有一个示例配置文件[.
golangci.yml]和推荐的linter设置。&lt;/p&gt;
&lt;p&gt;golangci-lint 有[various-linters]可供使用。建议将上述linters作为基本set，我们鼓励团队添加对他们的项目有意义的任何附加linters。&lt;/p&gt;
&lt;p&gt;golangci/
golangci-lint
[.
golangci.yml]: &lt;a class=&#34;link&#34; href=&#34;https://github.com/uber-&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/uber-&lt;/a&gt;
go/guide/blob/master/.
golangci.yml
[various-linters]: https://
golangci-lint.run/usage/linters/&lt;/p&gt;
&lt;h2 id=&#34;stargazers-over-time&#34;&gt;Stargazers over time&lt;/h2&gt;
&lt;p&gt;[![Stargazers over time](https://starchart.cc/xxjwxc/uber_
go_guide_cn.svg)](&lt;a class=&#34;link&#34; href=&#34;https://starchart.cc/xxjwxc/uber_&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://starchart.cc/xxjwxc/uber_&lt;/a&gt;
go_guide_cn)&lt;/p&gt;
</description>
        </item>
        <item>
        <title>内存管理</title>
        <link>https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</link>
        <pubDate>Mon, 18 Oct 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6.png" alt="Featured image of post 内存管理" /&gt;&lt;h2 id=&#34;虚拟地址空间布局&#34;&gt;虚拟地址空间布局&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;程序通过编译成为一堆的机器指令写入可执行文件，程序在运行是会将可执行文件加载在计算机的内存中
在虚拟地址空间分布中处于代码段。&lt;/li&gt;
&lt;li&gt;程序中的局部变量、函数的参数、函数的返回值等数据会保存在虚拟地址的栈中(栈是先进后出的数据结构)
栈空间的编译器分配和释放。&lt;/li&gt;
&lt;li&gt;程序的全局变量和静态变量会保存在虚拟地址的数据段&lt;/li&gt;
&lt;li&gt;动态分配内存的地址会保存在虚拟地址空间的堆上。堆空间是动态开辟的内存空间，需要主动开辟和释放。或者
调用GC释放  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 68; 
			flex-basis: 165px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.png&#34; data-size=&#34;547x795&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.png&#34;
			width=&#34;547&#34;
			height=&#34;795&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1_hu86f620222550b5f6f6b08ef9da75c8f9_105109_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1_hu86f620222550b5f6f6b08ef9da75c8f9_105109_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;堆内存管理&#34;&gt;堆内存管理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;堆内存空间不是编译器分配，而是有程序动态分配的内存空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;手动垃圾回收&#34;&gt;手动垃圾回收&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;需要程序主动释放没有用的数据所在的堆空间。如：c++中调用new()函数向计算机申请开辟内存空间后，使用delete或delete[]释放不需要的
堆内存空间。这一类是手动内存分配和释放。手动内存分配使用不恰当也会造成：内存泄露
悬挂指针的问题&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;过早释放会造成悬挂指针（野指针）：提前释放了动态的堆内存的空间，当程序访问这段地址时会报错。因为这段提前释放的内存空间被清空、
重新分配或者被操作系统回收。释放指针时将指针赋值为NULL，在访问时对指针进行判断是否为NULL&lt;/li&gt;
&lt;li&gt;不释放内存会造成内存泄漏：堆内存需要手动释放，当程序运行结束不释放，这段内存就会被一直占用。如果
一直在分配不释放会一直占用计算机的内存，直到内存被占完。将new与delete配套使用，使用工具检测或者打印出堆信息&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;自动垃圾回收gc&#34;&gt;自动垃圾回收（GC）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在程序运行过程中自动释放没有用的数据所在的堆空间（垃圾回收).在虚拟内存空间中能从栈或者数据段的根节点追踪不到的数据为没用的数据
（内存垃圾），常用的算法：标记法, 计数法&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;标记法回收&#34;&gt;标记法回收&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;标记法：将栈或者数据段作为根（root）进行追踪,将能追踪得的数据（堆空间）进行标记。没有被标记的数据
（堆空间）就是垃圾，将这部分垃圾进行回收。三色抽象：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;垃圾回收开始时，将所有数据为白色&lt;/li&gt;
&lt;li&gt;垃圾回收开始时，将所有的栈或者数据段的根节点设置为灰色&lt;/li&gt;
&lt;li&gt;在根据根节点进行追踪，直到所有的数据节点追踪结束后将根节点置为黑色，在将根节点的下一节点作为根节点进行追踪&lt;/li&gt;
&lt;li&gt;所有的数据节点都追踪完后，会剩下黑色和白色的数据节点。黑色表示有用的数据。白色为无用的数据。将白色的数据进行回收（堆空间的释放）
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 106; 
			flex-basis: 256px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.png&#34; data-size=&#34;739x692&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2.png&#34;
			width=&#34;739&#34;
			height=&#34;692&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2_hue8f862e9d9f89ba7caf7892b05f14474_215690_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/2_hue8f862e9d9f89ba7caf7892b05f14474_215690_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;标记法实现简单，但是会造成内存的碎片化(内存块中是可使用小内存块，造成大内存块不能使用这块内存，这些小小内存块也不能使用)&lt;/li&gt;
&lt;li&gt;因为内存碎片化的问题诞生了&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;标记整理法，就是标记法之后，将有用的数据堆内存空间移动在一起，释放更多连续的堆空间,但是这种做法带来
很大的开销，因为需要不断的扫描内存和移动内存&lt;/li&gt;
&lt;li&gt;复制回收法。将堆内存分为from和To两个相同的堆内存空间。程序执行时，使用from的堆空间。垃圾回收时会扫描from
的堆内存空间，将有用的数据复制到To的堆空间上。垃圾回收结束时，将To堆空间设置为From堆空间。将原来的from
堆空间全部回收后置为Ton堆空间。但是复制回收法只会使用一般的堆内存空间，造成堆内存空间利用率不高  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 190; 
			flex-basis: 456px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.png&#34; data-size=&#34;746x392&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3.png&#34;
			width=&#34;746&#34;
			height=&#34;392&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3_hu871100705c5f0bb9545d50108b3adbcf_40782_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/3_hu871100705c5f0bb9545d50108b3adbcf_40782_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;分代法回收：大部分对象都会在年轻时候死亡（弱分代假说）把新建的对象称之为新生代对象。经过特定次数的GC(垃圾回收)数据依然有用的对象称为
老年代对象。而大部分会在新生代对象就会垃圾回收了，在结合复制回收法使用  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 165; 
			flex-basis: 397px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4.png&#34; data-size=&#34;1202x725&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4.png&#34;
			width=&#34;1202&#34;
			height=&#34;725&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4_hude966255b53ebc705801aec78916c5d7_175139_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/4_hude966255b53ebc705801aec78916c5d7_175139_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;计数法回收&#34;&gt;计数法回收&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;引用计数指的是对象被引用的次数，程序在运行过程中会更新引用次数。对象引用越多，计数越大，当计数为0时，回收该对象（堆内存空间）
引用计数法可以在运行中更新对象的计数，可以及时判断计数为 0的对象，然后对其及时回收， 但是频繁的更新引用计数也会带来资源消耗  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 103; 
			flex-basis: 248px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5.png&#34; data-size=&#34;712x688&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5.png&#34;
			width=&#34;712&#34;
			height=&#34;688&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5_hu5f49777c171d0884056300bcd3c13161_71471_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/5_hu5f49777c171d0884056300bcd3c13161_71471_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;垃圾回收模式&#34;&gt;垃圾回收模式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;增量式的垃圾回收模式：SWT是用户承程序停下工作处理垃圾回收，但是为了提高cpu执行效率，会减少SWT的时间，经垃圾回收工作分多次进行（用户程序与垃圾回收交替执行）&lt;/li&gt;
&lt;li&gt;三色不变式：在增量式垃圾回收模式在进行垃圾回收时，会造成用户程序对标色的数据进行更改，当在次执行垃圾回收时，可能会将有用的数据当作垃圾回收了，在标色法中，当黑色数据节点可以引用白色的数据节点，但是没有灰色节点能引用这个白色节点，白色数据节点就被当作垃圾被回收
避免这样的发生，在垃圾回收时建立读写屏障。在三色中确保黑色的数据节点不引用白色的数据节点，就不会误判有用的数据当作垃圾回收了，这种叫做：强三色不变式
如果当黑色的数据节点能引用白色数据节点，同时确保回收节点也能引用白色节点，也能避免有用的数据被当作垃圾回收，这叫：弱三色不变式  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 177; 
			flex-basis: 425px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6.png&#34; data-size=&#34;1302x734&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6.png&#34;
			width=&#34;1302&#34;
			height=&#34;734&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6_hu61bd622d583377d86db238f2ea3bdaa9_262966_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/6_hu61bd622d583377d86db238f2ea3bdaa9_262966_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;并行垃圾回收：在多核下，使用多线程对垃圾回收，需要做好的负载均衡和规避数重复处理带来的问题，如在复制回收中，可能将同样的数据从from复制到to&lt;/li&gt;
&lt;li&gt;并发垃圾回收：垃圾回收与用户程序并发执行，可能会造成垃圾回收与用户程序的资源竞争等问题等&lt;/li&gt;
&lt;li&gt;主体并发回收：在时刻使用swt回收，在莫时刻又使用并发垃圾回收&lt;/li&gt;
&lt;li&gt;主体并发增量式回收: 是融合了增量式的垃圾回收模式和主体并发回收模式  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 67; 
			flex-basis: 161px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7.png&#34; data-size=&#34;549x817&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7.png&#34;
			width=&#34;549&#34;
			height=&#34;817&#34;
			srcset=&#34;https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7_hu9a89830b3bbfb2c96296aa9cbf536ee0_141902_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/7_hu9a89830b3bbfb2c96296aa9cbf536ee0_141902_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;1.&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/people/kylin-lab&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/people/kylin-lab&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go Channel的深入理解</title>
        <link>https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link>
        <pubDate>Fri, 15 Oct 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png" alt="Featured image of post Go Channel的深入理解" /&gt;&lt;h1 id=&#34;go-channel&#34;&gt;go Channel&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;（&lt;strong&gt;Do not communicate by sharing memory; instead, share memory by communicating&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;csp并发模型&#34;&gt;CSP并发模型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CSP&lt;/strong&gt; 即&lt;strong&gt;通信顺序进程&lt;/strong&gt;、&lt;strong&gt;交谈循序程序&lt;/strong&gt;，又被译为&lt;strong&gt;交换消息的循序程序&lt;/strong&gt;(communicating sequential processes)，它是一种用来描述并发性系统之间进行交互的模型。&lt;/li&gt;
&lt;li&gt;go  Channe是一种特殊的类型，是有特定类型的队列。是链接goroutine(协程)的通信机制，通过通信共享内存而不是通过共享内存而实现通信.&lt;/li&gt;
&lt;li&gt;Channel 收发操作均遵循了先进先出的设计，具体规则如下：
&lt;ol&gt;
&lt;li&gt;先从 Channel 读取数据的 Goroutine 会先接收到数据；&lt;/li&gt;
&lt;li&gt;先向 Channel 发送数据的 Goroutine 会得到先发送数据的权利；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 324; 
			flex-basis: 779px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1.png&#34; data-size=&#34;646x199&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1.png&#34;
			width=&#34;646&#34;
			height=&#34;199&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1_hu9f71752e01ad0714d9e001d394dc9e2e_27512_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1_hu9f71752e01ad0714d9e001d394dc9e2e_27512_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;channel-数据结构定义&#34;&gt;channel 数据结构定义：&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type hchan struct {
	// 队列中存储的数量
	qcount   uint           // total data in the queue
	//环形队列的大小(最大存储数量 )
	dataqsiz uint           // size of the circular queue
	// 存放环形队列的数据，数组
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	// 元素的大小
	elemsize uint16
	// 是否关闭的标识
	closed   uint32
	// 元素的类型(指向类型的元数据 )
	elemtype *_type // element type
	// 当前发送数据在环形队列的索引
	sendx    uint   // send index
	// 当前接受数据在环形队列的索引 
	recvx    uint   // receive index
	// 接收者等待队列（&amp;lt;-ch）阻塞在channel的协程队列
	recvq    waitq  // list of recv waiters
	// 发送者等待队列（ch&amp;lt;- data）阻塞在channel的协程队列
	sendq    waitq  // list of send waiters
	//锁保护hchan中的所有字段，以及几个
	//在这个通道上阻塞sudogs中的字段
	//保持这个锁时不要改变另一个G的状态
	//(特别是，不要准备一个G)，因为这可能会死锁
	//栈收缩。
	lock mutex  // 保护hchan中的所有字段，保持协程的状态不被更改，避免造成栈收缩引起的死锁，使用互斥锁解决程序中可能存在的线程竞争问题是很常见的
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;发送者/接收者等待队列的结构：一个双向链表
type waitq struct {
	first *sudog
	last  *sudog
}
&lt;/code&gt;&lt;/pre&gt;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;channel  sudog(等待队列)结构如下
type sudog struct {
	// The following fields are protected by the hchan.lock of the
	// channel this sudog is blocking on. shrinkstack depends on
	// this for sudogs involved in channel ops.
	//以下字段受hchan保护。锁的
  	//这个sudog正在阻塞。shrinkstack取决于
	//这是为涉及通道操作的sudogs。

	g *g  // 等待的协程协程
	next *sudog
	prev *sudog
	// 数据元素(可以指向堆栈)，等待发送/接收的数据
	elem unsafe.Pointer // data element (may point to stack)

	// The following fields are never accessed concurrently.
	// For channels, waitlink is only accessed by g.
	// For semaphores, all fields (including the ones above)
	// are only accessed when holding a semaRoot lock.
	//下面的字段永远不会并发访问。
   	//对于通道，waitlink只被g访问。
	//对于信号量，所有的字段(包括上面的字段)
	//只在持有semaRoot锁时访问。
	acquiretime int64
	releasetime int64
	ticket      uint32

	// isSelect indicates g is participating in a select, so
	// g.selectDone must be CAS&#39;d to win the wake-up race.
	// 表示g被选择
	isSelect bool

	// success indicates whether communication over channel c
	// succeeded. It is true if the goroutine was awoken because a
	// value was delivered over channel c, and false if awoken
	// because c was closed.
	//成功表示是否通过通道c通信
	// 成功了。 如果 goroutine 被唤醒是因为一个
	// 值通过通道 c 传递，如果被唤醒则返回 false
	// 因为 c 被关闭了
	success bool  // c 因关闭而唤醒

	parent   *sudog // semaRoot binary tree
	waitlink *sudog // g.waiting list or semaRoot
	waittail *sudog // semaRoot
    // 等待的channel被唤醒
	c        *hchan // channel
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;结构如图所示
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 188; 
			flex-basis: 451px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png&#34; data-size=&#34;1618x860&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png&#34;
			width=&#34;1618&#34;
			height=&#34;860&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_huc32f323c0433538c753e80bb5a9a01bb_276268_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_huc32f323c0433538c753e80bb5a9a01bb_276268_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;channel-创建&#34;&gt;channel 创建&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;channel 和 切片、map一样，需要使用make(chan type, int )才能使用,应为make()会调用makeChan()初始化&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;makech函数源码如下:
// 参数类型：创建chan的类型和环型缓冲区的数量
func makechan(t *chantype, size int) *hchan {
	elem := t.elem

	// compiler checks this but be safe.
	if elem.size &amp;gt;= 1&amp;lt;&amp;lt;16 {
		throw(&amp;quot;makechan: invalid channel element type&amp;quot;)
	}
	if hchanSize%maxAlign != 0 || elem.align &amp;gt; maxAlign {
		throw(&amp;quot;makechan: bad alignment&amp;quot;)
	}
	//判断环型缓冲区是否溢出
	mem, overflow := math.MulUintptr(elem.size, uintptr(size))
	if overflow || mem &amp;gt; maxAlloc-hchanSize || size &amp;lt; 0 {
		panic(plainError(&amp;quot;makechan: size out of range&amp;quot;))
	}

	// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
	// buf points into the same allocation, elemtype is persistent.
	// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
	// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
	var c *hchan
	switch {
	case mem == 0:
		// Queue or element size is zero.
		// 当队列或者元素大小为0时，定义无缓冲chan（同步chan）
		c = (*hchan)(mallocgc(hchanSize, nil, true))
		// Race detector uses this location for synchronization.
        // Race 竞争检查利用这个地址来进行同步操作
		c.buf = c.raceaddr()
	case elem.ptrdata == 0:
		// Elements do not contain pointers.
		// Allocate hchan and buf in one call.
        // 元素不包含指针时。一次分配 hchan 和 buf 的内存。
		c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
		c.buf = add(unsafe.Pointer(c), hchanSize)
	default:
		// Elements contain pointers.
        // 定义带缓存的chan或者异步的chan
		c = new(hchan)
		c.buf = mallocgc(mem, elem, true)
	}

	c.elemsize = uint16(elem.size)  // chan元素的大小
	c.elemtype = elem               // chan元素的类型
	c.dataqsiz = uint(size)        //  chan缓存区大小
	lockInit(&amp;amp;c.lock, lockRankHchan)  //初始化互斥锁

	if debugChan {
		print(&amp;quot;makechan: chan=&amp;quot;, c, &amp;quot;; elemsize=&amp;quot;, elem.size, &amp;quot;; dataqsiz=&amp;quot;, size, &amp;quot;\n&amp;quot;)
	}
	return c
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;channel创建过程：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;编译检查、缓冲区大小检查，判断是否溢出&lt;/li&gt;
&lt;li&gt;判断chan的类型&lt;br&gt;
1、当创建无缓冲chan时,调用mallocgc()在堆上为chan开辟hchanSize的buf缓存内存空间&lt;br&gt;
2、创建带缓冲的chan时,判断元素的类型是否为指针类型，若不是，则mallocgc()在堆上为chan和buf缓冲区数组开辟一段大小为 hchanSize+mem连续的内存空间。若是则调用mallocgc()在堆上分别为chan和buf缓冲区分配连续内存空间。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 187; 
			flex-basis: 450px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4.png&#34; data-size=&#34;1601x852&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4.png&#34;
			width=&#34;1601&#34;
			height=&#34;852&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4_hua8215d19cb3bccd8709e0a6c6f7245c2_228324_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4_hua8215d19cb3bccd8709e0a6c6f7245c2_228324_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;channel-发送数据与接收数据&#34;&gt;channel 发送数据与接收数据&lt;/h2&gt;
&lt;h3 id=&#34;channel-发送数据&#34;&gt;channel 发送数据&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;chan &amp;lt;- data&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chan发送数据源码如下:
func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    // 判断chan是否被初始化，向chan为nil的chan发送数据将会永久阻塞
	if c == nil {
		if !block {
			return false
		}
        // 使当前的groutine休眠
		gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
		throw(&amp;quot;unreachable&amp;quot;)
	}

	if debugChan {
		print(&amp;quot;chansend: chan=&amp;quot;, c, &amp;quot;\n&amp;quot;)
	}
     // 检查在没有获取锁的情况下会导致发送失败的非阻塞操作
	if raceenabled {
		racereadpc(c.raceaddr(), callerpc, funcPC(chansend))
	}

	// Fast path: check for failed non-blocking operation without acquiring the lock.
	//
	// After observing that the channel is not closed, we observe that the channel is
	// not ready for sending. Each of these observations is a single word-sized read
	// (first c.closed and second full()).
	// Because a closed channel cannot transition from &#39;ready for sending&#39; to
	// &#39;not ready for sending&#39;, even if the channel is closed between the two observations,
	// they imply a moment between the two when the channel was both not yet closed
	// and not ready for sending. We behave as if we observed the channel at that moment,
	// and report that the send cannot proceed.
	//
	// It is okay if the reads are reordered here: if we observe that the channel is not
	// ready for sending and then observe that it is not closed, that implies that the
	// channel wasn&#39;t closed during the first observation. However, nothing here
	// guarantees forward progress. We rely on the side effects of lock release in
	// chanrecv() and closechan() to update this thread&#39;s view of c.closed and full().
	if !block &amp;amp;&amp;amp; c.closed == 0 &amp;amp;&amp;amp; full(c) {
		return false
	}

	var t0 int64
	if blockprofilerate &amp;gt; 0 {
		t0 = cputicks()
	}
    // 获得同步锁
	lock(&amp;amp;c.lock)
    // 当chan关闭时,释放锁，并panic
    // 向也关闭的chan发送消息,会引发panic
	if c.closed != 0 {
		unlock(&amp;amp;c.lock)
		panic(plainError(&amp;quot;send on closed channel&amp;quot;))
	}
    // 如果接收队列中有等待的接收者，直接发送给接收者（有缓存区时，会绕过缓存区）
	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
		send(c, sg, ep, func() { unlock(&amp;amp;c.lock) }, 3)
		return true
	}

	if c.qcount &amp;lt; c.dataqsiz {
        // 没有接收者，当有缓存区时，将要发送的元素放入队列中
		// Space is available in the channel buffer. Enqueue the element to send.
		qp := chanbuf(c, c.sendx)  // 获取缓存地址
		if raceenabled {
			racenotify(c, c.sendx, nil)
		}
		typedmemmove(c.elemtype, qp, ep)
		c.sendx++ // 指向下一个存储的位置
		if c.sendx == c.dataqsiz {
			c.sendx = 0
		}
		c.qcount++ // 缓存数量相加
		unlock(&amp;amp;c.lock)
		return true
	}

	if !block {
		unlock(&amp;amp;c.lock)
		return false
	}
    // 缓存区满了，将当前发送协程加入到等待send队列
	// Block on the channel. Some receiver will complete our operation for us.
	gp := getg() // 获取当前的g发送协程
	mysg := acquireSudog()// 创建sudog等待队列
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
	mysg.elem = ep
	mysg.waitlink = nil
    // 把当前的发送协程与等待队列绑定
	mysg.g = gp 
	mysg.isSelect = false
	mysg.c = c
	gp.waiting = mysg
	gp.param = nil
    // 加入到发送等待队列中
	c.sendq.enqueue(mysg)
	// Signal to anyone trying to shrink our stack that we&#39;re about
	// to park on a channel. The window between when this G&#39;s status
	// changes and when we set gp.activeStackChans is not safe for
	// stack shrinking.
	atomic.Store8(&amp;amp;gp.parkingOnChan, 1)
	gopark(chanparkcommit, unsafe.Pointer(&amp;amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)
	// Ensure the value being sent is kept alive until the
	// receiver copies it out. The sudog has a pointer to the
	// stack object, but sudogs aren&#39;t considered as roots of the
	// stack tracer.
	KeepAlive(ep)

	// someone woke us up.
    // 发送协程被唤醒，解除等待队列的阻塞状态
    // 判断的等待队列是否在休眠
	if mysg != gp.waiting {
		throw(&amp;quot;G waiting list is corrupted&amp;quot;)
	}
	gp.waiting = nil
	gp.activeStackChans = false
	closed := !mysg.success
	gp.param = nil
	if mysg.releasetime &amp;gt; 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	mysg.c = nil
	releaseSudog(mysg) // 释放等待队列
	if closed {
		if c.closed == 0 {
			throw(&amp;quot;chansend: spurious wakeup&amp;quot;)
		}
		panic(plainError(&amp;quot;send on closed channel&amp;quot;))
	}
	return true
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;channel 发送数据总结&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;判断chan是否被初始化，向chan为nil的chan发送数据将会永久阻塞&lt;/li&gt;
&lt;li&gt;检查在没有获取锁， 在没有获取锁的情况下会导致发送失败的非阻塞操作&lt;/li&gt;
&lt;li&gt;检查chan是否关闭，向也关闭的chan发送消息,会引发panic&lt;/li&gt;
&lt;li&gt;如果接收队列中有等待的接收者，直接发送给接收者（有缓存区时，会绕过缓存区）&lt;/li&gt;
&lt;li&gt;没有接收者，当有缓存区时，将要发送的元素放入队列中&lt;/li&gt;
&lt;li&gt;缓存区满了，将当前协程加入到send等待队列，并阻塞&lt;/li&gt;
&lt;li&gt;当发送协程被唤醒，解除等待队列的阻塞状态，释放等待队列
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 163; 
			flex-basis: 392px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5.png&#34; data-size=&#34;1338x819&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5.png&#34;
			width=&#34;1338&#34;
			height=&#34;819&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5_huac78e02842841011bb19217a58ea5d43_197926_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5_huac78e02842841011bb19217a58ea5d43_197926_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;channel-接收数据&#34;&gt;channel 接收数据&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&amp;lt;- data&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chan 接收数据源码如下:
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
	// raceenabled: don&#39;t need to check ep, as it is always on the stack
	// or is new memory allocated by reflect.

	if debugChan {
		print(&amp;quot;chanrecv: chan=&amp;quot;, c, &amp;quot;\n&amp;quot;)
	}
    // 判断chan是否初始化，若没有初始化，接收channel数据将阻塞
	if c == nil {
		if !block {
			return
		}
		gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
		throw(&amp;quot;unreachable&amp;quot;)
	}
    // 检查chan是否为空，是否关闭
	// Fast path: check for failed non-blocking operation without acquiring the lock.
	if !block &amp;amp;&amp;amp; empty(c) {
		// After observing that the channel is not ready for receiving, we observe whether the
		// channel is closed.
		//
		// Reordering of these checks could lead to incorrect behavior when racing with a close.
		// For example, if the channel was open and not empty, was closed, and then drained,
		// reordered reads could incorrectly indicate &amp;quot;open and empty&amp;quot;. To prevent reordering,
		// we use atomic loads for both checks, and rely on emptying and closing to happen in
		// separate critical sections under the same lock.  This assumption fails when closing
		// an unbuffered channel with a blocked send, but that is an error condition anyway.
		if atomic.Load(&amp;amp;c.closed) == 0 {  // chan关闭，就返回
			// Because a channel cannot be reopened, the later observation of the channel
			// being not closed implies that it was also not closed at the moment of the
			// first observation. We behave as if we observed the channel at that moment
			// and report that the receive cannot proceed.
			return
		}
		// The channel is irreversibly closed. Re-check whether the channel has any pending data
		// to receive, which could have arrived between the empty and closed checks above.
		// Sequential consistency is also required here, when racing with such a send.
		if empty(c) { // 如果chan为空
			// The channel is irreversibly closed and empty.
            // // channel 不可逆的关闭了且为空
			if raceenabled {
				raceacquire(c.raceaddr())
			}
			if ep != nil {
				typedmemclr(c.elemtype, ep)
			}
			return true, false
		}
	}

	var t0 int64
	if blockprofilerate &amp;gt; 0 {
		t0 = cputicks()
	}

	lock(&amp;amp;c.lock)
    // chan 关闭了，清理缓冲区
	if c.closed != 0 &amp;amp;&amp;amp; c.qcount == 0 {
		if raceenabled {
			raceacquire(c.raceaddr())
		}
		unlock(&amp;amp;c.lock)
		if ep != nil {
			typedmemclr(c.elemtype, ep)
		}
		return true, false
	}
    //  找到一个等待的发件人。如果缓冲区大小为 0，则直接从发送方接收值。否则，从队列的头部接收 
    // 并将发送者的值添加到队列的尾部（两者都映射到 
    // 相同的缓冲区槽，因为队列已满）
      // 如果是无缓冲队列，直接从发送方取值
      // 如果是待缓冲的区，就从缓冲区头部获取值，并将发送着的值保存在缓冲区后
	if sg := c.sendq.dequeue(); sg != nil {
		// Found a waiting sender. If buffer is size 0, receive value
		// directly from sender. Otherwise, receive from head of queue
		// and add sender&#39;s value to the tail of the queue (both map to
		// the same buffer slot because the queue is full).
		recv(c, sg, ep, func() { unlock(&amp;amp;c.lock) }, 3)
		return true, true
	}
    // 没有发送的协程，但是缓冲区有元素，直接获取缓冲区头部的值
	if c.qcount &amp;gt; 0 {
		// Receive directly from queue
		qp := chanbuf(c, c.recvx)
		if raceenabled {
			racenotify(c, c.recvx, nil)
		}
		if ep != nil {
			typedmemmove(c.elemtype, ep, qp)
		}
		typedmemclr(c.elemtype, qp)
		c.recvx++
		if c.recvx == c.dataqsiz {
			c.recvx = 0
		}
		c.qcount--
		unlock(&amp;amp;c.lock)
		return true, true
	}

	if !block {
		unlock(&amp;amp;c.lock)
		return false, false
	}
    // 当没有发送数据的的协程，且缓冲区值，就将接收的协程放入等待队列中
	// no sender available: block on this channel.
	gp := getg()  // 获取当前接收协程
	mysg := acquireSudog() // 创建等待队列
	mysg.releasetime = 0
	if t0 != 0 {
		mysg.releasetime = -1
	}
	// No stack splits between assigning elem and enqueuing mysg
	// on gp.waiting where copystack can find it.
	mysg.elem = ep
	mysg.waitlink = nil
	gp.waiting = mysg 
    // 将接送写协程与等待队列绑定
	mysg.g = gp
	mysg.isSelect = false
	mysg.c = c
	gp.param = nil
    // 放入在协程的等待队列中
	c.recvq.enqueue(mysg)
	// Signal to anyone trying to shrink our stack that we&#39;re about
	// to park on a channel. The window between when this G&#39;s status
	// changes and when we set gp.activeStackChans is not safe for
	// stack shrinking.
	atomic.Store8(&amp;amp;gp.parkingOnChan, 1)
	gopark(chanparkcommit, unsafe.Pointer(&amp;amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)
    //当接收协程被唤醒时，解除阻塞状态
	// someone woke us up
	if mysg != gp.waiting {
		throw(&amp;quot;G waiting list is corrupted&amp;quot;)
	}
	gp.waiting = nil
	gp.activeStackChans = false
	if mysg.releasetime &amp;gt; 0 {
		blockevent(mysg.releasetime-t0, 2)
	}
	success := mysg.success
	gp.param = nil
	mysg.c = nil
	releaseSudog(mysg) // 释放等待队列内存
	return true, success
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;channel 发送数据总结&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;判断chan是否初始化，若没有初始化，接收channel数据将阻塞&lt;/li&gt;
&lt;li&gt;检查chan是否为空，是否关闭&lt;/li&gt;
&lt;li&gt;当有发送协程，如果是无缓冲队列，直接从发送方取值,如果是待缓冲的区，就从缓冲区头部获取值，并将发送着的值保存在缓冲区后&lt;/li&gt;
&lt;li&gt;当没有发送协程，但是有缓冲区有元素，直接获取缓冲区头部的值&lt;/li&gt;
&lt;li&gt;当没有发送数据的的协程，且缓冲区值，就将接收的协程放入等待队列中&lt;/li&gt;
&lt;li&gt;当接收协程被唤醒时，解除阻塞状态，释放等待队列内存
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 177; 
			flex-basis: 426px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6.png&#34; data-size=&#34;1488x837&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6.png&#34;
			width=&#34;1488&#34;
			height=&#34;837&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6_hudbd79ce6f9ecebda132de055b60a9928_209658_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-channel%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6_hudbd79ce6f9ecebda132de055b60a9928_209658_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;channel-关闭&#34;&gt;channel 关闭&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;close(chan)&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;chan 关闭源码如下:
    func closechan(c *hchan) {
        // 判断chan是否初始化，没有初始化，关闭没有初始化的chan,直接panic
    	if c == nil {
    		panic(plainError(&amp;quot;close of nil channel&amp;quot;))
    	}
        // 判断chan是否也被关闭，关闭也关闭的chan,也会发送panic
    	lock(&amp;amp;c.lock)
    	if c.closed != 0 {
    		unlock(&amp;amp;c.lock)
    		panic(plainError(&amp;quot;close of closed channel&amp;quot;))
    	}
    
    	if raceenabled {
    		callerpc := getcallerpc()
    		racewritepc(c.raceaddr(), callerpc, funcPC(closechan))
    		racerelease(c.raceaddr())
    	}
    
    	c.closed = 1
    
    	var glist gList
        // 释放所有的接收chan，并将所有的接收队列加入到待清除队列 glist 中
    	// release all readers
    	for {
    		sg := c.recvq.dequeue()
    		if sg == nil {
    			break
    		}
    		if sg.elem != nil {
    			typedmemclr(c.elemtype, sg.elem)
    			sg.elem = nil
    		}
    		if sg.releasetime != 0 {
    			sg.releasetime = cputicks()
    		}
    		gp := sg.g
    		gp.param = unsafe.Pointer(sg)
    		sg.success = false
    		if raceenabled {
    			raceacquireg(gp, c.raceaddr())
    		}
    		glist.push(gp)
    	}
        // 释放所有的发送chan,发送者的等待队列 sendq 中的 sudog 放入待清除队列 glist 中
    	// release all writers (they will panic)
    	for {
    		sg := c.sendq.dequeue()
    		if sg == nil {
    			break
    		}
    		sg.elem = nil
    		if sg.releasetime != 0 {
    			sg.releasetime = cputicks()
    		}
    		gp := sg.g
    		gp.param = unsafe.Pointer(sg)
    		sg.success = false
    		if raceenabled {
    			raceacquireg(gp, c.raceaddr())
    		}
    		glist.push(gp)
    	}
    	unlock(&amp;amp;c.lock)
    最后会为所有被阻塞的 goroutine 调用 goready 触发调度。将所有 glist 中的 
    goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度。
    	// Ready all Gs now that we&#39;ve dropped the channel lock.
    	for !glist.empty() {
    		gp := glist.pop()
    		gp.schedlink = 0
    		goready(gp, 3)
    	}
    }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;channel 关闭总结&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;判断chan是否初始化，没有初始化，关闭没有初始化的chan,直接panic&lt;/li&gt;
&lt;li&gt;判断chan是否也被关闭，关闭也关闭的chan,也会发送panic&lt;/li&gt;
&lt;li&gt;先释放所有的接收chan，并将所有的接收队列加入到待清除队列 glist 中&lt;/li&gt;
&lt;li&gt;释放所有的发送chan,发送者的等待队列 sendq 中的 sudog 放入待清除队列 glist 中&lt;/li&gt;
&lt;li&gt;最后会为所有被阻塞的 goroutine 调用 goready 触发调度。将所有 glist 中的goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度。&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>go error类型转json</title>
        <link>https://zcj-git520.github.io/p/golang/</link>
        <pubDate>Sat, 09 Oct 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/golang/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/golang/2.png" alt="Featured image of post go error类型转json" /&gt;&lt;h2 id=&#34;问题&#34;&gt;问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在收集服务的访问记录时，需要将访问记录保存，定义结构体如下&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type accessData struct {
	RemoteAddr string    // 远程访问主机地址
	RequestURI string    //访问的路由
	ServerName string    // 访问的服务名称
	AccessDate string    //访问的时间
	RunStatus bool       //服务是否正常运行
	RunError error       //运行报错：报错信息.
	ServerParam interface{} // 访问服务的参数
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过结构体转json，同时通过get请求得到图下结果
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 135; 
			flex-basis: 325px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/golang/1.png&#34; data-size=&#34;630x464&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/golang/1.png&#34;
			width=&#34;630&#34;
			height=&#34;464&#34;
			srcset=&#34;https://zcj-git520.github.io/p/golang/1_hu0cd8407e48b8e284b5fa50d7a8dedae6_33030_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/golang/1_hu0cd8407e48b8e284b5fa50d7a8dedae6_33030_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&amp;ldquo;RunError&amp;rdquo;: {},被json转为{}的字符， 打印结构体，发现错误信息是有的：{192.168.1.101:53364 /v1/alarms/out/d GetOutAlarms 2021-10-12 10:09:42 false 没有这个报警🆔id &lt;!-- raw HTML omitted --&gt;},说明是error 转json问题&lt;/p&gt;
&lt;h2 id=&#34;问题分析与解决&#34;&gt;问题分析与解决&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;问题分析查看error类型定义发现：error类型只是一个接口。它可以包含任何实现它的具体类型的值&lt;/li&gt;
&lt;li&gt;解决：将结构体中错误转化为字符串类型，同时用err.Error()返回是错误的字符串&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type accessData struct {
  RemoteAddr string    // 远程访问主机地址
  RequestURI string    //访问的路由
  ServerName string    // 访问的服务名称
  AccessDate string    //访问的时间
  RunStatus bool       //服务是否正常运行
  RunError string       //运行报错：报错信息.
  ServerParam interface{} // 访问服务的参数
  }
  type error interface {
  Error() string
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果如图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 88; 
			flex-basis: 212px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/golang/2.png&#34; data-size=&#34;492x556&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/golang/2.png&#34;
			width=&#34;492&#34;
			height=&#34;556&#34;
			srcset=&#34;https://zcj-git520.github.io/p/golang/2_hu3607656af67f333528ae9e7b0ed06a62_30106_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/golang/2_hu3607656af67f333528ae9e7b0ed06a62_30106_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>go goroutine与gmp模型的深入理解</title>
        <link>https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link>
        <pubDate>Wed, 06 Oct 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1.png" alt="Featured image of post go goroutine与gmp模型的深入理解" /&gt;&lt;h2 id=&#34;go-协程goroutine&#34;&gt;go 协程goroutine&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;协程是用户级的线程，有用户自己调度，使用协程使得程序调度更加灵活。同时比线程更轻量，占用的栈内存更少。go语言天生支持高并发，go使用协程goroutine的调度器。goroutine 的栈内存最小值为2kb(_StackMin = 2048),它不是固定不变的，可以随需求增大和缩小。goroutine 维护着很大的内存，无需频繁开辟内存，goroutine是使用M:n模型，在用户态切换协程，加上创建协程代价低，使得cpu的利用率大大提升，cup的性能大幅度的被利用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;goroutine-调度器gpm模型&#34;&gt;goroutine 调度器GPM模型&lt;/h2&gt;
&lt;h3 id=&#34;g&#34;&gt;G&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;G 就是goroutine协程&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;type g struct {
	// Stack parameters.
	// stack describes the actual stack memory: [stack.lo, stack.hi).
	// stackguard0 is the stack pointer compared in the Go stack growth prologue.
	// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.
	// stackguard1 is the stack pointer compared in the C stack growth prologue.
	// It is stack.lo+StackGuard on g0 and gsignal stacks.
	// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).
	// 记录该goroutine使用的栈
    stack       stack   // offset known to runtime/cgo
    
	//下面两个成员用于栈溢出检查，实现栈的自动伸缩，抢占调度也会用到stackguard0
    stackguard0 uintptr // offset known to liblink
	stackguard1 uintptr // offset known to liblink

	_panic         *_panic // innermost panic - offset known to liblink
	_defer         *_defer // innermost defer
    
    // 此goroutine正在被哪个工作线程执行
	m              *m      // current m; offset known to arm liblink
    //这个字段跟调度切换有关，G切换时用来保存上下文，保存什么，看下面gobuf结构体
	sched          gobuf
	syscallsp      uintptr        // if status==Gsyscall, syscallsp = sched.sp to use during gc
	syscallpc      uintptr        // if status==Gsyscall, syscallpc = sched.pc to use during gc
	stktopsp       uintptr        // expected sp at top of stack, to check in traceback
	param          unsafe.Pointer // passed parameter on wakeup，wakeup唤醒时传递的参数
	// 状态Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead
    atomicstatus   uint32
	stackLock      uint32 // sigprof/scang lock; TODO: fold in to atomicstatus
	goid           int64
    
    //schedlink字段指向全局运行队列中的下一个g，
    //所有位于全局运行队列中的g形成一个链表
	schedlink      guintptr
	waitsince      int64      // approx time when the g become blocked
	waitreason     waitReason // if status==Gwaiting，g被阻塞的原因
    //抢占信号，stackguard0 = stackpreempt，如果需要抢占调度，设置preempt为true
	preempt        bool       // preemption signal, duplicates stackguard0 = stackpreempt
	paniconfault   bool       // panic (instead of crash) on unexpected fault address
	preemptscan    bool       // preempted g does scan for gc
	gcscandone     bool       // g has scanned stack; protected by _Gscan bit in status
	gcscanvalid    bool       // false at start of gc cycle, true if G has not run since last scan; TODO: remove?
	throwsplit     bool       // must not split stack
	raceignore     int8       // ignore race detection events
	sysblocktraced bool       // StartTrace has emitted EvGoInSyscall about this goroutine
	sysexitticks   int64      // cputicks when syscall has returned (for tracing)
	traceseq       uint64     // trace event sequencer
	tracelastp     puintptr   // last P emitted an event for this goroutine
	// 如果调用了 LockOsThread，那么这个 g 会绑定到某个 m 上
    lockedm        muintptr
	sig            uint32
	writebuf       []byte
	sigcode0       uintptr
	sigcode1       uintptr
	sigpc          uintptr
    // 创建这个goroutine的go表达式的pc
	gopc           uintptr         // pc of go statement that created this goroutine
	ancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)
	startpc        uintptr         // pc of goroutine function
	racectx        uintptr
	waiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order
	cgoCtxt        []uintptr      // cgo traceback context
	labels         unsafe.Pointer // profiler labels
	timer          *timer         // cached timer for time.Sleep,为 time.Sleep 缓存的计时器
	selectDone     uint32         // are we participating in a select and did someone win the race?

	// Per-G GC state

	// gcAssistBytes is this G&#39;s GC assist credit in terms of
	// bytes allocated. If this is positive, then the G has credit
	// to allocate gcAssistBytes bytes without assisting. If this
	// is negative, then the G must correct this by performing
	// scan work. We track this in bytes to make it fast to update
	// and check for debt in the malloc hot path. The assist ratio
	// determines how this corresponds to scan work debt.
	gcAssistBytes int64
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;保存着goroutine所有信息以及栈信息，gobuf结构体：cpu里的寄存器信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;p-processor处理器&#34;&gt;P processor处理器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调度协程G和线程M的关联&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;P 的结构体如下：
type p struct {
    //allp中的索引
	id          int32
    //p的状态
	status      uint32 // one of pidle/prunning/...
	link        puintptr
	schedtick   uint32     // incremented on every scheduler call-&amp;gt;每次scheduler调用+1
	syscalltick uint32     // incremented on every system call-&amp;gt;每次系统调用+1
	sysmontick  sysmontick // last tick observed by sysmon
    //指向绑定的 m，如果 p 是 idle 的话，那这个指针是 nil
	m           muintptr   // back-link to associated m (nil if idle)
	mcache      *mcache
	raceprocctx uintptr

    //不同大小可用defer结构池
	deferpool    [5][]*_defer // pool of available defer structs of different sizes (see panic.go)
	deferpoolbuf [5][32]*_defer

	// Cache of goroutine ids, amortizes accesses to runtime·sched.goidgen.
	goidcache    uint64
	goidcacheend uint64

    //本地运行队列，可以无锁访问
	// Queue of runnable goroutines. Accessed without lock.
	runqhead uint32  //队列头
	runqtail uint32   //队列尾
    //数组实现的循环队列
	runq     [256]guintptr
    
	// runnext, if non-nil, is a runnable G that was ready&#39;d by
	// the current G and should be run next instead of what&#39;s in
	// runq if there&#39;s time remaining in the running G&#39;s time
	// slice. It will inherit the time left in the current time
	// slice. If a set of goroutines is locked in a
	// communicate-and-wait pattern, this schedules that set as a
	// unit and eliminates the (potentially large) scheduling
	// latency that otherwise arises from adding the ready&#39;d
	// goroutines to the end of the run queue.
    // runnext 非空时，代表的是一个 runnable 状态的 G，
    //这个 G 被 当前 G 修改为 ready 状态，相比 runq 中的 G 有更高的优先级。
    //如果当前 G 还有剩余的可用时间，那么就应该运行这个 G
    //运行之后，该 G 会继承当前 G 的剩余时间
	runnext guintptr

	// Available G&#39;s (status == Gdead)
    //空闲的g
	gFree struct {
		gList
		n int32
	}

	sudogcache []*sudog
	sudogbuf   [128]*sudog

	tracebuf traceBufPtr

	// traceSweep indicates the sweep events should be traced.
	// This is used to defer the sweep start event until a span
	// has actually been swept.
	traceSweep bool
	// traceSwept and traceReclaimed track the number of bytes
	// swept and reclaimed by sweeping in the current sweep loop.
	traceSwept, traceReclaimed uintptr

	palloc persistentAlloc // per-P to avoid mutex

	_ uint32 // Alignment for atomic fields below

	// Per-P GC state
	gcAssistTime         int64    // Nanoseconds in assistAlloc
	gcFractionalMarkTime int64    // Nanoseconds in fractional mark worker (atomic)
	gcBgMarkWorker       guintptr // (atomic)
	gcMarkWorkerMode     gcMarkWorkerMode

	// gcMarkWorkerStartTime is the nanotime() at which this mark
	// worker started.
	gcMarkWorkerStartTime int64

	// gcw is this P&#39;s GC work buffer cache. The work buffer is
	// filled by write barriers, drained by mutator assists, and
	// disposed on certain GC state transitions.
	gcw gcWork

	// wbBuf is this P&#39;s GC write barrier buffer.
	//
	// TODO: Consider caching this in the running G.
	wbBuf wbBuf

	runSafePointFn uint32 // if 1, run sched.safePointFn at next safe point

	pad cpu.CacheLinePad
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;记录着P的信息，以及G的状态等。同时P是有着本地队列，存放着带待运行的G,本地队列不能超过256个。&lt;/li&gt;
&lt;li&gt;P的数量：是由环境变量 $GOMAXPROCS 或者是由 runtime 的方法 GOMAXPROCS() 决定。在程序启动式创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;m-是内核态线程的抽象&#34;&gt;M 是内核态线程的抽象&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;主要的工作执行协程G或者在调度G到P中&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;M的结构体如下：
type m struct {
    // 系统管理的一个g，执行调度代码时使用的。比如执行用户的goroutine时，就需要把把用户
    // 的栈信息换到内核线程的栈，以便能够执行用户goroutine
	g0      *g     // goroutine with scheduling stack
	morebuf gobuf  // gobuf arg to morestack
	divmod  uint32 // div/mod denominator for arm - known to liblink

	// Fields not known to debuggers.
	procid        uint64       // for debuggers, but offset not hard-coded
    //处理signal的 g
	gsignal       *g           // signal-handling g
	goSigStack    gsignalStack // Go-allocated signal handling stack
	sigmask       sigset       // storage for saved signal mask
    //线程的本地存储TLS，这里就是为什么OS线程能运行M关键地方
	tls           [6]uintptr   // thread-local storage (for x86 extern register)
	//go 关键字运行的函数
    mstartfn      func()
    //当前运行的用户goroutine的g结构体对象
	curg          *g       // current running goroutine
	caughtsig     guintptr // goroutine running during fatal signal
    
    //当前工作线程绑定的P，如果没有就为nil
	p             puintptr // attached p for executing go code (nil if not executing go code)
	//暂存与当前M潜在关联的P
    nextp         puintptr
    //M之前调用的P
	oldp          puintptr // the p that was attached before executing a syscall
	id            int64
	mallocing     int32
	throwing      int32
    //当前M是否关闭抢占式调度
	preemptoff    string // if != &amp;quot;&amp;quot;, keep curg running on this m
	locks         int32
	dying         int32
	profilehz     int32
    //M的自旋状态，为true时M处于自旋状态，正在从其他线程偷G; 为false，休眠状态
	spinning      bool // m is out of work and is actively looking for work
	blocked       bool // m is blocked on a note
	newSigstack   bool // minit on C thread called sigaltstack
	printlock     int8
	incgo         bool   // m is executing a cgo call
	freeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)
	fastrand      [2]uint32
	needextram    bool
	traceback     uint8
	ncgocall      uint64      // number of cgo calls in total
	ncgo          int32       // number of cgo calls currently in progress
	cgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily
	cgoCallers    *cgoCallers // cgo traceback if crashing in cgo call
	//没有goroutine运行时，工作线程睡眠
    //通过这个来唤醒工作线程
    park          note // 休眠锁
    //记录所有工作线程的链表
	alllink       *m // on allm
	schedlink     muintptr
    //当前线程内存分配的本地缓存
	mcache        *mcache
    //当前M锁定的G，
	lockedg       guintptr
	createstack   [32]uintptr // stack that created this thread.
	lockedExt     uint32      // tracking for external LockOSThread
	lockedInt     uint32      // tracking for internal lockOSThread
	nextwaitm     muintptr    // next m waiting for lock
	waitunlockf   func(*g, unsafe.Pointer) bool
	waitlock      unsafe.Pointer
	waittraceev   byte
	waittraceskip int
	startingtrace bool
	syscalltick   uint32
    //操作系统线程id
	thread        uintptr // thread handle
	freelink      *m      // on sched.freem

	// these are here because they are too large to be on the stack
	// of low-level NOSPLIT functions.
	libcall   libcall
	libcallpc uintptr // for cpu profiler
	libcallsp uintptr
	libcallg  guintptr
	syscall   libcall // stores syscall parameters on windows

	vdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)
	vdsoPC uintptr // PC for traceback while in VDSO call

	dlogPerM

	mOS
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;记录着M的线程的信息，包括一些P,G以及信号和自旋锁等信息&lt;/li&gt;
&lt;li&gt;m 数量：可以通过SetMaxThreads函数，设置 M 的最大数量，默认为10000(sched.maxmcount = 10000)，和P一样在程序启动时创建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全局队列gqueue&#34;&gt;全局队列（gQueue）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;P的本地队列可以存放着不超过256个待执行的G,P是有限的，当G过多时，即当P本地队列存放不下时，就需要将G存放在全局队列中。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;全局队列结构如下：
type gQueue struct {
	head guintptr //队列头
	tail guintptr //队列尾
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;gpmgqueue关系&#34;&gt;G、P、M、gQueue关系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;P与M没有数量关系，当一个M处于阻塞时，P先找空闲M,没有空闲的M就创建新的M&lt;/li&gt;
&lt;li&gt;G优先存放在P本地队列中，当P中G满时，会将P中前一半G存放在全局中。当P空闲时时，会从全局中拿取G放在本地队列。全局没有G时，会从其P的本地队列中拿取一半到本地队列。&lt;/li&gt;
&lt;li&gt;关系如图所示：&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 90; 
			flex-basis: 218px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1.png&#34; data-size=&#34;662x728&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1.png&#34;
			width=&#34;662&#34;
			height=&#34;728&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1_huda718813a1636432ee91da972c85e460_240629_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1_huda718813a1636432ee91da972c85e460_240629_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建goroutine&#34;&gt;创建goroutine&lt;/h2&gt;
&lt;h3 id=&#34;newproc函数&#34;&gt;newproc()函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;goroutine 是由函数newproc函数进行创建的，newproc源码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 参数：协程函数的参数占的字节数和协程入口函数的funcval指针
func newproc(siz int32, fn *funcval) {
    // 获得协程参数的地址= fn函数地址+偏移值
	argp := add(unsafe.Pointer(&amp;amp;fn), sys.PtrSize)
	gp := getg() // 获得当前G的指针
    //调用者的pc，也就是执行完此函数返回调用者时的下一条指令地址
	pc := getcallerpc() 
    // 切换到（系统栈）g0栈中
	systemstack(func() {
    //执行调用newproc1()函数执行创建协程
		newg := newproc1(fn, argp, siz, gp, pc)
		_p_ := getg().m.p.ptr()
        // 把当前的G存放在runq队列中
		runqput(_p_, newg, true) 
        // 如果当前由空闲的P,没有睡眠的M,主协程开始运行时
		if mainStarted {
			wakep() // 创建m,并设置为活跃状态
		}
	})
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;在newproc函数中为什么要切换在g0栈中执行呢？是因为newproc1()函数不支持栈增长，协程的栈空间小(几KB)，为了防止运行协程函数时栈溢出，需要在g0的栈上运行，g0是分配在线程的栈空间(4MB)上。g0的栈空间很大，运行协程函数时栈不溢出。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;newproc1函数&#34;&gt;newproc1()函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;newproc1()是创建协程 源码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;参数：协程入口、参数首地址、参数大小、父协程指针、返回地址
func newproc1(fn *funcval, argp unsafe.Pointer, narg int32, callergp *g, callerpc uintptr) *g {
	_g_ := getg()  // 获得当前的G

	if fn == nil {
		_g_.m.throwing = -1 // do not dump full stacks
		throw(&amp;quot;go of nil func value&amp;quot;)
	}
     // 为了保证数据一致性会禁止当前m被抢占
	acquirem() // disable preemption because it can be holding p in a local var
	siz := narg
	siz = (siz + 7) &amp;amp;^ 7

	// We could allocate a larger initial stack if necessary.
	// Not worth it: this is almost always an error.
	// 4*sizeof(uintreg): extra space added below
	// sizeof(uintreg): caller&#39;s LR (arm) or return address (x86, in gostartcall).
	if siz &amp;gt;= _StackMin-4*sys.RegSize-sys.RegSize {
		throw(&amp;quot;newproc: function arguments too large for new goroutine&amp;quot;)
	}

	_p_ := _g_.m.p.ptr()
    // 尝试获取一个空闲的G,如果没有空闲的G,就会创建新的G,分配栈空间,并添加到全局allgs中
	newg := gfget(_p_)
    // 如果没有空闲的G
	if newg == nil {
    // 就会创建新的G,分配栈空间大小为最小的2KB
		newg = malg(_StackMin)
        // 设置状态为等待
		casgstatus(newg, _Gidle, _Gdead)
        //并添加到全局allgs中
		allgadd(newg) // publishes with a g-&amp;gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
	}
	if newg.stack.hi == 0 {
		throw(&amp;quot;newproc1: newg missing stack&amp;quot;)
	}

	if readgstatus(newg) != _Gdead {
		throw(&amp;quot;newproc1: new g is not Gdead&amp;quot;)
	}

	totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame
	totalSize += -totalSize &amp;amp; (sys.SpAlign - 1)                  // align to spAlign
	sp := newg.stack.hi - totalSize
	spArg := sp
	if usesLR {
		// caller&#39;s LR
		*(*uintptr)(unsafe.Pointer(sp)) = 0
		prepGoExitFrame(sp)
		spArg += sys.MinFrameSize
	}
	if narg &amp;gt; 0 {
        // 如果协程入口函数由参数，会将参数移动在协程栈中 
		memmove(unsafe.Pointer(spArg), argp, uintptr(narg))
		// This is a stack-to-stack copy. If write barriers
		// are enabled and the source stack is grey (the
		// destination is always black), then perform a
		// barrier copy. We do this *after* the memmove
		// because the destination stack may have garbage on
		// it.
		if writeBarrier.needed &amp;amp;&amp;amp; !_g_.m.curg.gcscandone {
			f := findfunc(fn.fn)
			stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps))
			if stkmap.nbit &amp;gt; 0 {
				// We&#39;re in the prologue, so it&#39;s always stack map index 0.
				bv := stackmapdata(stkmap, 0)
				bulkBarrierBitmap(spArg, spArg, uintptr(bv.n)*sys.PtrSize, 0, bv.bytedata)
			}
		}
	}
    // 初始化newg.sched调度相关的信息
	memclrNoHeapPointers(unsafe.Pointer(&amp;amp;newg.sched), unsafe.Sizeof(newg.sched))
	newg.sched.sp = sp //设置为协程栈指针
	newg.stktopsp = sp
    // 设置为指向协程入口函数的入口，当协程调度执行时，运行协程函数
	newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function
	newg.sched.g = guintptr(unsafe.Pointer(newg))
	gostartcallfn(&amp;amp;newg.sched, fn)
    // 设置为父协程调用newproc函数结束后的返回地址
	newg.gopc = callerpc
	newg.ancestors = saveAncestors(callergp)
    // 设置startpc为协程入孔函数的起始地址
	newg.startpc = fn.fn 
	if _g_.m.curg != nil {
		newg.labels = _g_.m.curg.labels
	}
	if isSystemGoroutine(newg, false) {
		atomic.Xadd(&amp;amp;sched.ngsys, +1)
	}
    // 设置协程为运行状态
	casgstatus(newg, _Gdead, _Grunnable)

	if _p_.goidcache == _p_.goidcacheend {
		// Sched.goidgen is the last allocated id,
		// this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].
		// At startup sched.goidgen=0, so main goroutine receives goid=1.
		_p_.goidcache = atomic.Xadd64(&amp;amp;sched.goidgen, _GoidCacheBatch)
		_p_.goidcache -= _GoidCacheBatch - 1
		_p_.goidcacheend = _p_.goidcache + _GoidCacheBatch
	}
    // 给协程赋予一个唯一的goid
	newg.goid = int64(_p_.goidcache)
	_p_.goidcache++
	if raceenabled {
		newg.racectx = racegostart(callerpc)
	}
	if trace.enabled {
		traceGoCreate(newg, newg.startpc)
	}
    // 允许当前m被抢占
	releasem(_g_.m)

	return newg
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;图示如下&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 214; 
			flex-basis: 514px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2.png&#34; data-size=&#34;1903x887&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2.png&#34;
			width=&#34;1903&#34;
			height=&#34;887&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2_hu005dba7d92ca61057a969757b05a2c3b_575926_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2_hu005dba7d92ca61057a969757b05a2c3b_575926_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结goroutine创建过程&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;为了保证数据一致性会禁止当前m被抢占&lt;/li&gt;
&lt;li&gt;尝试获取一个空闲的G,如果没有空闲的G,就会创建新的G,分配栈空间,状态为等待并添加到全局allgs中&lt;/li&gt;
&lt;li&gt;如果协程入口函数由参数，会将参数移动在协程栈中&lt;/li&gt;
&lt;li&gt;初始化newg.sched调度相关的信息，设置状态运行&lt;/li&gt;
&lt;li&gt;得到唯一的goid, 并添加到runq队列中&lt;/li&gt;
&lt;li&gt;如果当前有空闲的P,没有睡眠的M,并且主协程开始运行时，就会创建新的活跃的M&lt;/li&gt;
&lt;li&gt;当g运行结束后，设置允许当前m被抢占&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;goroutine的让出与恢复调度抢占监控&#34;&gt;goroutine的让出与恢复、调度、抢占、监控&lt;/h2&gt;
&lt;h3 id=&#34;goroutine-让出与恢复&#34;&gt;goroutine 让出与恢复&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;协程的让出是由函数gopark()执行的&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;源码如下：
func gopark(unlockf func(*g, unsafe.Pointer) bool, lock unsafe.Pointer, reason waitReason, traceEv byte, traceskip int) {
	if reason != waitReasonSleep {
		checkTimeouts() // timeouts may expire while two goroutines keep the scheduler busy
	}
    // 禁止当前m被抢占
	mp := acquirem()
	gp := mp.curg
	status := readgstatus(gp)
    // 判断协程的是否在运行状态
	if status != _Grunning &amp;amp;&amp;amp; status != _Gscanrunning {
		throw(&amp;quot;gopark: bad g status&amp;quot;)
	}
	mp.waitlock = lock
	mp.waitunlockf = unlockf
	gp.waitreason = reason
	mp.waittraceev = traceEv
	mp.waittraceskip = traceskip
    // 解除对m的抢占
	releasem(mp)
	// can&#39;t do anything that might move the G between Ms here.
    // 不能做任何可能在 Ms 之间移动 G 的事情。
    // 保存协程，切换在go
	mcall(park_m)
}
func park_m(gp *g) {
	_g_ := getg()

	if trace.enabled {
		traceGoPark(_g_.m.waittraceev, _g_.m.waittraceskip)
	}
    //更改协程由运行状态到等待状态
	casgstatus(gp, _Grunning, _Gwaiting)
	dropg()
    &amp;quot;&amp;quot;&amp;quot;
    func dropg() {
    	_g_ := getg()
        // 把m当前执行的置为nil(m不在运行这个当前写协程，协程就挂起了)
    	setMNoWB(&amp;amp;_g_.m.curg.m, nil)
    	setGNoWB(&amp;amp;_g_.m.curg, nil)
    }
    &amp;quot;&amp;quot;&amp;quot;

	if fn := _g_.m.waitunlockf; fn != nil {
		ok := fn(gp, _g_.m.waitlock)
		_g_.m.waitunlockf = nil
		_g_.m.waitlock = nil
		if !ok {
			if trace.enabled {
				traceGoUnpark(gp, 2)
			}
			casgstatus(gp, _Gwaiting, _Grunnable)
			execute(gp, true) // Schedule it back, never returns.
		}
	}
	schedule() // 寻找下一个G
}
//在G中由定时调用回调函数f 
type timer struct {
	// If this timer is on a heap, which P&#39;s heap it is on.
	// puintptr rather than *p to match uintptr in the versions
	// of this struct defined in other packages.
	pp puintptr

	// Timer wakes up at when, and then at when+period, ... (period &amp;gt; 0 only)
	// each time calling f(arg, now) in the timer goroutine, so f must be
	// a well-behaved function and not block.
	//
	// when must be positive on an active timer.
	when   int64
	period int64
	f      func(interface{}, uintptr)
	arg    interface{}
	seq    uintptr

	// What to set the when field to in timerModifiedXX status.
	nextwhen int64

	// The status field holds one of the values below.
	status uint32
}
// Mark gp ready to run.
// 将等待协程状态置为运行的状态
func ready(gp *g, traceskip int, next bool) {
	if trace.enabled {
		traceGoUnpark(gp, traceskip)
	}

	status := readgstatus(gp)

	// Mark runnable.
	_g_ := getg()
    //// 禁止当前m被抢占
	mp := acquirem() // disable preemption because it can be holding p in a local var
	if status&amp;amp;^_Gscan != _Gwaiting {
		dumpgstatus(gp)
		throw(&amp;quot;bad g-&amp;gt;status in ready&amp;quot;)
	}

	// status is Gwaiting or Gscanwaiting, make Grunnable and put on runq
	casgstatus(gp, _Gwaiting, _Grunnable) // 把协程等待的转态置为可运行状态
	runqput(_g_.m.p.ptr(), gp, next)  // 添加在运行队列中
	wakep()// 如果没有可执行的M,就创建新的m
	releasem(mp)  // 释放当前的m
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如图所示  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 93; 
			flex-basis: 224px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4.png&#34; data-size=&#34;616x659&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4.png&#34;
			width=&#34;616&#34;
			height=&#34;659&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4_hu5613a8da5b016601d36fb944722fdf94_151142_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/4_hu5613a8da5b016601d36fb944722fdf94_151142_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;gopark()是让出函数，禁止当前m被抢占，判断当前的协程状态是否为运行状态。&lt;/li&gt;
&lt;li&gt;dropg()让当前的m不在执行当前的G,修改当前g的状态为等待(协程挂起)，调用schedule() 寻找下一个可执行G&lt;/li&gt;
&lt;li&gt;timers 等待的g中数据结构，定时调用回调函数f，将g置为了运行状态&lt;/li&gt;
&lt;li&gt;ready()函数是将唤醒等待G,将G的状态更改为可运行状态，并添加在运行的队列中m，如果没有可执行的M,就创建新的m&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;goroutine-监控&#34;&gt;goroutine 监控&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用checkTimers()检查到时间运行的唤醒g&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;源码如下
checkTimers(pp *p, now int64) (rnow, pollUntil int64, ran bool) {
  	// If it&#39;s not yet time for the first timer, or the first adjusted
  	// timer, then there is nothing to do.
  	next := int64(atomic.Load64(&amp;amp;pp.timer0When))
  	nextAdj := int64(atomic.Load64(&amp;amp;pp.timerModifiedEarliest))
  	if next == 0 || (nextAdj != 0 &amp;amp;&amp;amp; nextAdj &amp;lt; next) {
  		next = nextAdj
  	}
  
  	if next == 0 {
  		// No timers to run or adjust.
  		return now, 0, false
  	}
  
  	if now == 0 {
  		now = nanotime()
  	}
  	if now &amp;lt; next {
  		// Next timer is not ready to run, but keep going
  		// if we would clear deleted timers.
  		// This corresponds to the condition below where
  		// we decide whether to call clearDeletedTimers.
  		if pp != getg().m.p.ptr() || int(atomic.Load(&amp;amp;pp.deletedTimers)) &amp;lt;= int(atomic.Load(&amp;amp;pp.numTimers)/4) {
  			return now, next, false
  		}
  	}
  
  	lock(&amp;amp;pp.timersLock)
  
  	if len(pp.timers) &amp;gt; 0 {
  		adjusttimers(pp, now)
  		for len(pp.timers) &amp;gt; 0 {
  			// Note that runtimer may temporarily unlock
  			// pp.timersLock.
  			if tw := runtimer(pp, now); tw != 0 {
  				if tw &amp;gt; 0 {
  					pollUntil = tw
  				}
  				break
  			}
  			ran = true
  		}
  	}
  
  	// If this is the local P, and there are a lot of deleted timers,
  	// clear them out. We only do this for the local P to reduce
  	// lock contention on timersLock.
  	if pp == getg().m.p.ptr() &amp;amp;&amp;amp; int(atomic.Load(&amp;amp;pp.deletedTimers)) &amp;gt; len(pp.timers)/4 {
  		clearDeletedTimers(pp)
  	}
  
  	unlock(&amp;amp;pp.timersLock)
  
  	return now, pollUntil, ran
  }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;协程的监控是由专门的监控协程程来运行，监控协程是由主协程创建而来
，监控协程与gpm中的协程不一样，它不是由gpm进行调度，当然了也不需要P,
监控timer，并按需调整g的休眠时间，如果没有可执行的M,就创建新的m执行被唤醒的G,
确保被唤醒g被执行。
如图  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 153; 
			flex-basis: 368px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5.png&#34; data-size=&#34;1256x819&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5.png&#34;
			width=&#34;1256&#34;
			height=&#34;819&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5_hu682cbf00a0aebc2341d65e28e3999df2_184463_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/5_hu682cbf00a0aebc2341d65e28e3999df2_184463_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goroutine-抢占&#34;&gt;goroutine 抢占&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;对运行过长的g进行抢占，即当g运行时间超过运行阈值的g强制让出m
运行时间是由P的结构syscalltick、schedtick、timer0When等记录。&lt;/li&gt;
&lt;li&gt;通过栈增长时：当stackguard = stackPreempt,不执行栈增长，而是执行协程调度,
这样就让协程让出栈。&lt;/li&gt;
&lt;li&gt;这种抢占依赖栈增长，有缺陷。所以有asyncPreempt通过信号方式进行异步抢占&lt;br&gt;
如图所示  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 135; 
			flex-basis: 325px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6.png&#34; data-size=&#34;1157x853&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6.png&#34;
			width=&#34;1157&#34;
			height=&#34;853&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6_huc14b31ec4abc9db0f402c5310d9f9d21_373269_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/6_huc14b31ec4abc9db0f402c5310d9f9d21_373269_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;goroutine-调度&#34;&gt;goroutine 调度&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;调用schedule()函数进行协程的调度&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;源码如下：
func schedule() {
	_g_ := getg() // 获得当前的G

	if _g_.m.locks != 0 {
		throw(&amp;quot;schedule: holding locks&amp;quot;)
	}
    // 判断当前的M和当前的G是否绑定
	if _g_.m.lockedg != 0 {
        // 如果当前的M绑定G,就阻塞m(休眠M)
		stoplockedm()
		execute(_g_.m.lockedg.ptr(), false) // Never returns.
	}

	// We should not schedule away from a g that is executing a cgo call,
	// since the cgo call is using the m&#39;s g0 stack.
	if _g_.m.incgo {
		throw(&amp;quot;schedule: in cgo&amp;quot;)
	}

top:
	pp := _g_.m.p.ptr()
	pp.preempt = false
    // 判断Gc是否在等待执行
	if sched.gcwaiting != 0 {
        //是在等待执行，先执行gc，执行完在执行后续操作
		gcstopm() 
		goto top
	}
	if pp.runSafePointFn != 0 {
		runSafePointFn()
	}

	// Sanity check: if we are spinning, the run queue should be empty.
	// Check this before calling checkTimers, as that might call
	// goready to put a ready goroutine on the local run queue.
	if _g_.m.spinning &amp;amp;&amp;amp; (pp.runnext != 0 || pp.runqhead != pp.runqtail) {
		throw(&amp;quot;schedule: spinning with local work&amp;quot;)
	}
    //检查是否有要被执行的Timer
	checkTimers(pp, 0)

	var gp *g
	var inheritTime bool

	// Normal goroutines will check for need to wakeP in ready,
	// but GCworkers and tracereaders will not, so the check must
	// be done here instead.
    // 普通的 goroutine 会检查是否需要在准备好时唤醒， 
    // 但 GCworkers 和跟踪读取器不会，所以检查必须 
    // 在这里完成。
	tryWakeP := false
	if trace.enabled || trace.shutdown {
		gp = traceReader()
		if gp != nil {
			casgstatus(gp, _Gwaiting, _Grunnable)
			traceGoUnpark(gp, 0)
			tryWakeP = true
		}
	}
	if gp == nil &amp;amp;&amp;amp; gcBlackenEnabled != 0 {
		gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
		tryWakeP = tryWakeP || gp != nil
	}
	if gp == nil {
		// Check the global runnable queue once in a while to ensure fairness.
		// Otherwise two goroutines can completely occupy the local runqueue
		// by constantly respawning each other.
        / 每隔一段时间检查一下全局可运行队列以确保公平。 
        // 否则两个 goroutine 可以完全占用本地运行队列
        // 通过不断相互重生。
        // 有%61的概率把G从全局运行队列中搬移到本地可运行队列，保障本地可运行队列
            有G运行，全局队列也能放在本都队列中
		if _g_.m.p.ptr().schedtick%61 == 0 &amp;amp;&amp;amp; sched.runqsize &amp;gt; 0 {
			lock(&amp;amp;sched.lock)
			gp = globrunqget(_g_.m.p.ptr(), 1)
			unlock(&amp;amp;sched.lock)
		}
	}
	if gp == nil {
        // 没有待运行的G 就现在本地可运行队列查找
		gp, inheritTime = runqget(_g_.m.p.ptr())
		// We can see gp != nil here even if the M is spinning,
		// if checkTimers added a local goroutine via goready.
	}
	if gp == nil {
        // 本地队列没有，就调用findrunnable()，直到有待执行的g才返回(先在本地
            运行队列，全局队列、等待的io, 其他的P)
		gp, inheritTime = findrunnable() // blocks until work is available
	}

	// This thread is going to run a goroutine and is not spinning anymore,
	// so if it was marked as spinning we need to reset it now and potentially
	// start a new spinning M.
	if _g_.m.spinning {
		resetspinning()
	}

	if sched.disable.user &amp;amp;&amp;amp; !schedEnabled(gp) {
		// Scheduling of this goroutine is disabled. Put it on
		// the list of pending runnable goroutines for when we
		// re-enable user scheduling and look again.
		lock(&amp;amp;sched.lock)
		if schedEnabled(gp) {
			// Something re-enabled scheduling while we
			// were acquiring the lock.
			unlock(&amp;amp;sched.lock)
		} else {
			sched.disable.runnable.pushBack(gp)
			sched.disable.n++
			unlock(&amp;amp;sched.lock)
			goto top
		}
	}

	// If about to schedule a not-normal goroutine (a GCworker or tracereader),
	// wake a P if there is one.
	if tryWakeP {
		wakep()
	}
    // 判断获得的G有没有绑定的M,有就阻塞g, 再次进行调度
	if gp.lockedm != 0 {
		// Hands off own p to the locked m,
		// then blocks waiting for a new p.
		startlockedm(gp)
		goto top
	}
    // 使用execute函数让m执行g
	execute(gp, inheritTime)
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如图所示  &lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 103; 
			flex-basis: 248px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/7.png&#34; data-size=&#34;896x865&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/7.png&#34;
			width=&#34;896&#34;
			height=&#34;865&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/7_huebf4099418eefb5d5e40ab8835dd1ae1_193577_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/7_huebf4099418eefb5d5e40ab8835dd1ae1_193577_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;总结&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;判断当前的M和当前的G是否绑定，如果当前的M绑定G,就阻塞m(休眠M)&lt;/li&gt;
&lt;li&gt;判断Gc是否在等待执行，是在等待执行，先执行gc，执行完在执行后续操作&lt;/li&gt;
&lt;li&gt;检查是否有要被执行的Timer&lt;/li&gt;
&lt;li&gt;普通的 goroutine 会检查是否需要在准备好时唤醒，但 GCworkers 和跟踪读取器不会，所以检查必须&lt;/li&gt;
&lt;li&gt;有%61的概率把G从全局运行队列中搬移到本地可运行队列，保障本地可运行队列有G运行，全局队列也能放在本都队列中&lt;/li&gt;
&lt;li&gt;没有待运行的G就现在本地可运行队列查找，本地队列没有，就调用findrunnable()，直到有待执行的g才返回(先在本地
运行队列，全局队列、等待的io, 其他的P中分配G)&lt;/li&gt;
&lt;li&gt;判断获得的G有没有绑定的M,有就阻塞g, 再次进行调度&lt;/li&gt;
&lt;li&gt;使用execute函数让m执行g,待运行g绑定m,调用gogo(&amp;amp;gp.sched)协程的现场恢复等&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;调度器的设计策略&#34;&gt;调度器的设计策略&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;减少线程的创建与销毁cup的开销，GPM是线程的复用。即当没有 可运行的G时，将M休眠,P空闲。当有可执行G是找空闲的P，在将M唤醒，执行G，直到 main.main 退出，runtime.main 执行 Defer 和 Panic 处理，或调用 runtime.exit 退出程序&lt;/li&gt;
&lt;li&gt;work stealing 机制：当本线程无可运行的 G 时，尝试从其他线程绑定的 P 偷取 G，而不是销毁线程。&lt;/li&gt;
&lt;li&gt;hand off 机制：&lt;br&gt;
1.当本线程因为 G 进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行。&lt;br&gt;
2.利用并行：GOMAXPROCS 设置 P 的数量，最多有 GOMAXPROCS 个线程分布在多个 CPU 上同时运行。GOMAXPROCS 也限制了并发的程度，比如 GOMAXPROCS = 核数/2，则最多利用了一半的 CPU 核进行并行。 &lt;br&gt;
3.抢占：在 coroutine 中要等待一个协程主动让出 CPU 才执行下一个协程，在 Go 中，一个 goroutine 最多占用 CPU 10ms，防止其他 goroutine 被饿死，这就是 goroutine 不同于 coroutine 的一个地方。&lt;br&gt;
4.全局 G 队列：在新的调度器中依然有全局 G 队列，但功能已经被弱化了，当 M 执行 work stealing 从其他 P 偷不到 G 时，它可以从全局 G 队列获取 G。&lt;/li&gt;
&lt;li&gt;调度如图所示&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 179; 
			flex-basis: 431px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png&#34; data-size=&#34;970x540&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png&#34;
			width=&#34;970&#34;
			height=&#34;540&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_hu6b3ed4c0e6c5dd3549ade2aca3a75bc3_223170_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-goroutine%E4%B8%8Egmp%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_hu6b3ed4c0e6c5dd3549ade2aca3a75bc3_223170_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;1、&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/fa696563c38a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/fa696563c38a&lt;/a&gt;
2.&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/people/kylin-lab&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/people/kylin-lab&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>进程、线程、协程</title>
        <link>https://zcj-git520.github.io/p/c/c-/</link>
        <pubDate>Tue, 28 Sep 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/c/c-/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/c/c/10.png" alt="Featured image of post 进程、线程、协程" /&gt;&lt;h2 id=&#34;理解进程与线程&#34;&gt;理解进程与线程&lt;/h2&gt;
&lt;h3 id=&#34;进程&#34;&gt;进程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;进程是程序一次动态执行过程、进程是操作系统分配资源(内存、io资源、cpu等)和资源调度的基本单位。程序是指令、数据及其组织形式的描述，进程是程序的实体。&lt;/li&gt;
&lt;li&gt;进程是由 进程控制块PCB、相关程序段和该程序段进行操作的数据结构集三个部分组成。&lt;/li&gt;
&lt;li&gt;进程的五中状态：创建、就绪、运行、阻塞、终止&lt;/li&gt;
&lt;li&gt;五种状态转换如图所示：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 396; 
			flex-basis: 950px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/1.png&#34; data-size=&#34;697x176&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/1.png&#34;
			width=&#34;697&#34;
			height=&#34;176&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/1_hu867c95a79e12df8701fb93f07d38202e_22636_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/1_hu867c95a79e12df8701fb93f07d38202e_22636_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程&#34;&gt;线程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;线程是cup调度和分配的基本单位也是cup执行的最小单位, 有独立的栈空间，共享堆空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程与线程的关系&#34;&gt;进程与线程的关系&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一个进程可以创建和撤销多个线程， 一个进程必须有一个线程(主线程), 线程共享进程所有资源，进程是线程的容器，关系如图所示：&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 282; 
			flex-basis: 677px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/2.png&#34; data-size=&#34;491x174&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/2.png&#34;
			width=&#34;491&#34;
			height=&#34;174&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/2_hu53069a5ffbb3f88620ec70a2a20f56ba_161705_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/2_hu53069a5ffbb3f88620ec70a2a20f56ba_161705_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;并发与并行&#34;&gt;并发与并行&lt;/h2&gt;
&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;并发：多进程(线程)程序在一个核cup串行运行，当一个进程(线程)阻塞的时候，切换到另外等待执行的进程(线程) 如图&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 176; 
			flex-basis: 424px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/3.png&#34; data-size=&#34;470x266&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/3.png&#34;
			width=&#34;470&#34;
			height=&#34;266&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/3_huf7020f04dcb48d893cde63f717a76dfc_28449_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/3_huf7020f04dcb48d893cde63f717a76dfc_28449_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并行&#34;&gt;并行&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;并行：多线程程序在多核cup并行运行，如图&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 193; 
			flex-basis: 463px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/4.png&#34; data-size=&#34;535x277&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/4.png&#34;
			width=&#34;535&#34;
			height=&#34;277&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/4_hu785964094345562635a27d3f581c929f_23668_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/4_hu785964094345562635a27d3f581c929f_23668_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;用户态和内核态用户空间和内核空间&#34;&gt;用户态和内核态(用户空间和内核空间)&lt;/h2&gt;
&lt;h3 id=&#34;特权级划分&#34;&gt;特权级划分&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;cpu一共有0～4四个特权级，R0级最高，R3级最低。用户态指的是：程序运行在R3级以上，通常在应用程序中运行，内核态是指：程序运行在R0级以上，通常在内核中运行。一般来说，我们写的应用程序就是运行在R3级衣以上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3中种用户态与内核态的切换&#34;&gt;3中种用户态与内核态的切换&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统调用：用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如前例中fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外围设备的中断： 当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作的完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户态与内核态结构如图：&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 121; 
			flex-basis: 291px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/5.png&#34; data-size=&#34;638x526&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/5.png&#34;
			width=&#34;638&#34;
			height=&#34;526&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/5_hua341d62eb4441aa20e3670f5a5321e7c_124841_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/5_hua341d62eb4441aa20e3670f5a5321e7c_124841_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户态与内核态的切换是需要开销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;来源：linux用户态和内核态理解(&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/weifeng1463/p/11660260.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/weifeng1463/p/11660260.html&lt;/a&gt;)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;进程与线程用户态到内核态的开销&#34;&gt;进程与线程用户态到内核态的开销&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多进程(线程)可以提高cpu的利用率，减少程序阻塞带来cpu闲置的情况，也就是提升cpu的运行时间片，但是过多的创建进程(线程)也会花费额外的cpu时间片进行进程(线程)的花销。进程的创建、就绪、运行、阻塞、终止，这些都会带来cup花销。例如在32位的操作系统中创建一个进程需要开辟4GB的虚拟内存空间，创建一个线程需要占用约4MB的内存。&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 172; 
			flex-basis: 413px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/6.png&#34; data-size=&#34;1002x582&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/6.png&#34;
			width=&#34;1002&#34;
			height=&#34;582&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/6_hud198df65b05650e861fc5dc9032c3d5f_195182_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/6_hud198df65b05650e861fc5dc9032c3d5f_195182_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程(线程)的调度也会带来cup的花销。cup进程(线程)的调度就是进程(线程)切换，进程(线程)的切换就会进行线程在内核态的调度。cup切换的内核态的线程，不操作用户态的线程，用户态线程通过系统调用触发内核线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为减少cpu内核态线程之间的切换，操作系统中使用(用户态进程(线程):内核态进程(线程))1:1，用户态直接通过系统，直接与内核态的线程一一对应。如图&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 87; 
			flex-basis: 209px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/7.png&#34; data-size=&#34;649x742&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/7.png&#34;
			width=&#34;649&#34;
			height=&#34;742&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/7_hub3d98815bced38b8bc21c868cdbcca3f_129141_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/7_hub3d98815bced38b8bc21c868cdbcca3f_129141_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户态一个进程(线程)对应一个内核态的进程(线程)是减少了内核态中进程(线程)切换的花销，但是也增加了内核态中进程(线程)创建的开销。减少内核态中进程(线程)切换与创建带来的开销，操作系统中使用(用户态进程(线程):内核态进程(线程))N:1，减少内核态中进程(线程)的创建，同时在用户态进行线程的之间的切换，不牵连内核态线程的切换，减少cup的花销。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 129; 
			flex-basis: 310px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/8.png&#34; data-size=&#34;947x733&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/8.png&#34;
			width=&#34;947&#34;
			height=&#34;733&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/8_huc6701a49375d06381df34c24cc00a698_215784_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/8_huc6701a49375d06381df34c24cc00a698_215784_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虽然N:1减少内核态中进程(线程)切换与创建带来的开销，但是当用户态的进程(线程)阻塞时，其他进程(线程)就只能等待，这造成与单线程一样的问题。操作系统结合1:1和n:1模型的有点形成n:m模型，内核态中进程(线程)进入阻塞状态时， 用户态的进程(线程)切换另一个内核态中的线程。&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 124; 
			flex-basis: 298px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/9.png&#34; data-size=&#34;832x670&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/9.png&#34;
			width=&#34;832&#34;
			height=&#34;670&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/9_hud3b7e360612e399d72998f5a6843f71d_181995_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/9_hud3b7e360612e399d72998f5a6843f71d_181995_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;协程&#34;&gt;协程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;协程和线程一样有独立的栈空间，共享堆空间，是用户级的线程，是有用户自己调度。一个线程可以创建多个协程，协程是轻量级的线程。创建一个协程只需要占用4~5kB的虚拟内存，创建协程的开销相比进程与线程低太多了。&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 231; 
			flex-basis: 555px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/c/c/10.png&#34; data-size=&#34;808x349&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/c/c/10.png&#34;
			width=&#34;808&#34;
			height=&#34;349&#34;
			srcset=&#34;https://zcj-git520.github.io/p/c/c/10_hu5bb3a4baa791897c79c1df91e792ef0e_243913_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/c/c/10_hu5bb3a4baa791897c79c1df91e792ef0e_243913_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;1、&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/337978321&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/337978321&lt;/a&gt;
2、&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/fa696563c38a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/fa696563c38a&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>go map的深入理解</title>
        <link>https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link>
        <pubDate>Mon, 20 Sep 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png" alt="Featured image of post go map的深入理解" /&gt;&lt;h1 id=&#34;goland-基础之map&#34;&gt;goland 基础之map&lt;/h1&gt;
&lt;h2 id=&#34;map的内部结构&#34;&gt;map的内部结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;go map是使用的哈希表构建的&lt;/li&gt;
&lt;li&gt;map的结构可分为：hmap的结构体和bmap(桶)，hmap结构体记录这map的基础信息(包括map存储个数，
桶的个数，hash种子，桶的数据，扩容时旧桶的数据以及迁移个数（map扩容不是一次性迁移完）)&lt;/li&gt;
&lt;li&gt;源码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;定义hmap的结构：
type hmap struct {
	// Note: the format of the hmap is also encoded in cmd/compile/internal/gc/reflect.go.
	// Make sure this stays in sync with the compiler&#39;s definition.
    // map 存储元素的计数
	count     int // # live cells == size of map.  Must be first (used by len() builtin)
    flags     uint8 // map的状态标识，桶是否在增改，扩容或者缩容
    //桶的个数/采用的与运算法计算桶的个数，桶的个数为2的整数次幂
	B         uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)
	//溢出的桶的数量的近似值
    noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details
	hash0     uint32 // hash seed
    //指向桶数据的指针
	buckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.
	// 指向旧桶数据的指针
    oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing
	//扩容计数
    nevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)
    // 保存溢出桶的链表和未使用的溢出桶数组的首地址
	extra *mapextra // optional fields
}
// 桶的实现结构
type bmap struct {
	// 当前版本bucketCnt的值是8，一个桶最多存储8个key-value对
	tophash [bucketCnt]uint8
}

&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;bmap存储结构如图所示&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 142; 
			flex-basis: 341px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1.png&#34; data-size=&#34;631x444&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1.png&#34;
			width=&#34;631&#34;
			height=&#34;444&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1_hu1600ca2579a18bcbdc1f1a6cd5b9810d_76803_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/1_hu1600ca2579a18bcbdc1f1a6cd5b9810d_76803_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;前8个是hash值，8个key和8个value、后面是溢出桶的指针&lt;/li&gt;
&lt;li&gt;溢出桶是减少map扩容次数，溢出桶的结构与bmap桶的结构一样的&lt;/li&gt;
&lt;li&gt;溢出桶的基础结构：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-//&#34; data-lang=&#34;//&#34;&gt;  type mapextra struct {
  	// If both key and elem do not contain pointers and are inline, then we mark bucket
  	// type as containing no pointers. This avoids scanning such maps.
  	// However, bmap.overflow is a pointer. In order to keep overflow buckets
  	// alive, we store pointers to all overflow buckets in hmap.extra.overflow and hmap.extra.oldoverflow.
  	// overflow and oldoverflow are only used if key and elem do not contain pointers.
  	// overflow contains overflow buckets for hmap.buckets.
  	// oldoverflow contains overflow buckets for hmap.oldbuckets.
  	// The indirection allows to store a pointer to the slice in hiter.
  	overflow    *[]*bmap  //记录已经被使用的溢出桶
  	oldoverflow *[]*bmap  // 扩容阶段旧的溢出桶
  
  	// nextOverflow holds a pointer to a free overflow bucket.
  	nextOverflow *bmap   //指向下一个空闲的溢出桶
  }
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;当桶的个数大于2的4次方时就会使用溢出桶源码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func makeBucketArray(t *maptype, b uint8, dirtyalloc unsafe.Pointer) (buckets unsafe.Pointer, nextOverflow *bmap) {
	// 桶的个数
    base := bucketShift(b)
	nbuckets := base
	// For small b, overflow buckets are unlikely.
	// Avoid the overhead of the calculation.
	if b &amp;gt;= 4 {
        // 使用溢出桶
		// Add on the estimated number of overflow buckets
		// required to insert the median number of elements
		// used with this value of b.
		nbuckets += bucketShift(b - 4)//计算溢出桶的数量和不是溢出桶的数量的和
		sz := t.bucket.size * nbuckets
		up := roundupsize(sz)
		if up != sz {
			nbuckets = up / t.bucket.size //得出桶的数量
		}
	}

	if dirtyalloc == nil {
        // 没有被创建桶，申请创建桶的，返回桶的首地址
		buckets = newarray(t.bucket, int(nbuckets))
	} else {
		// dirtyalloc was previously generated by
		// the above newarray(t.bucket, int(nbuckets))
		// but may not be empty.
		buckets = dirtyalloc
		size := t.bucket.size * nbuckets
		if t.bucket.ptrdata != 0 {
			memclrHasPointers(buckets, size)
		} else {
			memclrNoHeapPointers(buckets, size)
		}
	}

	if base != nbuckets {
		// We preallocated some overflow buckets.
		// To keep the overhead of tracking these overflow buckets to a minimum,
		// we use the convention that if a preallocated overflow bucket&#39;s overflow
		// pointer is nil, then there are more available by bumping the pointer.
		// We need a safe non-nil pointer for the last overflow bucket; just use buckets.
		//空闲桶的地址
        nextOverflow = (*bmap)(add(buckets, base*uintptr(t.bucketsize)))
		last := (*bmap)(add(buckets, (nbuckets-1)*uintptr(t.bucketsize)))
		last.setoverflow(t, (*bmap)(buckets))
	}
	return buckets, nextOverflow
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;如图所示&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 184; 
			flex-basis: 441px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2.png&#34; data-size=&#34;1636x889&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2.png&#34;
			width=&#34;1636&#34;
			height=&#34;889&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2_hu425c8a15ea5dff908d9430989255e351_318909_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/2_hu425c8a15ea5dff908d9430989255e351_318909_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;使用map时需要make(map[type]type,len,cap)才能使用。&lt;/li&gt;
&lt;li&gt;make 源码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func makemap(t *maptype, hint int, h *hmap) *hmap {
    // 判断是否超过内存的限制
	mem, overflow := math.MulUintptr(uintptr(hint), t.bucket.size)
	if overflow || mem &amp;gt; maxAlloc {
		hint = 0
	}

	// initialize Hmap
	if h == nil {
		h = new(hmap)
	}
	h.hash0 = fastrand()// 获取随机的hash值

	// Find the size parameter B which will hold the requested # of elements.
	// For hint &amp;lt; 0 overLoadFactor returns false since hint &amp;lt; bucketCnt.
	B := uint8(0)
	for overLoadFactor(hint, B) {
		B++
	}
	h.B = B

	// allocate initial hash table
	// if B == 0, the buckets field is allocated lazily later (in mapassign)
	// If hint is large zeroing this memory could take a while.
	if h.B != 0 {
		var nextOverflow *bmap
        // 创建map的存储数据，返回的桶的数据的地址，下一个溢出桶的地址
		h.buckets, nextOverflow = makeBucketArray(t, h.B, nil)
		if nextOverflow != nil {
			h.extra = new(mapextra)
			h.extra.nextOverflow = nextOverflow
		}
	}

	return h
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;map的完整结构如图：
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 259; 
			flex-basis: 623px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png&#34; data-size=&#34;1503x579&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3.png&#34;
			width=&#34;1503&#34;
			height=&#34;579&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_hu50c7ad8b87ebb1655f26b2166388bb8a_150234_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-map%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/3_hu50c7ad8b87ebb1655f26b2166388bb8a_150234_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;map扩容&#34;&gt;map扩容&lt;/h2&gt;
&lt;h3 id=&#34;扩容条件&#34;&gt;扩容条件&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当负载因子(loadFactorNum*(bucketShift(B)/loadFactorDen&amp;gt;6.5  -&amp;gt; 翻倍扩容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当负载因子小于6.5，但是溢出桶的数量大于2的15次方  -&amp;gt; 等量扩容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// overLoadFactor reports whether count items placed in 1&amp;lt;&amp;lt;B buckets is over loadFactor.
// 负载因子大于6.5
func overLoadFactor(count int, B uint8) bool {
	return count &amp;gt; bucketCnt &amp;amp;&amp;amp; uintptr(count) &amp;gt; loadFactorNum*(bucketShift(B)/loadFactorDen)
}
// 溢出桶过多时
func tooManyOverflowBuckets(noverflow uint16, B uint8) bool {
	// If the threshold is too low, we do extraneous work.
	// If the threshold is too high, maps that grow and shrink can hold on to lots of unused memory.
	// &amp;quot;too many&amp;quot; means (approximately) as many overflow buckets as regular buckets.
	// See incrnoverflow for more details.
	if B &amp;gt; 15 {
		B = 15
	}
	// The compiler doesn&#39;t see here that B &amp;lt; 16; mask B to generate shorter shift code.
	return noverflow &amp;gt;= uint16(1)&amp;lt;&amp;lt;(B&amp;amp;15)
}
// 扩容源码

func hashGrow(t *maptype, h *hmap) {
	// If we&#39;ve hit the load factor, get bigger.
	// Otherwise, there are too many overflow buckets,
	// so keep the same number of buckets and &amp;quot;grow&amp;quot; laterally.
	bigger := uint8(1)
	if !overLoadFactor(h.count+1, h.B) {
        //等量扩容
		bigger = 0
		h.flags |= sameSizeGrow
	}
	oldbuckets := h.buckets
	newbuckets, nextOverflow := makeBucketArray(t, h.B+bigger, nil)// 从新分配数据地址

	flags := h.flags &amp;amp;^ (iterator | oldIterator)
	if h.flags&amp;amp;iterator != 0 {
        // 迭代的时候搬迁旧桶
		flags |= oldIterator
	}
	// commit the grow (atomic wrt gc)
	h.B += bigger  // 桶的个数
	h.flags = flags
	h.oldbuckets = oldbuckets
	h.buckets = newbuckets
	h.nevacuate = 0
	h.noverflow = 0
    // 溢出桶钻便为旧溢出桶
	if h.extra != nil &amp;amp;&amp;amp; h.extra.overflow != nil {
		// Promote current overflow buckets to the old generation.
		if h.extra.oldoverflow != nil {
			throw(&amp;quot;oldoverflow is not nil&amp;quot;)
		}
		h.extra.oldoverflow = h.extra.overflow
		h.extra.overflow = nil
	}
	if nextOverflow != nil {
		if h.extra == nil {
			h.extra = new(mapextra)
		}
		h.extra.nextOverflow = nextOverflow
	}

	// the actual copying of the hash table data is done incrementally
	// by growWork() and evacuate().
}
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;参考文献&#34;&gt;参考文献&lt;/h2&gt;
&lt;p&gt;1.&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/people/kylin-lab&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.zhihu.com/people/kylin-lab&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>syslog日志转发配置</title>
        <link>https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/</link>
        <pubDate>Mon, 20 Sep 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/8.png" alt="Featured image of post syslog日志转发配置" /&gt;&lt;h2 id=&#34;服务器配置服务器平台x86&#34;&gt;服务器配置(服务器平台：x86)&lt;/h2&gt;
&lt;h3 id=&#34;rsyslog简介&#34;&gt;Rsyslog简介&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Rsyslog是一个 syslogd 的多线程增强版，在syslog的基础上扩展了很多其他功能，如数据库支持(MySQL, PostgreSQL、Oracle等)、日志内容筛选、定义日志格式模板等。除了默认的udp协议外，rsyslog还支持tcp协议来接收日志。&lt;/li&gt;
&lt;li&gt;目前的linux的发行版都切换为rsyslog&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;安装rsyslog&#34;&gt;安装Rsyslog&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Linux的发行版中预先安装了Rsyslog,无需安装，rsyslogd –v 查看版本&lt;/li&gt;
&lt;li&gt;若未安装，以下是安装步骤：
1.ubuntu：sudo apt install rsyslog
2.CentOS：yum install rsyslog&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;rsyslogconf配置文件详解&#34;&gt;Rsyslog.conf配置文件详解&lt;/h3&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;配置文件位置：/etc/rsyslog.conf
#### MODULES ####               #定义日志的模块。
$ModLoad imuxsock             #imuxsock为模块名，支持本地系统日志的模块。
$ModLoad imjournal            #imjournal为模块名，支持对系统日志的访问。
#$ModLoad imklog               #imklog为模块名，支持内核日志的模块。
#$ModLoad immark               #immark为模块名，支持日志标记。
# Provides UDP syslog reception   #提供udp syslog的接收。
#$ModLoad imudp               #imudp为模块名，支持udp协议。
#$UDPServerRun 514               #允许514端口接收使用udp和tcp转发来的日志。
# Provides TCP syslog reception       #提供tcp syslog的接收。
#$ModLoad imtcp              #imtcp为模块名，支持tcp协议。
#$InputTCPServerRun 514

#### GLOBAL DIRECTIVES ####    #定义全局日志格式的指令。
# Where to place auxiliary files
$WorkDirectory /var/lib/rsyslog       #工作目录。
# Use default timestamp format
$ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat  #定义日志格式默认模板。
$IncludeConfig /etc/rsyslog.d/*.conf                     #所有配置文件路径。
$OmitLocalLogging on                                      #省略本地登录。
# File to store the position in the journal
$IMJournalStateFile imjournal.state

#### RULES ####
#kern.*                                  /dev/console
#记录所有日志类型的info级别以及大于info级别的信息到messages文件，但是mail邮件信息，authpriv验证方面的信息和corn时间和任务相关信息除外。
*.info;mail.none;authpriv.none;cron.none      /var/log/messages

# authpriv验证相关的所有信息存放在/var/log/secure。
authpriv.*                                /var/log/secure

#邮件的所有信息存在/var/log/maillog；这里有一个“-”符号表示是使用异步的方式记录
mail.*                                   -/var/log/maillog

#任务计划有关的信息存放在/var/log/cron。
cron.*                                   /var/log/cron

#记录所有的≥emerg级别信息，发送给每个登录到系统的日志。
*.emerg                                 :omusrmsg:*

#记录uucp，news.crit等存放在/var/log/spooler
uucp,news.crit                            /var/log/spooler

#本地服务器的启动的所有日志存放在/var/log/boot.log
local7.*                                  /var/log/boot.log

以下为：rsyslog 客服端的配置
#发送日志，@表示传输协议（@表示udp，@@表示tcp），后面是ip和端口。
#*.* @@remote-host:514
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;配置服务器&#34;&gt;配置服务器&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用sudo vi /etc/rsyslog.conf 打开配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;选择传输的协议&#34;&gt;选择传输的协议&lt;/h4&gt;
&lt;p&gt;1.使用udp传输日志，配置时将前面的#去掉即可&lt;br&gt;
$ModLoad imudp&lt;br&gt;
$UDPServerRun 514&lt;br&gt;
2.使用tcp传输协议, 将#去点即可&lt;br&gt;
$ModLoad imtcp&lt;br&gt;
$InputTCPServerRun 514&lt;br&gt;
配置如图：&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 359; 
			flex-basis: 863px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/1.png&#34; data-size=&#34;554x154&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/1.png&#34;
			width=&#34;554&#34;
			height=&#34;154&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/1_hu77084371b4080a34a3de211f1d39cdb3_32949_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/1_hu77084371b4080a34a3de211f1d39cdb3_32949_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注明：&lt;br&gt;
514/5014端口号可以自己配置，默认为514.&lt;br&gt;
rsyslog后台进程是可以同时监听TCP/UDP连接的&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;配置接收日志模板&#34;&gt;配置接收日志模板&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在GLOBAL DIRECTIVES内容块的前面增加接收日志模板
模板如下：&lt;br&gt;
$template RemoteLogs,&amp;quot;/var/log/%HOSTNAME%/%PROGRAMNAME%.log&amp;quot;&lt;br&gt;
*.* ?RemoteLogs&lt;br&gt;
&amp;amp; ~&lt;/li&gt;
&lt;li&gt;注明：&lt;br&gt;
1、$template RemoteLogs指令（“RemoteLogs” 可以为其它的描述的名字）迫使rsyslog后台进程隔开本地/var/log/下文件去写日志信息。而日志文件名则依据发送远程日志的机器名及应用程序名来定义。&lt;br&gt;
2、*.*  ?RemoteLogs）暗含运行用模板RemoteLogs于所有的接收日志。&lt;br&gt;
3、&amp;amp; ~则告诉rsyslog后台进程停止进一步的去处理日志信息,即不对它们进行本地化写入，它是代表一个重定向规则。如果没有这一行，则意味着接收到的日志会写入两次，一次如前两行写的方式写，第二次则以本地日志记录的方式写入。运行这个规则的另一个结论则是日志服务器自己的日志信息只会写入到依照机器主机名命名的文件中。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 426; 
			flex-basis: 1022px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/2.png&#34; data-size=&#34;554x130&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/2.png&#34;
			width=&#34;554&#34;
			height=&#34;130&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/2_hu3baee738422c39b2b8b3a15300ae6fe7_26443_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/2_hu3baee738422c39b2b8b3a15300ae6fe7_26443_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;设置后，会按照模板格式保存日志
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 1065; 
			flex-basis: 2556px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/3.png&#34; data-size=&#34;554x52&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/3.png&#34;
			width=&#34;554&#34;
			height=&#34;52&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/3_hu8eaabc720939b9f1b459055b1ef23fcf_21246_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/3_hu8eaabc720939b9f1b459055b1ef23fcf_21246_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;设置完成保存&#34;&gt;设置完成，保存&lt;/h4&gt;
&lt;h3 id=&#34;检查rsyslog配置&#34;&gt;检查Rsyslog配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用命令：rsyslogd -f /etc/rsyslog.conf -N1&lt;/li&gt;
&lt;li&gt;配置信息正确有如下提示:
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 1259; 
			flex-basis: 3021px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/4.png&#34; data-size=&#34;554x44&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/4.png&#34;
			width=&#34;554&#34;
			height=&#34;44&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/4_hu7b39900913f27882a0ae7c07277316b2_23299_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/4_hu7b39900913f27882a0ae7c07277316b2_23299_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;若配置信息有误，则需要在更改配置文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重启rsyslog服务&#34;&gt;重启RSyslog服务&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Debian,Ubuntu或CentOS/RHEL 6使用:sudo service rsyslog restart&lt;/li&gt;
&lt;li&gt;Fedora 或 CentOS/RHEL 7使用：sudo systemctl restart rsyslog&lt;/li&gt;
&lt;li&gt;使用：sudo lsof -i :[端口号]，查看服务是否开启和tcp/udp连接情况
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 548; 
			flex-basis: 1316px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/5.png&#34; data-size=&#34;554x101&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/5.png&#34;
			width=&#34;554&#34;
			height=&#34;101&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/5_hub384d36617421245c9364162c8094a34_49314_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/5_hub384d36617421245c9364162c8094a34_49314_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;或使用sudo netstat -pantu | grep rsyslog
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 748; 
			flex-basis: 1796px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/6.png&#34; data-size=&#34;554x74&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/6.png&#34;
			width=&#34;554&#34;
			height=&#34;74&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/6_hud96afeb39ab29624ebbfb8d879fa92f8_35198_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/6_hud96afeb39ab29624ebbfb8d879fa92f8_35198_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查看日志&#34;&gt;查看日志&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;启动客户端，进入配置文件模板中日志保存的位置：&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 971; 
			flex-basis: 2332px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/7.png&#34; data-size=&#34;554x57&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/7.png&#34;
			width=&#34;554&#34;
			height=&#34;57&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/7_hu31450327525b5e8e578d50ab58e1813e_22403_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/7_hu31450327525b5e8e578d50ab58e1813e_22403_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 371; 
			flex-basis: 892px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/8.png&#34; data-size=&#34;554x149&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/8.png&#34;
			width=&#34;554&#34;
			height=&#34;149&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/8_hu442c80cfdca83249146ebd0d5822289f_88346_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/8_hu442c80cfdca83249146ebd0d5822289f_88346_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;若没有生成日志文件，需要使用：sudo tcpdump host 客户端ip 查看是否转发日志，有则是保存模板出问题，没有可能的服务端配置或者客户端配置出问题&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 415; 
			flex-basis: 997px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/9.png&#34; data-size=&#34;553x133&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/9.png&#34;
			width=&#34;553&#34;
			height=&#34;133&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/9_hud06aeafa785a175b3e704d37bde11243_109835_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/9_hud06aeafa785a175b3e704d37bde11243_109835_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;客户端配置&#34;&gt;客户端配置&lt;/h2&gt;
&lt;h3 id=&#34;平台x86&#34;&gt;平台：x86&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;平台是使用的rsyslog&lt;/li&gt;
&lt;li&gt;使用sudo vi /etc/rsyslog.conf 打开配置文件&lt;/li&gt;
&lt;li&gt;配置：&lt;br&gt;
发送日志，@表示传输协议（@表示udp，@@表示tcp），后面是ip和端口。&lt;br&gt;
*.* @@remote-host:514&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 769; 
			flex-basis: 1846px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/10.png&#34; data-size=&#34;554x72&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/10.png&#34;
			width=&#34;554&#34;
			height=&#34;72&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/10_hu121ce9beda989ac489d36785534a4c07_11404_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/10_hu121ce9beda989ac489d36785534a4c07_11404_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查与重启服务和x86服务器平台一样&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;平台开发板&#34;&gt;平台开发板&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;板子是使用的syslog 使用命令：ps进行查看进程&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 266; 
			flex-basis: 639px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/11.png&#34; data-size=&#34;554x208&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/11.png&#34;
			width=&#34;554&#34;
			height=&#34;208&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/11_hu4e6e3e2c799b4a539a43c7ac3ef0cfea_64168_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/11_hu4e6e3e2c799b4a539a43c7ac3ef0cfea_64168_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;li&gt;找到syslogd服务，若未找到，可能不支持syslog服务
使用命令：syslogd –h 查看syslogd支持的服务&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 271; 
			flex-basis: 651px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/12.png&#34; data-size=&#34;554x204&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/12.png&#34;
			width=&#34;554&#34;
			height=&#34;204&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/12_hu303331932f04e72e99ec8f8ee7478f8d_60851_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/12_hu303331932f04e72e99ec8f8ee7478f8d_60851_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置客户端&#34;&gt;配置客户端&lt;/h3&gt;
&lt;p&gt;1.结束之前的syslogd服务，通过使用kill 进程号 结束进程&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 537; 
			flex-basis: 1290px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13.png&#34; data-size=&#34;554x103&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13.png&#34;
			width=&#34;554&#34;
			height=&#34;103&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13_hu9fb7ecb2769d8f203208712c5df5625e_31804_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13_hu9fb7ecb2769d8f203208712c5df5625e_31804_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;
2.通过syslogd提供的服务是通过 -L  –R 服务器的ip:port&lt;br&gt;
注明：默认端口为：514,端口号应该与服务器配置的端口号一致&lt;br&gt;
3.启动syslogd服务：/sbin/syslogd -f /etc/syslog.conf -L -R 172.16.193.204:514
4.通过tcpdump host 172.16.193.204 查看日志是否被转发到服务器&lt;br&gt;
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 537; 
			flex-basis: 1290px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13.png&#34; data-size=&#34;554x103&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13.png&#34;
			width=&#34;554&#34;
			height=&#34;103&#34;
			srcset=&#34;https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13_hu9fb7ecb2769d8f203208712c5df5625e_31804_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/syslog%E6%97%A5%E5%BF%97%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE/13_hu9fb7ecb2769d8f203208712c5df5625e_31804_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注明：开发板的syslog支持UDP传输，需要开发板的日志文件需要在服务器打开UDP&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>go 切片的深入理解</title>
        <link>https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</link>
        <pubDate>Wed, 15 Sep 2021 22:00:38 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</guid>
        <description>&lt;img src="https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s4.png" alt="Featured image of post go 切片的深入理解" /&gt;&lt;h2 id=&#34;切片的内部结构&#34;&gt;切片的内部结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;切片的结构可分为：数组，数据（元素）的地址&amp;amp;data、也存元素个数len、可以存储多少元素cap&lt;/li&gt;
&lt;li&gt;源码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;定义切片的结构：
type slice struct {
	array unsafe.Pointer   
	len   int
	cap   int
}
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;如图所示&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 447; 
			flex-basis: 1075px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s1.png&#34; data-size=&#34;327x73&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s1.png&#34;
			width=&#34;327&#34;
			height=&#34;73&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s1_hufa230f30ea970ac155f1510029c77fa1_16064_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s1_hufa230f30ea970ac155f1510029c77fa1_16064_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;avatar&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;avatar&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;var data [] int 声明一个切片，相当于生成切片的结构，data地址指针为nil, len和cap都为0。这就很清楚为什么，nil切片不可以直接使用了😄 结构如图&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 425; 
			flex-basis: 1020px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s2.png&#34; data-size=&#34;357x84&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s2.png&#34;
			width=&#34;357&#34;
			height=&#34;84&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s2_hu3ecbacb1008bd2eb98e4b57b029321b8_19806_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s2_hu3ecbacb1008bd2eb98e4b57b029321b8_19806_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;avatar&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;avatar&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用切片时需要make([]type,len,cap)或者初始化[]type{}才能使用，这是因为在在生成切片的结构时，同时也开辟了一段新的内存，类型为type, 结构长度为cap,同时值进行初始化。&lt;/li&gt;
&lt;li&gt;make 源码如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func makeslice(et *_type, len, cap int) unsafe.Pointer {
	mem, overflow := math.MulUintptr(et.size, uintptr(cap))    // 判断是否越界
	if overflow || mem &amp;gt; maxAlloc || len &amp;lt; 0 || len &amp;gt; cap {
		// NOTE: Produce a &#39;len out of range&#39; error instead of a
		// &#39;cap out of range&#39; error when someone does make([]T, bignumber).
		// &#39;cap out of range&#39; is true too, but since the cap is only being
		// supplied implicitly, saying len is clearer.
		// See golang.org/issue/4085.
		mem, overflow := math.MulUintptr(et.size, uintptr(len))
		if overflow || mem &amp;gt; maxAlloc || len &amp;lt; 0 {
			panicmakeslicelen()       // 越界直接 panic
		}
		panicmakeslicecap()    // 越界直接 panic
	}

	return mallocgc(mem, et, true)  //开辟内存
}
&lt;/code&gt;&lt;/pre&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 318; 
			flex-basis: 763px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s3.png&#34; data-size=&#34;525x165&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s3.png&#34;
			width=&#34;525&#34;
			height=&#34;165&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s3_hu288b58219022501a33ccafd08b91cbd7_40298_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s3_hu288b58219022501a33ccafd08b91cbd7_40298_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;avatar&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;avatar&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;也可以通过底层数组初始化，切片的data指针指向就是相同类型的底层数组；通过slince := array[n:m],表示定义了一个类型和array相同，len为m-n,cap默认为array的长度的切片。切片和数组都指向了相同的地址。多个切片可以共用同一个底层数组。
&lt;figure 
	
		class=&#34;gallery-image&#34; 
		style=&#34;
			flex-grow: 195; 
			flex-basis: 468px&#34;
	&gt;
	&lt;a href=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s4.png&#34; data-size=&#34;531x272&#34;&gt;
		&lt;img src=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s4.png&#34;
			width=&#34;531&#34;
			height=&#34;272&#34;
			srcset=&#34;https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s4_hu1fce009c184102799b4a69d72efc8ec2_68940_480x0_resize_box_3.png 480w, https://zcj-git520.github.io/p/go-%E5%88%87%E7%89%87%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/s4_hu1fce009c184102799b4a69d72efc8ec2_68940_1024x0_resize_box_3.png 1024w&#34;
			loading=&#34;lazy&#34;
			alt=&#34;avatar&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;avatar&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过append 函数向切片增加切片的元素，增加了len, cap 不变。&lt;/p&gt;
&lt;h2 id=&#34;切片扩容&#34;&gt;切片扩容&lt;/h2&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在资源充裕的条件下，切片是可以通过append不断增加元素，当len个数增加到cap一样时，在增加元素时，就需要增加切片的容量cap，那问题来了，切片是怎么扩容的呢？&lt;/p&gt;
&lt;h3 id=&#34;扩容规则预估规则&#34;&gt;扩容规则（预估规则）&lt;/h3&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当需要扩容的数量比之前cap的两倍都大，则扩容为需要扩容的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当需要扩容的数量比之前cap的两倍都大小，之前的cap小于1024 直接扩大之前的2倍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当需要扩容的数量比之前cap的两倍都大小，之前的cap大于1024 直接扩大之前的1.25倍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;伪代码如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;if oldcap&lt;em&gt;2  &amp;lt; newcap 时， 扩容为newcap
else{ if oldcap &amp;lt; 1024     newcap = 2&lt;/em&gt;oldcap     ;  else           newcap = 1.25*oldcap }&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;源代码如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;newcap := old.cap
	doublecap := newcap + newcap     //两倍的oldcap
	if cap &amp;gt; doublecap {
//当需要扩容的数量比之前cap的两倍都大，则扩容为需要扩容的数量
		newcap = cap   
	} else {
//当需要扩容的数量比之前cap的两倍都大小，之前的cap小于1024 直接扩大之前的2倍
		if old.cap &amp;lt; 1024 {   
			newcap = doublecap
		} else {
			// Check 0 &amp;lt; newcap to detect overflow
			// and prevent an infinite loop.
当需要扩容的数量比之前cap的两倍都大小，之前的cap大于1024 直接扩大之前的1.25倍
			for 0 &amp;lt; newcap &amp;amp;&amp;amp; newcap &amp;lt; cap {
				newcap += newcap / 4
			}
			// Set newcap to the requested cap when
			// the newcap calculation overflowed.
			if newcap &amp;lt;= 0 {
				newcap = cap
			}
		}
	}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;扩容调整&#34;&gt;扩容调整&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在预估扩容后，会根据内存对齐（减少内存浪费）在进行调整，代码：capmem := roundupsize(uintptr(newcap) * uintptr(et.size))newcap就是前文中计算出的newcap，et.size代表slice中一个元素的大小，capmem计算出来的就是此次扩容需要申请的内存大小。roundupsize函数就是处理内存对齐的函数&lt;/li&gt;
&lt;li&gt;源码如下&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt; var overflow bool
 	var lenmem, newlenmem, capmem uintptr
 	switch {
 	case et.size == 1:    //例如byte 大小为1， 扩容的大小为向上取整的数值
 		lenmem = uintptr(old.len)
 		newlenmem = uintptr(cap)
 		capmem = roundupsize(uintptr(newcap)) 
 		overflow = uintptr(newcap) &amp;gt; maxAlloc
 		newcap = int(capmem)
 	case et.size == sys.PtrSize:
 		lenmem = uintptr(old.len) * sys.PtrSize
 		newlenmem = uintptr(cap) * sys.PtrSize
 		capmem = roundupsize(uintptr(newcap) * sys.PtrSize)
 		overflow = uintptr(newcap) &amp;gt; maxAlloc/sys.PtrSize
 		newcap = int(capmem / sys.PtrSize)
 	case isPowerOfTwo(et.size):  //处理2的倍数
 		var shift uintptr
 		if sys.PtrSize == 8 {
 			// Mask shift for better code generation.
 			shift = uintptr(sys.Ctz64(uint64(et.size))) &amp;amp; 63
 		} else {
 			shift = uintptr(sys.Ctz32(uint32(et.size))) &amp;amp; 31
 		}
 		lenmem = uintptr(old.len) &amp;lt;&amp;lt; shift
 		newlenmem = uintptr(cap) &amp;lt;&amp;lt; shift
 		capmem = roundupsize(uintptr(newcap) &amp;lt;&amp;lt; shift)
 		overflow = uintptr(newcap) &amp;gt; (maxAlloc &amp;gt;&amp;gt; shift)
 		newcap = int(capmem &amp;gt;&amp;gt; shift)
 	default:
 		lenmem = uintptr(old.len) * et.size
 		newlenmem = uintptr(cap) * et.size
 		capmem, overflow = math.MulUintptr(et.size, uintptr(newcap))
 		capmem = roundupsize(capmem)
 		newcap = int(capmem / et.size)
 	}
 
 	// The check of overflow in addition to capmem &amp;gt; maxAlloc is needed
 	// to prevent an overflow which can be used to trigger a segfault
 	// on 32bit architectures with this example program:
 	//
 	// type T [1&amp;lt;&amp;lt;27 + 1]int64
 	//
 	// var d T
 	// var s []T
 	//
 	// func main() {
 	//   s = append(s, d, d, d, d)
 	//   print(len(s), &amp;quot;\n&amp;quot;)
 	// }
 	if overflow || capmem &amp;gt; maxAlloc {
 		panic(errorString(&amp;quot;growslice: cap out of range&amp;quot;))
 	}

### 扩容后内存分配

* 分配 大于cap的内存，没有数据指针，memclrNoHeapPointers创建
* 源码如下：
  &amp;gt; 
	var p unsafe.Pointer
	if et.ptrdata == 0 {
		p = mallocgc(capmem, nil, false)
		// The append() that calls growslice is going to overwrite from old.len to cap (which will be the new length).
		// Only clear the part that will not be overwritten.
		memclrNoHeapPointers(add(p, newlenmem), capmem-newlenmem)
	} else {
		// Note: can&#39;t use rawmem (which avoids zeroing of memory), because then GC can scan uninitialized memory.
		p = mallocgc(capmem, et, true)  //分配内存地址
		if lenmem &amp;gt; 0 &amp;amp;&amp;amp; writeBarrier.enabled {
			// Only shade the pointers in old.array since we know the destination slice p
			// only contains nil pointers because it has been cleared during alloc.
			bulkBarrierPreWriteSrcOnly(uintptr(p), uintptr(old.array), lenmem-et.size+et.ptrdata)
		}
	}
	memmove(p, old.array, lenmem)  //数据迁移

	return slice{p, old.len, newcap}  
}
&lt;/code&gt;&lt;/pre&gt;</description>
        </item>
        <item>
        <title>我的第一份博客</title>
        <link>https://zcj-git520.github.io/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%8D%9A%E5%AE%A2/</link>
        <pubDate>Sat, 04 Sep 2021 10:05:40 +0800</pubDate>
        
        <guid>https://zcj-git520.github.io/p/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E4%BB%BD%E5%8D%9A%E5%AE%A2/</guid>
        <description>&lt;h3 id=&#34;为什么写博客&#34;&gt;为什么写博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;总结开发中遇到的问题。工作过后发现自己并不擅长对知识点的总结，导致总是遇到相同的问题，过段时间需要重新查找解决方案&lt;/li&gt;
&lt;li&gt;记录学习的知识，不断的温习。学的东西过于碎片化，导致知识不成体系。时间长了，碎片的知识也忘记了&lt;/li&gt;
&lt;li&gt;提升自己的专业技能。通过写博客提升自己的能力&lt;/li&gt;
&lt;li&gt;形成自己的技术栈，遇到的志同道合的朋友&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;为什么选择hugo来搭建自己的博客&#34;&gt;为什么选择hugo来搭建自己的博客&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Hugo是由Go语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。&lt;/li&gt;
&lt;li&gt;操作简单，使用Markdown直接生成静态网页&lt;/li&gt;
&lt;li&gt;免费且以维护, 在github上就可供他人访问，无需购买服务器，维护简单&lt;/li&gt;
&lt;li&gt;发表文章直接push到自己仓库即可&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;下载hogo的源码&#34;&gt;下载hogo的源码&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;git clone  &lt;a class=&#34;link&#34; href=&#34;https://github.com/gohugoio/hugo.git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/gohugoio/hugo.git&lt;/a&gt;&lt;br&gt;
git branch 查看单前代码的分支&lt;br&gt;
git branch -a 查看全部分支&lt;br&gt;
git checkout branch 切换分支&lt;br&gt;
git branch 分支名  创建自己的本地分子&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;编译源码&#34;&gt;编译源码&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;在master分支下，在main.go 的目录下使用命令: go build  在目录下生成hugo.exe&lt;/li&gt;
&lt;li&gt;在cmd下使用hugo 查看是否编译成功 编译成功 会打印hugo的版本&lt;/li&gt;
&lt;li&gt;安装成功&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;生成站点&#34;&gt;生成站点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用命令：hugo new site /目录&lt;/li&gt;
&lt;li&gt;cd /目录 查看到&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;            ▸ archetypes/  
            ▸ content/  
            ▸ layouts/  
            ▸ static/  
            config.toml
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;创建站点成功&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;创建md文章&#34;&gt;创建md文章&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使用命令: hugo  new 文章名.md  在content/ 下生成该md文件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选择博客主题模板&#34;&gt;选择博客主题模板&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;hugo 提供很多的主题博客模板：https://themes.gohugo.io/&lt;/li&gt;
&lt;li&gt;创建theme文件夹，将主题模板放在里面 ：mkdir themes&lt;/li&gt;
&lt;li&gt;进入该文件夹：cd themes&lt;/li&gt;
&lt;li&gt;下载主题，使用git clone 主题模板 ：git clone &lt;a class=&#34;link&#34; href=&#34;https://github.com/spf13/hyde.git&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/spf13/hyde.git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;配置configtoml文件&#34;&gt;配置config.toml文件&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;config.toul 文件hugo 的配置文件，可以配置主题模板，个人信息等(主题模板中相应的配置文件)如&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt; baseurl = &amp;quot;http://****.com/&amp;quot;  //发布的网站
 languageCode = &amp;quot;ja&amp;quot;           //使用的语言
 title = &amp;quot;xxxx.COM&amp;quot;      //网站名称等
  [Params]
  subtitle = &amp;quot;I would like to be a layer 3 switch.&amp;quot;
  facebook = &amp;quot;https://facebook.com/foobar&amp;quot;
  twitter = &amp;quot;https://twitter.com/foobar&amp;quot;
  github = &amp;quot;https://github.com/foobar&amp;quot;
  profile = &amp;quot;/images/profile.png&amp;quot;
  copyright = &amp;quot;Written by Asuka Suzuki&amp;quot;
  analytics = &amp;quot;UA-XXXXXXXX-X&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;运行&#34;&gt;运行&lt;/h3&gt;
&lt;h4 id=&#34;本地运行&#34;&gt;本地运行&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;使用命令：hugo server &amp;ndash;buildDrafts 配置正确则会出现： http://localhost:1313/ (bind address 127.0.0.1) 点击在浏览器中运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;推送到gitgub&#34;&gt;推送到gitgub&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;首先在GitHub上创建一个Repository，命名为：github用户名.github.io&lt;/li&gt;
&lt;li&gt;修改config.toml 配置文件：将baseurl = &amp;ldquo;http://github用户名.github.io&amp;rdquo;&lt;/li&gt;
&lt;li&gt;使用命令：hugo  &amp;ndash;buildDrafts 在本地生成public的文件夹&lt;/li&gt;
&lt;li&gt;&amp;ndash;buildDrafts 参数的主用是将你的文章在主题中出现&lt;/li&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;  cd public 进入到public文件夹
  $ git init  初始化本地仓库
  $ git remote add origin https://github.com/github用户名/github用户名.github.io //添加原创仓库
 或者直接 git clone 
  $ git add -A
  $ git commit -m &amp;quot;first commit&amp;quot;
  $ git push -u origin master  //推到远端
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;使用 &amp;ldquo;http://github用户名.github.io&amp;quot;就可访问&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
